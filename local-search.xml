<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>docker常用命令</title>
    <link href="/2023/06/07/debian%2011%E5%AE%89%E8%A3%85docker/"/>
    <url>/2023/06/07/debian%2011%E5%AE%89%E8%A3%85docker/</url>
    
    <content type="html"><![CDATA[<h1 id="debian-11安装docker"><a href="#debian-11安装docker" class="headerlink" title="debian 11安装docker"></a>debian 11安装docker</h1><ol><li>安装基础工具</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo apt-get update<br> sudo apt-get install \<br>    apt-transport-https \<br>    ca-certificates \<br>    curl \<br>    gnupg \<br>    lsb-release<br></code></pre></td></tr></table></figure><ol start="2"><li>安装docker的gpg key：</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg<br></code></pre></td></tr></table></figure><ol start="3"><li>安装docker源</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">echo &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null<br></code></pre></td></tr></table></figure><p>上面命令中的<code>lsb_release -cs</code>返回<code>bullseye</code>，也就是debian11的代号。</p><ol start="4"><li>安装docker</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">apt-get update<br>sudo apt-get install docker-ce docker-ce-cli containerd.io<br></code></pre></td></tr></table></figure><p>至此安装完成。</p><p>在debian系的Linux发行版上，docker会开机启动启动。</p><p>如果平时使用非root账户，又不想每次执行docker命令之前都加上sudo，参考docker的<a href="https://link.zhihu.com/?target=https://docs.docker.com/engine/install/linux-postinstall/%23manage-docker-as-a-non-root-user">文档</a>，可以添加<code>docker</code>组，并将非root账户加入到该组中。下面的命令创建<code>docker</code>组并将当前用户加入<code>docker</code>组，执行完成之后重新登陆生效：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo groupadd docker<br>sudo usermod -aG docker $USER<br></code></pre></td></tr></table></figure><h1 id="启动相关命令"><a href="#启动相关命令" class="headerlink" title="启动相关命令"></a>启动相关命令</h1><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cmd">#启动docker<br>systemctl <span class="hljs-built_in">start</span> docker<br>#查看docker状态<br>systemctl status docker<br>#停掉docker<br>systemctl stop docker<br>#重启docker<br>systemctl restart docker<br>#开机自启docker<br>systemctl enable docker<br></code></pre></td></tr></table></figure><h1 id="镜像相关命令"><a href="#镜像相关命令" class="headerlink" title="镜像相关命令"></a>镜像相关命令</h1><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cmd">#查看镜像<br>docker images<br>#查看所有镜像id<br>docker images -q<br>#搜索镜像（redis）<br>docker search redis<br>#下载<br>docker pull redis<br>#删除docker<br>docker rmi [image id]<br>#删除所有镜像<br>docker rmi `docker images -q`<br></code></pre></td></tr></table></figure><h1 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令"></a>容器相关命令</h1><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cmd">docker run -it --name=mysql mysql:<span class="hljs-number">5</span>.<span class="hljs-number">7</span> /bin/bash<br>#-i 保持容器一直运行<br>#-t 给容器分配个伪终端，可以输入命令（输入<span class="hljs-keyword">exit</span>后退出）<br>#--name 给容器取名<br>#mysql:<span class="hljs-number">5</span>.<span class="hljs-number">7</span> 使用哪个镜像<br>#/bin/bash 进入容器的初始化指令<br><br>docker run -id --name=mysql1 mysql:<span class="hljs-number">5</span>.<span class="hljs-number">7</span> <br>#-d 后台运行容器（输入<span class="hljs-keyword">exit</span>()后不退出）<br>docker exec -it mysql1 /bin/bash #进入容器<br><br>docker ps #查看正在运行的容器<br>docker ps -a #查看所有容器<br><br>docker stop mysql1 #关闭容器<br>docker <span class="hljs-built_in">start</span> mysql1 #开启容器<br>docker rm [名称，id] #删除容器<br>docker rm `docker ps -aq` #删除所有容器<br>docker inspect mysql1 #查看容器名称<br></code></pre></td></tr></table></figure><h1 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h1><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230606164746448.png" alt="image-20230606164746448" style="zoom: 33%;" /><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cmd">#创建启动容器时，使用-V参数设置数据卷<br>docker run ... -v 宿主机目求（文件）：容器内日录（文件）<br>#例子<br>docker run -it --name=cl -v /root/data:/root/data_container mysql:<span class="hljs-number">5</span>.<span class="hljs-number">7</span> /bin/bash<br>#注意事项：<br>#<span class="hljs-number">1</span>.目录必须是绝对路径<br>#<span class="hljs-number">2</span>.如果目录不存在，会自动创建<br>#<span class="hljs-number">3</span>.可以挂载多个数据卷<br>docker run -it --name=c2 \<br>-v ~/data2:/root/data2 \<br>-v ~/data3:/root/data3 \<br><span class="hljs-function">mysql:5.7</span><br><span class="hljs-function"></span><br><span class="hljs-function">#两个容器挂载同一个目录</span><br><span class="hljs-function"><span class="hljs-title">docker</span> <span class="hljs-title">run</span> -<span class="hljs-title">it</span> --<span class="hljs-title">name</span>=<span class="hljs-title">c3</span> -<span class="hljs-title">v</span> ~/<span class="hljs-title">data</span>:/<span class="hljs-title">root</span>/<span class="hljs-title">data</span> <span class="hljs-title">centos</span>:7</span><br><span class="hljs-function"><span class="hljs-title">docker</span> <span class="hljs-title">run</span> -<span class="hljs-title">it</span> --<span class="hljs-title">name</span>=<span class="hljs-title">c4</span> -<span class="hljs-title">v</span> ~/<span class="hljs-title">data</span>:/<span class="hljs-title">root</span>/<span class="hljs-title">data</span> <span class="hljs-title">centos</span>:7</span><br></code></pre></td></tr></table></figure><h1 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h1><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230606181324784.png" alt="image-20230606181324784" style="zoom:33%;" /><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmd">#多容器进行数据交换<br>#<span class="hljs-number">1</span>.多个容器挂载同一个数据卷<br>#<span class="hljs-number">2</span>.数据卷容器<br>#可以直接删c3，不影响挂载。<br>docker run -it --name=c3 -v /volume centos:<span class="hljs-number">7</span> /bin/bash<br>docker run -it --name=c1 --volumes-from c3 centos:<span class="hljs-number">7</span> /bin/bash<br>docker run -it --name=c2 --volumes-from c3 centos:<span class="hljs-number">7</span> /bin/bash<br></code></pre></td></tr></table></figure><h1 id="1-部署mysql"><a href="#1-部署mysql" class="headerlink" title="1.部署mysql"></a>1.部署mysql</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">搜索mysql镜像</span><br>docker search mysql<br><span class="hljs-meta prompt_">#</span><span class="language-bash">拉取mysql镜像</span><br>docker pull mysql:5.6<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">创建容器，设置端口映射、目录映射</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在/root目录下创建mysql目录用于存储mysql数据信息</span><br>mkdir ~/mysql<br>cd ~/mysql<br><br><br>docker run -id \<br>-p 3307:3306 \<br>--name=c_mysql \<br>-v $PWD/conf:/etc/mysql/conf.d \<br>-v $PWD/logs:/logs \<br>-v $PWD/data:/var/lib/mysql \<br>-e MYSQL_ROOT_PASSWORD=123456 \<br>mysql:5.6<br><span class="hljs-meta prompt_">#</span><span class="language-bash">参数说明：</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">-p 3307:3306：将容器的 3306 端口映射到宿主机的 3307 端口。</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">-v <span class="hljs-variable">$PWD</span>/conf:/etc/mysql/conf.d：将主机当前目录下的 conf/my.cnf 挂载到容器的 /etc/mysql/my.cnf。配置目录</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">-v <span class="hljs-variable">$PWD</span>/logs:/logs：将主机当前目录下的 logs 目录挂载到容器的 /logs。日志目录</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">-v <span class="hljs-variable">$PWD</span>/data:/var/lib/mysql ：将主机当前目录下的data目录挂载到容器的 /var/lib/mysql 。数据目录</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">-e MYSQL_ROOT_PASSWORD=123456：初始化 root 用户的密码。</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">分配终端</span><br>docker exec -it c_mysql /bin/bash<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">登录mysql</span><br>mysql -uroot -p123456<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">退出</span><br>Ctrl-C<br></code></pre></td></tr></table></figure><h1 id="2-tomcat部署"><a href="#2-tomcat部署" class="headerlink" title="2.tomcat部署"></a>2.tomcat部署</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">搜索tomcat镜像</span><br>docker search tomcat<br><span class="hljs-meta prompt_">#</span><span class="language-bash">拉取tomcat镜像</span><br>docker pull tomcat<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在/root目录下创建tomcat目录用于存储tomcat数据信息</span><br>mkdir ~/tomcat<br>cd ~/tomcat<br><br>docker run -id --name=c_tomcat \<br>-p 8080:8080 \<br>-v $PWD:/usr/local/tomcat/webapps \<br>tomcat <br><span class="hljs-meta prompt_">#</span><span class="language-bash">参数说明：</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">-p 8080:8080：将容器的8080端口映射到主机的8080端口</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">-v <span class="hljs-variable">$PWD</span>:/usr/local/tomcat/webapps：将主机中当前目录挂载到容器的webapps</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">访问</span><br>http://192.168.1.118:8080/<br></code></pre></td></tr></table></figure><h1 id="3-nginx部署"><a href="#3-nginx部署" class="headerlink" title="3.nginx部署"></a>3.nginx部署</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">搜索nginx镜像</span><br>docker search nginx<br><span class="hljs-meta prompt_">#</span><span class="language-bash">拉取nginx镜像</span><br>docker pull nginx<br><span class="hljs-meta prompt_">#</span><span class="language-bash">创建容器，设置端口映射、目录映射</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在/root目录下创建nginx目录用于存储nginx数据信息</span><br>mkdir ~/nginx<br>cd ~/nginx<br>mkdir conf<br>cd conf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在~/nginx/conf/下创建nginx.conf文件,粘贴下面内容</span><br>vim nginx.conf<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs json">user  nginx;<br>worker_processes  <span class="hljs-number">1</span>;<br><br>error_log  /var/log/nginx/error.log warn;<br>pid        /var/run/nginx.pid;<br><br><br>events <span class="hljs-punctuation">&#123;</span><br>    worker_connections  <span class="hljs-number">1024</span>;<br><span class="hljs-punctuation">&#125;</span><br><br><br>http <span class="hljs-punctuation">&#123;</span><br>    include       /etc/nginx/mime.types;<br>    default_type  application/octet-stream;<br><br>    log_format  main  &#x27;$remote_addr - $remote_user <span class="hljs-punctuation">[</span>$time_local<span class="hljs-punctuation">]</span> <span class="hljs-string">&quot;$request&quot;</span> &#x27;<br>                      &#x27;$status $body_bytes_sent <span class="hljs-string">&quot;$http_referer&quot;</span> &#x27;<br>                      &#x27;<span class="hljs-string">&quot;$http_user_agent&quot;</span> <span class="hljs-string">&quot;$http_x_forwarded_for&quot;</span>&#x27;;<br><br>    access_log  /var/log/nginx/access.log  main;<br><br>    sendfile        on;<br>    #tcp_nopush     on;<br><br>    keepalive_timeout  <span class="hljs-number">65</span>;<br><br>    #gzip  on;<br><br>    include /etc/nginx/conf.d<span class="hljs-comment">/*.conf;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"></span><br></code></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cmd">docker run -id --name=c_nginx \<br>-p <span class="hljs-number">80</span>:<span class="hljs-number">80</span> \<br>-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf \<br>-v $PWD/logs:/var/log/nginx \<br>-v $PWD/html:/usr/share/nginx/html \<br>nginx<br><br>#参数说明：<br>#-p <span class="hljs-number">80</span>:<span class="hljs-number">80</span>：将容器的 <span class="hljs-number">80</span>端口映射到宿主机的 <span class="hljs-number">80</span> 端口。<br>#-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf：将主机当前目录下的 /conf/nginx.conf 挂载到容器的 :/etc/nginx/nginx.conf。配置目录<br>#-v $PWD/logs:/var/log/nginx：将主机当前目录下的 logs 目录挂载到容器的/var/log/nginx。日志目录<br></code></pre></td></tr></table></figure><h1 id="4-redis部署"><a href="#4-redis部署" class="headerlink" title="4.redis部署"></a>4.redis部署</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">搜索redis镜像</span><br>docker search redis<br><span class="hljs-meta prompt_">#</span><span class="language-bash">拉取redis镜像</span><br>docker pull redis:5.0<br><span class="hljs-meta prompt_">#</span><span class="language-bash">创建容器，设置端口映射</span><br>docker run -id --name=c_redis -p 6379:6379 redis:5.0<br><span class="hljs-meta prompt_">#</span><span class="language-bash">使用外部机器连接redis</span><br>./redis-cli.exe -h 192.168.149.135 -p 6379<br></code></pre></td></tr></table></figure><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120130749819.png" alt="img"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120131008869.png" alt="img"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120131751168.png" alt="img"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230607142513393.png" alt="image-20230607142513393"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120132440129.png" alt="img"></p><p>演示</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120133459889.png" alt="img"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120133726220.png" alt="img"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120133948978.png" alt="img"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120134315829.png" alt="img"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120134530599.png" alt="img"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120134838135.png" alt="img"></p><h2 id="Dockerfile关键字"><a href="#Dockerfile关键字" class="headerlink" title="Dockerfile关键字"></a>Dockerfile关键字</h2><table><thead><tr><th>关键字</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>FROM</td><td>指定父镜像</td><td>指定dockerfile基于那个image构建</td></tr><tr><td>MAINTAINER</td><td>作者信息</td><td>用来标明这个dockerfile谁写的</td></tr><tr><td>LABEL</td><td>标签</td><td>用来标明dockerfile的标签 可以使用Label代替Maintainer 最终都是在docker image基本信息中可以查看</td></tr><tr><td>RUN</td><td>执行命令</td><td>执行一段命令 默认是/bin/sh 格式: RUN command 或者 RUN [“command” , “param1”,”param2”]</td></tr><tr><td>CMD</td><td>容器启动命令</td><td>提供启动容器时候的默认命令 和ENTRYPOINT配合使用.格式 CMD command param1 param2 或者 CMD [“command” , “param1”,”param2”]</td></tr><tr><td>ENTRYPOINT</td><td>入口</td><td>一般在制作一些执行就关闭的容器中会使用</td></tr><tr><td>COPY</td><td>复制文件</td><td>build的时候复制文件到image中</td></tr><tr><td>ADD</td><td>添加文件</td><td>build的时候添加文件到image中 不仅仅局限于当前build上下文 可以来源于远程服务</td></tr><tr><td>ENV</td><td>环境变量</td><td>指定build时候的环境变量 可以在启动的容器的时候 通过-e覆盖 格式ENV name=value</td></tr><tr><td>ARG</td><td>构建参数</td><td>构建参数 只在构建的时候使用的参数 如果有ENV 那么ENV的相同名字的值始终覆盖arg的参数</td></tr><tr><td>VOLUME</td><td>定义外部可以挂载的数据卷</td><td>指定build的image那些目录可以启动的时候挂载到文件系统中 启动容器的时候使用 -v 绑定 格式 VOLUME [“目录”]</td></tr><tr><td>EXPOSE</td><td>暴露端口</td><td>定义容器运行的时候监听的端口 启动容器的使用-p来绑定暴露端口 格式: EXPOSE 8080 或者 EXPOSE 8080/udp</td></tr><tr><td>WORKDIR</td><td>工作目录</td><td>指定容器内部的工作目录 如果没有创建则自动创建 如果指定/ 使用的是绝对地址 如果不是/开头那么是在上一条workdir的路径的相对路径</td></tr><tr><td>USER</td><td>指定执行用户</td><td>指定build或者启动的时候 用户 在RUN CMD ENTRYPONT执行的时候的用户</td></tr><tr><td>HEALTHCHECK</td><td>健康检查</td><td>指定监测当前容器的健康监测的命令 基本上没用 因为很多时候 应用本身有健康监测机制</td></tr><tr><td>ONBUILD</td><td>触发器</td><td>当存在ONBUILD关键字的镜像作为基础镜像的时候 当执行FROM完成之后 会执行 ONBUILD的命令 但是不影响当前镜像 用处也不怎么大</td></tr><tr><td>STOPSIGNAL</td><td>发送信号量到宿主机</td><td>该STOPSIGNAL指令设置将发送到容器的系统调用信号以退出。</td></tr><tr><td>SHELL</td><td>指定执行脚本的shell</td><td>指定RUN CMD ENTRYPOINT 执行命令的时候 使用的shell</td></tr></tbody></table><h2 id="Dockerfile案例"><a href="#Dockerfile案例" class="headerlink" title="Dockerfile案例"></a>Dockerfile案例</h2><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120163713655.png" alt="img"></p><p>准备好springboot jar包并传至宿主机的根目录</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120164903532.png" alt="img"></p><p>创建docker-files目录，并把jar包移动进去</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120165116968.png" alt="img"></p><p>创建dockerfile文件并编辑</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM java:8<br>MAINTAINER itheima &lt;itheima@itcast.cn&gt;<br>ADD HelloDocker-0.0.1-SNAPSHOT.jar app.jar<br>CMD java -jar app.jar<br></code></pre></td></tr></table></figure><p>根据dockerfile制作镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build -f ./springboot_dockerfile -t app .<br></code></pre></td></tr></table></figure><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120170212253.png" alt="img"></p><p>启动并做端口映射</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -id -p 9000:8080 app<br></code></pre></td></tr></table></figure><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120170509684.png" alt="img"></p><p>成功访问</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120170920994.png" alt="img"></p><h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120171246537.png" alt="img"></p><p>编辑dockerfile文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@hecs-33111 docker-files]# vim centos_dockerfile<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM centos:7<br>MAINTAINER itheima&lt;itheima@itcast.cn&gt;<br>RUN yum install -y vim<br>WORKDIR /usr<br>CMD /bin/bash<br></code></pre></td></tr></table></figure><p>构建镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@hecs-33111 docker-files]# docker build -f centos_dockerfile -t itheima_centos:1 .<br></code></pre></td></tr></table></figure><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120174043683.png" alt="img"></p><p>创建容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it --name=c5 itheima_centos:1<br></code></pre></td></tr></table></figure><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120174230249.png" alt="img"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120174417280.png" alt="img"></p><h1 id="服务编排"><a href="#服务编排" class="headerlink" title="服务编排"></a>服务编排</h1><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120174617528.png" alt="img"></p><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120174712386.png" alt="img"></p><h2 id="Docker-Compose-安装使用"><a href="#Docker-Compose-安装使用" class="headerlink" title="Docker Compose 安装使用"></a>Docker Compose 安装使用</h2><h3 id="一、安装Docker-Compose"><a href="#一、安装Docker-Compose" class="headerlink" title="一、安装Docker Compose"></a>一、安装Docker Compose</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">1、进入如下地址，下载版本：</span><br><br>docker-compose-Linux-x86_64<br><br>https://github.com/docker/compose/releases/tag/v2.18.1<br><span class="hljs-meta prompt_">#</span><span class="language-bash">2、拷贝至/usr/local/bin/目录下，命令如下：</span><br><br>cp 文件路径/docker-compose-Linux-x86_64 /usr/local/bin/docker-compose-Linux-x86_64<br><span class="hljs-meta prompt_">#</span><span class="language-bash">3、使用下面命令进行重命名文件，命令如下：</span><br><br>mv docker-compose-Linux-x86_64 /usr/local/bin/docker-compose<br><span class="hljs-meta prompt_">#</span><span class="language-bash">4、授予权限，命令如下：</span><br><br>chmod +x /usr/local/bin/docker-compose<br><span class="hljs-meta prompt_">#</span><span class="language-bash">5、验证是否安装成功，命令如下：</span><br><br>docker-compose -v<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置文件可执行权限</span> <br>chmod +x /usr/local/bin/docker-compose<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看版本信息</span> <br>docker-compose --version<br></code></pre></td></tr></table></figure><h3 id="二、卸载Docker-Compose"><a href="#二、卸载Docker-Compose" class="headerlink" title="二、卸载Docker Compose"></a>二、卸载Docker Compose</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">SHELL<br><span class="hljs-meta prompt_"># </span><span class="language-bash">二进制包方式安装的，删除二进制文件即可</span><br>rm /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure><h3 id="三、-使用docker-compose编排nginx-springboot项目"><a href="#三、-使用docker-compose编排nginx-springboot项目" class="headerlink" title="三、 使用docker compose编排nginx+springboot项目"></a>三、 使用docker compose编排nginx+springboot项目</h3><ol><li>创建docker-compose目录</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir ~/docker-compose<br>cd ~/docker-compose<br></code></pre></td></tr></table></figure><ol><li>编写 docker-compose.yml 文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">version: &#x27;3&#x27;<br>services:<br>  nginx:<br>   image: nginx<br>   ports:<br>    - 80:80<br>   links:<br>    - app<br>   volumes:<br>    - ./nginx/conf.d:/etc/nginx/conf.d<br>  app:<br>    image: app<br>    expose:<br>      - &quot;8080&quot;<br></code></pre></td></tr></table></figure><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120182206246.png" alt="img"></p><ol start="3"><li>创建./nginx/conf.d目录</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p ./nginx/conf.d<br></code></pre></td></tr></table></figure><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120182309055.png" alt="img"></p><ol start="4"><li>在./nginx/conf.d目录下 编写itheima.conf文件</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">server <span class="hljs-punctuation">&#123;</span><br>    listen <span class="hljs-number">80</span>;<br>    access_log off;<br><br>    location / <span class="hljs-punctuation">&#123;</span><br>        proxy_pass http<span class="hljs-punctuation">:</span><span class="hljs-comment">//app:8080;</span><br>    <span class="hljs-punctuation">&#125;</span><br>   <br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120182520017.png" alt="img"></p><ol start="5"><li>在~/docker-compose 目录下 使用docker-compose 启动容器</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose up<br></code></pre></td></tr></table></figure><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120182758615.png" alt="img"></p><ol start="6"><li>测试访问</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">http://192.168.149.135/hello<br></code></pre></td></tr></table></figure><h1 id="Docker私有仓库"><a href="#Docker私有仓库" class="headerlink" title="Docker私有仓库"></a>Docker私有仓库</h1><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120183215288.png" alt="img"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120183254474.png" alt="img"></p><h3 id="一、私有仓库搭建"><a href="#一、私有仓库搭建" class="headerlink" title="一、私有仓库搭建"></a>一、私有仓库搭建</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1、拉取私有仓库镜像</span> <br>docker pull registry<br><span class="hljs-meta prompt_"># </span><span class="language-bash">2、启动私有仓库容器</span> <br>docker run -id --name=registry -p 5000:5000 registry<br><span class="hljs-meta prompt_"># </span><span class="language-bash">3、打开浏览器 输入地址http://私有仓库服务器ip:5000/v2/_catalog，看到&#123;<span class="hljs-string">&quot;repositories&quot;</span>:[]&#125; 表示私有仓库 搭建成功</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">4、修改daemon.json</span>   <br>vim /etc/docker/daemon.json    <br><span class="hljs-meta prompt_"># </span><span class="language-bash">在上述文件中添加一个key，保存退出。此步用于让 docker 信任私有仓库地址；注意将私有仓库服务器ip修改为自己私有仓库服务器真实ip</span> <br>&#123;&quot;insecure-registries&quot;:[&quot;私有仓库服务器ip:5000&quot;]&#125; <br><span class="hljs-meta prompt_"># </span><span class="language-bash">5、重启docker 服务</span> <br>systemctl restart docker<br>docker start registry<br></code></pre></td></tr></table></figure><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120201936298.png" alt="img"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120202727139.png" alt="img"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120203058041.png" alt="img"></p><h3 id="二、将镜像上传至私有仓库"><a href="#二、将镜像上传至私有仓库" class="headerlink" title="二、将镜像上传至私有仓库"></a>二、将镜像上传至私有仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1、标记镜像为私有仓库的镜像</span>     <br>docker tag centos:7 私有仓库服务器IP:5000/centos:7<br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2、上传标记的镜像</span>     <br>docker push 私有仓库服务器IP:5000/centos:7<br></code></pre></td></tr></table></figure><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120203333919.png" alt="img"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120204528268.png" alt="img"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120204549966.png" alt="img"></p><h3 id="三、-从私有仓库拉取镜像"><a href="#三、-从私有仓库拉取镜像" class="headerlink" title="三、 从私有仓库拉取镜像"></a>三、 从私有仓库拉取镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">拉取镜像</span> <br>docker pull 私有仓库服务器ip:5000/centos:7<br></code></pre></td></tr></table></figure><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120204927944.png" alt="img"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120205000360.png" alt="img"></p><h1 id="Docker-相关观念"><a href="#Docker-相关观念" class="headerlink" title="Docker 相关观念"></a>Docker 相关观念</h1><h2 id="Docker容器化虚拟化与传统虚拟机比较"><a href="#Docker容器化虚拟化与传统虚拟机比较" class="headerlink" title="Docker容器化虚拟化与传统虚拟机比较"></a>Docker容器化虚拟化与传统虚拟机比较</h2><p><a href="https://weishao-996.github.io/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-Docker/image-20221120205141989.png"><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120205141989.png" alt="image-20221120205141989"></a></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20221120205344250.png" alt="image-20221120205344250"></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>防火墙</title>
    <link href="/2023/06/07/%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    <url>/2023/06/07/%E9%98%B2%E7%81%AB%E5%A2%99/</url>
    
    <content type="html"><![CDATA[<h1 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h1><p>查看端口</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cmd">#查看具体端口<br>netstat -anp | grep <span class="hljs-number">8080</span><br>netstat -tln | grep <span class="hljs-number">8080</span><br><br>#查看所有端口<br>netstat -anp<br>#只看server(最多)<br>netstat -tln<br><br>#查看具体端口被哪个程序占用<br>lsof -i :<span class="hljs-number">8080</span><br><br>#杀掉进程,<span class="hljs-number">2597932</span>为PID<br>kill -<span class="hljs-number">9</span> <span class="hljs-number">2597932</span><br><br><br></code></pre></td></tr></table></figure><p>防火墙</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">安装 UFW：</span><br>apt-get install ufw<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看状态</span><br>ufw status<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">添加规则，只对外开放端口 22, 80, 443 端口：</span><br>ufw allow 22/tcp<br>ufw allow 80/tcp<br>ufw allow 443/tcp<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">开启防火墙：</span><br>ufw enable<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果防火墙之前已经开启了，只需要重载规则：</span><br>ufw reload<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">删除规则</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">获得规则编号</span><br>sudo ufw status numbered<br>sudo ufw delete 2<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>debian初始化安装</title>
    <link href="/2023/06/06/Debian11%20%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <url>/2023/06/06/Debian11%20%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="Debian11-系统环境初始化"><a href="#Debian11-系统环境初始化" class="headerlink" title="Debian11 系统环境初始化"></a>Debian11 系统环境初始化</h1><h2 id="一、Debian11-查看系统环境状态"><a href="#一、Debian11-查看系统环境状态" class="headerlink" title="一、Debian11 查看系统环境状态"></a>一、Debian11 查看系统环境状态</h2><p>Debian11 系统安装后，在进行系统环境初始化之前，首先检查系统配置状态。</p><h3 id="1-1、df-命令-查看磁盘"><a href="#1-1、df-命令-查看磁盘" class="headerlink" title="1.1、df 命令 查看磁盘"></a>1.1、df 命令 查看磁盘</h3><p>df 命令 的英文全称：Disk Free，主要是用于显示系统上可使用的磁盘空间。默认显示单位为KB，建议使用 <strong>df -h</strong> 的参数组合，根据磁盘容量自动变换合适的单位，更利于阅读理解。以下为常用的查看磁盘空间的命令汇总。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">df</span> -i <span class="hljs-comment">#输出文件系统的 Inode 信息</span><br><span class="hljs-built_in">df</span> -h <span class="hljs-comment">#以人类易读的格式输出</span><br><span class="hljs-built_in">df</span> -h /data <span class="hljs-comment">#显示特定文件系统已使用的空间</span><br><span class="hljs-built_in">df</span> -h --total <span class="hljs-comment">#输出所有文件系统使用情况汇总</span><br><span class="hljs-built_in">df</span> -hT <span class="hljs-comment">#只打印本地文件系统磁盘的使用情况</span><br><span class="hljs-built_in">df</span> -a <span class="hljs-comment">#显示所有文件系统的磁盘使用情况</span><br><span class="hljs-built_in">df</span> -T <span class="hljs-comment">#输出所有已挂载文件系统的类型</span><br><span class="hljs-built_in">df</span> -k <span class="hljs-comment">#按块大小输出文件系统磁盘使用情况</span><br><span class="hljs-built_in">df</span> -t ext4 <span class="hljs-comment">#打印特定文件系统类型的磁盘使用情况</span><br><span class="hljs-built_in">df</span> -x ext4 <span class="hljs-comment">#使用 -x 选项排除特定的文件类型</span><br><span class="hljs-built_in">df</span> --output=fstype,size,iused <span class="hljs-comment">#在 df 命令的输出中只打印特定的字段</span><br></code></pre></td></tr></table></figure><h3 id="1-2、free-命令-查看内存"><a href="#1-2、free-命令-查看内存" class="headerlink" title="1.2、free 命令 查看内存"></a>1.2、free 命令 查看内存</h3><p>free 命令 主要用于查看当前系统内存的使用情况，它显示系统中剩余的及已用的物理内存和交换内存，还有共享内存和被核心使用的缓冲区等信息。</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">free</span> -<span class="hljs-string">b</span>, <span class="hljs-built_in">--bytes</span> <span class="hljs-comment">#以字节显示输出</span><br><span class="hljs-string">free</span> -<span class="hljs-string">k</span>, <span class="hljs-built_in">--kibi</span> <span class="hljs-comment">#以千字节显示输出</span><br><span class="hljs-string">free</span> -<span class="hljs-string">m</span>, <span class="hljs-built_in">--mebi</span> <span class="hljs-comment">#以兆字节显示输出</span><br><span class="hljs-string">free</span> -<span class="hljs-string">g</span>, <span class="hljs-built_in">--gibi</span> <span class="hljs-comment">#以千兆字节显示输出</span><br><span class="hljs-string">free</span> <span class="hljs-built_in">--tebi</span> <span class="hljs-comment">#以兆兆字节显示输出</span><br><span class="hljs-string">free</span> <span class="hljs-built_in">--pebi</span> <span class="hljs-comment">#以拍字节显示输出</span><br><span class="hljs-string">free</span> -<span class="hljs-string">h</span>, <span class="hljs-built_in">--human</span> <span class="hljs-comment">#显示人类可读的输出</span><br><span class="hljs-string">free</span> <span class="hljs-built_in">--si</span> <span class="hljs-comment">#使用 1000 的倍数而非使用 1024</span><br><span class="hljs-string">free</span> -<span class="hljs-string">l</span>, <span class="hljs-built_in">--lohi</span> <span class="hljs-comment">#显示详细的内存高低统计信息</span><br><span class="hljs-string">free</span> -<span class="hljs-string">t</span>, <span class="hljs-built_in">--total</span> <span class="hljs-comment">#显示内存+交换的总数</span><br><span class="hljs-string">free</span> -<span class="hljs-string">s</span> <span class="hljs-string">N</span>, <span class="hljs-built_in">--seconds</span> <span class="hljs-string">N</span> <span class="hljs-comment">#每N秒重复打印一次</span><br><span class="hljs-string">free</span> -<span class="hljs-string">c</span> <span class="hljs-string">N</span>, <span class="hljs-built_in">--count</span> <span class="hljs-string">N</span> <span class="hljs-comment">#重复打印N次，然后退出</span><br><span class="hljs-string">free</span> -<span class="hljs-string">w</span>, <span class="hljs-built_in">--wide</span> <span class="hljs-comment">#宽版输出</span><br></code></pre></td></tr></table></figure><h3 id="1-3、查看其它"><a href="#1-3、查看其它" class="headerlink" title="1.3、查看其它"></a>1.3、查看其它</h3><p>主要用于查看 Debian11 系统基础硬件配置，如CPU、内存、磁盘、系统内核版本信息等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /proc/cpuinfo <span class="hljs-comment">#查看CPU详情</span><br><span class="hljs-built_in">cat</span> /proc/cpuinfo | grep <span class="hljs-string">&quot;model name&quot;</span> <span class="hljs-comment">#查看CPU详情并指定字段</span><br>fdisk -l, --list <span class="hljs-comment">#查看磁盘分区并退出</span><br>fdisk -x, --list-details <span class="hljs-comment">#查看更多磁盘分区并退出</span><br><span class="hljs-built_in">cat</span> /proc/meminfo <span class="hljs-comment">#查看内存详情</span><br><span class="hljs-built_in">cat</span> /proc/meminfo | grep <span class="hljs-string">&quot;MemTotal&quot;</span> <span class="hljs-comment">#查看内存详情并指定字段</span><br><span class="hljs-built_in">uname</span> -r <span class="hljs-comment">#显示操作系统的发行版号</span><br><span class="hljs-built_in">uname</span> -a <span class="hljs-comment">#显示系统名称、节点名称、操作系统的发行版号、内核版本等</span><br></code></pre></td></tr></table></figure><h2 id="二、Debian11-系统环境初始化"><a href="#二、Debian11-系统环境初始化" class="headerlink" title="二、Debian11 系统环境初始化"></a>二、Debian11 系统环境初始化</h2><h3 id="2-1、系统升级"><a href="#2-1、系统升级" class="headerlink" title="2.1、系统升级"></a>2.1、系统升级</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">apt</span> update -y <span class="hljs-comment">#更新系统的包索引或包列表，它不会升级任何软件</span><br>apt upgrade -y <span class="hljs-comment">#将您的软件包升级到最新版本，含软件、安全更新和相关依赖</span><br></code></pre></td></tr></table></figure><h3 id="2-2、安装-SSH"><a href="#2-2、安装-SSH" class="headerlink" title="2.2、安装 SSH"></a>2.2、安装 SSH</h3><p>一般云服务器厂商提供安装的 Linux 操作系统已经自带SSH用于远程链接，但是通过本地安装的虚拟机可能需要手动安装SSH，SSH安装和查看命令如下。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">apt install ssh <span class="hljs-comment">#安装SSH</span><br><span class="hljs-regexp">/etc/i</span>nit.d/ssh restart <span class="hljs-comment">#重启SSH</span><br>vim <span class="hljs-regexp">/etc/</span>ssh/ssh_config <span class="hljs-comment">#查看配置信息</span><br></code></pre></td></tr></table></figure><p>简单的SSH配置参数，按需调整：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">Port<span class="hljs-number"> 22 </span><span class="hljs-comment">#修改默认端口号</span><br>PermitRootLogin yes <span class="hljs-comment">#修改root用户可以登录</span><br>ClientAliveInterval<span class="hljs-number"> 60 </span><span class="hljs-comment">#指定服务器端向客户端请求消息的时间间隔</span><br>ClientAliveCountMax<span class="hljs-number"> 3 </span><span class="hljs-comment">#表示服务器发出请求后客户端没有响应的次数达到一定值, 就自动断开</span><br></code></pre></td></tr></table></figure><h3 id="2-3、设置系统时区"><a href="#2-3、设置系统时区" class="headerlink" title="2.3、设置系统时区"></a>2.3、设置系统时区</h3><p>系统时区是指服务器运行使用的时区，一般中国可以设置为上海时区，欧洲设置为德国柏林时区，美国设置为纽约时区，您还可以根据实际需要设置服务器需要的时区。</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">timedatectl</span> <span class="hljs-built_in">list-timezones</span> <span class="hljs-comment">#列出系统支持的时区</span><br><span class="hljs-string">timedatectl</span> <span class="hljs-built_in">set-timezone</span> <span class="hljs-string">Asia</span>/<span class="hljs-string">Shanghai</span> <span class="hljs-comment">#设置时区为中国上海</span><br><span class="hljs-string">timedatectl</span> <span class="hljs-built_in">set-timezone</span> <span class="hljs-string">Europe</span>/<span class="hljs-string">Berlin</span> <span class="hljs-comment">#设置时区为德国柏林</span><br><span class="hljs-string">timedatectl</span> <span class="hljs-built_in">set-timezone</span> <span class="hljs-string">America</span>/<span class="hljs-string">New_York</span> <span class="hljs-comment">#设置时区为美国纽约</span><br><span class="hljs-string">timedatectl</span> <span class="hljs-comment">#查看系统当前时区</span><br></code></pre></td></tr></table></figure><h3 id="2-4、设置UFW防火墙"><a href="#2-4、设置UFW防火墙" class="headerlink" title="2.4、设置UFW防火墙"></a>2.4、设置UFW防火墙</h3><p>ufw 作为 Debian11 系统官方默认使用的防火墙，它是一个主机端的类似于iptables防火墙配置工具，简单好用。一般场景下使用ufw已经可以满足基本安全需求了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt install ufw <span class="hljs-comment">#安装防火墙</span><br>ufw allow ssh <span class="hljs-comment">#开放ssh服务</span><br>ufw allow 22/tcp <span class="hljs-comment">#开放22端口</span><br>ufw allow 22/udp <span class="hljs-comment">#开放22端口</span><br>ufw delete allow 80/tcp <span class="hljs-comment">#禁止开放80端口</span><br>ufw allow from 1.1.1.1 to any port 22 <span class="hljs-comment">#允许指定地址访问本机指定端口</span><br>ufw <span class="hljs-built_in">enable</span> <span class="hljs-comment">#开启</span><br>ufw <span class="hljs-built_in">disable</span> <span class="hljs-comment">#禁用</span><br>ufw reload <span class="hljs-comment">#重启</span><br>ufw status <span class="hljs-comment">#查看状态</span><br></code></pre></td></tr></table></figure><h3 id="2-5、设置DNS"><a href="#2-5、设置DNS" class="headerlink" title="2.5、设置DNS"></a>2.5、设置DNS</h3><p>通过命令：vim /etc/resolv.conf 打开，在底部添加如下参数，然后重启。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">nameserver</span> <span class="hljs-number">114.114.114.114</span> <span class="hljs-comment">#大陆电信DNS</span><br>nameserver <span class="hljs-number">8.8.8.8</span> <span class="hljs-comment">#海外谷歌DNS</span><br>systemctl restart networking <span class="hljs-comment">#重启网络</span><br></code></pre></td></tr></table></figure><h3 id="2-6、设置镜像源"><a href="#2-6、设置镜像源" class="headerlink" title="2.6、设置镜像源"></a>2.6、设置镜像源</h3><p>通过命令：vim /etc/apt/sources.list 打开，在底部添加如下参数，以下仅为示例。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">deb http:<span class="hljs-regexp">//</span>ftp.cn.debian.org/debian sid main <br></code></pre></td></tr></table></figure><p>镜像源如果为 https 开头，则需要安装如下服务：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">apt</span> install apt-trans<span class="hljs-keyword">port</span>-https ca-certificates<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>debian安装</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux下使用pytorch(服务器)</title>
    <link href="/2023/06/05/readme/"/>
    <url>/2023/06/05/readme/</url>
    
    <content type="html"><![CDATA[<h2 id="Conda环境"><a href="#Conda环境" class="headerlink" title="Conda环境"></a>Conda环境</h2><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230516163153471.png" alt="image-20230516163153471"></p><h2 id="torch环境"><a href="#torch环境" class="headerlink" title="torch环境"></a>torch环境</h2><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230516163334492.png" alt="image-20230516163334492"></p><h2 id="自己账户下使用Pytorch"><a href="#自己账户下使用Pytorch" class="headerlink" title="自己账户下使用Pytorch"></a>自己账户下使用Pytorch</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmd">#执行初始化操作，将Conda环境变量等写入bashrc，然后新连接ssh<br>/opt/anaconda3/bin/conda init bash<br>#普通用户执行启动配置<br>source ~/.bashrc<br>#激活torch环境<br>conda activate torch<br></code></pre></td></tr></table></figure><h2 id="Vscode远程连接"><a href="#Vscode远程连接" class="headerlink" title="Vscode远程连接"></a>Vscode远程连接</h2><h3 id="1、安装插件"><a href="#1、安装插件" class="headerlink" title="1、安装插件"></a>1、安装插件</h3><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230516163437478.png" alt="image-20230516163437478"></p><h3 id="2、连接"><a href="#2、连接" class="headerlink" title="2、连接"></a>2、连接</h3><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230516163726362.png" alt="image-20230516163726362"></p><h3 id="3、打开文件夹"><a href="#3、打开文件夹" class="headerlink" title="3、打开文件夹"></a>3、打开文件夹</h3><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230516163855433.png" alt="image-20230516163855433"></p><h3 id="4、运行文件"><a href="#4、运行文件" class="headerlink" title="4、运行文件"></a>4、运行文件</h3><p>如果缺依赖，百度一下安装方式（pip install , conda install 等）</p><p>去linux激活的torch环境下安装(现在默认torch环境公用，需要自己创建环境可参考：<a href="https://blog.csdn.net/weixin_44021149/article/details/126265328">https://blog.csdn.net/weixin_44021149/article/details/126265328</a>)</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230516164043996.png" alt="image-20230516164043996"></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件格式设计</title>
    <link href="/2023/06/05/%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/06/05/%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="文件格式设计"><a href="#文件格式设计" class="headerlink" title="文件格式设计"></a>文件格式设计</h1><p><strong>大数据中不同文件格式的比较</strong>：<a href="https://blog.csdn.net/weixin_41446370/article/details/121650901">https://blog.csdn.net/weixin_41446370/article/details/121650901</a></p><p><a href="https://www.jianshu.com/p/9009d652ed64">https://www.jianshu.com/p/9009d652ed64</a></p><p><strong>解析四种大数据文件格式</strong>：<a href="https://www.easemob.com/news/3594">https://www.easemob.com/news/3594</a></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230525190147294.png" alt="image-20230525190147294"></p><p>Parquent文档：<a href="https://parquet.apache.org/docs/">Documentation | Apache Parquet</a></p><p><strong>JAVA中使用Parquent:</strong><a href="https://github.com/apache/parquet-mr">GitHub - apache/parquet-mr： Apache Parquet</a></p><p>在C++中，您可以使用 Apache Arrow 库，该库包括一个本机多线程C++适配器，用于内存中的 Arrow 数据。您可以在此处找到文档和示例：<a href="https://arrow.apache.org/docs/cpp/parquet.html">https://arrow.apache.org/docs/cpp/parquet.html</a></p><p>在 Python 中，您可以使用 PyArrow 库，其中包括 Apache Parquet C++实现的 Python 绑定。您还可以使用 pandas 通过 PyArrow 读取和写入 Parquet 文件。您可以在此处找到文档和示例：<a href="https://arrow.apache.org/docs/python/parquet.html">https://arrow.apache.org/docs/python/parquet.html</a></p><p>parquet格式设计参考：<a href="https://github.com/apache/parquet-format/blob/master/LogicalTypes.md#schema-representation">parquet-format/LogicalTypes.md at master ·阿帕奇/镶木地板格式 ·GitHub</a></p><p>基于Java实现Avro文件读写功能：<a href="https://blog.csdn.net/weixin_39636364/article/details/122994220">https://blog.csdn.net/weixin_39636364/article/details/122994220</a></p><p>C++ JSON快速解析：<a href="https://github.com/simdjson/simdjson">https://github.com/simdjson/simdjson</a></p><p>avro文档：<a href="https://avro.apache.org/docs/1.11.1/">Apache Avro™ 1.11.1 文档 |阿帕奇·阿夫罗</a></p><p>python读取avro:<a href="https://fastavro.readthedocs.io/en/latest/">fastavro — fastavro 1.7.3 documentation</a></p><table><thead><tr><th>TXT大小</th><th>AVRO大小(deflate压缩)</th><th>parquet(gzip压缩)</th><th>parquet（写入，读取）</th><th>AVRO速度（写入，读取）</th><th>TXT(CSV)读取速度</th></tr></thead><tbody><tr><td>32M文件</td><td>5M</td><td>16M</td><td>JAVA:1172 毫秒/126 毫秒</td><td>JAVA: 写：784 毫秒/               读：239 毫秒.(官方库)</td><td>JAVA:703 毫秒.</td></tr><tr><td>129列，4万点</td><td></td><td></td><td>PYTHON：写：0.81秒/读：0.030秒</td><td>PYTHON：写：3.21秒/               读：1.50秒(fastavro)</td><td>PYTHON：0.38秒</td></tr><tr><td>400M</td><td>47M</td><td>93M</td><td>JAVA:11452 毫秒/1326 毫秒</td><td>JAVA:  写：9686 毫秒/                读：2706 毫秒  (官方库)</td><td>JAVA:10510 毫秒</td></tr><tr><td>129列，50万点</td><td></td><td></td><td>PYTHON：写：10.12秒/读：0.249秒</td><td>PYTHON：写：40.86秒/         读：21.63秒(fastavro)</td><td>PYTHON：3.78 秒</td></tr></tbody></table><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;doc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;A flightData.&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;flightData&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;record&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;fields&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Info&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;string&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;records&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;map&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;keys&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;string&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;values&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;array&quot;</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;items&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;float&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;null&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;boolean&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;int&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;doc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;A flightData.&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;flightData&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;record&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;fields&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Info&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;string&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;time&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;map&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;keys&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;string&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;values&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;array&quot;</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;items&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;float&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;null&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;boolean&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;int&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;analogQuantity&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;map&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;keys&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;string&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;values&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;array&quot;</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;items&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;float&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;null&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;boolean&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;int&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;digitalQuantity&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;map&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;keys&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;string&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;values&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;array&quot;</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;items&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;float&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;null&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;boolean&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;int&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>读入时需要把”\r\n”替换为“\n”</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">message flightData &#123;<br>    optional <span class="hljs-keyword">group</span> <span class="hljs-title">time</span> (MAP) &#123;<br>        required binary key (UTF8);<br>        optional <span class="hljs-keyword">group</span> <span class="hljs-title">value</span> (LIST) &#123;<br>            repeated <span class="hljs-keyword">group</span> <span class="hljs-title">list</span> &#123;<br>                repeated INT64 element;<br>            &#125;<br>        &#125;<br>    &#125;<br>    optional <span class="hljs-keyword">group</span> <span class="hljs-title">analog-quantity</span> (MAP) &#123;<br>        repeated <span class="hljs-keyword">group</span> <span class="hljs-title">key_value</span> &#123;<br>            required binary key (UTF8);<br>            optional <span class="hljs-keyword">group</span> <span class="hljs-title">value</span> (LIST) &#123;<br>                repeated <span class="hljs-keyword">group</span> <span class="hljs-title">list</span> &#123;<br>                optional DOUBLE element;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    optional <span class="hljs-keyword">group</span> <span class="hljs-title">digital-quantity</span> (MAP) &#123;<br>        repeated <span class="hljs-keyword">group</span> <span class="hljs-title">key_value</span> &#123;<br>        required binary key (UTF8);<br>            optional <span class="hljs-keyword">group</span> <span class="hljs-title">value</span> (LIST) &#123;<br>                repeated <span class="hljs-keyword">group</span> <span class="hljs-title">list</span> &#123;<br>                    repeated BOOLEAN element;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">message</span> schema &#123;<br>  <span class="hljs-attribute">optional</span> int64 time;<br>  <span class="hljs-attribute">optional</span> double p1;<br>  <span class="hljs-attribute">optional</span> double p2;<br>  <span class="hljs-attribute">optional</span> double p3;<br>  <span class="hljs-attribute">optional</span> double p4;<br>  <span class="hljs-attribute">optional</span> double p5;<br>  <span class="hljs-attribute">optional</span> double p6;<br>  <span class="hljs-attribute">optional</span> double p7;<br>  <span class="hljs-attribute">optional</span> double p8;<br>  <span class="hljs-attribute">optional</span> double p9;<br>  <span class="hljs-attribute">optional</span> double p10;<br>  <span class="hljs-attribute">optional</span> double p11;<br>  <span class="hljs-attribute">optional</span> double p12;<br>  <span class="hljs-attribute">optional</span> double p21;<br>  <span class="hljs-attribute">optional</span> double p22;<br>  <span class="hljs-attribute">optional</span> double p23;<br>  <span class="hljs-attribute">optional</span> double p24;<br>  <span class="hljs-attribute">optional</span> double p25;<br>  <span class="hljs-attribute">optional</span> double p26;<br>  <span class="hljs-attribute">optional</span> double p27;<br>  <span class="hljs-attribute">optional</span> double p28;<br>  <span class="hljs-attribute">optional</span> double p29;<br>  <span class="hljs-attribute">optional</span> double p30;<br>  <span class="hljs-attribute">optional</span> double p31;<br>  <span class="hljs-attribute">optional</span> double p32;<br>  <span class="hljs-attribute">optional</span> double p41;<br>  <span class="hljs-attribute">optional</span> double p42;<br>  <span class="hljs-attribute">optional</span> double p43;<br>  <span class="hljs-attribute">optional</span> double p44;<br>  <span class="hljs-attribute">optional</span> double p45;<br>  <span class="hljs-attribute">optional</span> double p46;<br>  <span class="hljs-attribute">optional</span> double p47;<br>  <span class="hljs-attribute">optional</span> double p48;<br>  <span class="hljs-attribute">optional</span> double p49;<br>  <span class="hljs-attribute">optional</span> double p50;<br>  <span class="hljs-attribute">optional</span> double p51;<br>  <span class="hljs-attribute">optional</span> double p52;<br>  <span class="hljs-attribute">optional</span> double p61;<br>  <span class="hljs-attribute">optional</span> double p62;<br>  <span class="hljs-attribute">optional</span> double p63;<br>  <span class="hljs-attribute">optional</span> double p64;<br>  <span class="hljs-attribute">optional</span> double p65;<br>  <span class="hljs-attribute">optional</span> double p66;<br>  <span class="hljs-attribute">optional</span> double p67;<br>  <span class="hljs-attribute">optional</span> double p68;<br>  <span class="hljs-attribute">optional</span> double p69;<br>  <span class="hljs-attribute">optional</span> double p70;<br>  <span class="hljs-attribute">optional</span> double p71;<br>  <span class="hljs-attribute">optional</span> double p72;<br>  <span class="hljs-attribute">optional</span> int64 n1;<br>  <span class="hljs-attribute">optional</span> int64 n2;<br>  <span class="hljs-attribute">optional</span> int64 n3;<br>  <span class="hljs-attribute">optional</span> int64 n4;<br>  <span class="hljs-attribute">optional</span> int64 n5;<br>  <span class="hljs-attribute">optional</span> int64 n6;<br>  <span class="hljs-attribute">optional</span> int64 n7;<br>  <span class="hljs-attribute">optional</span> int64 n8;<br>  <span class="hljs-attribute">optional</span> int64 n11;<br>  <span class="hljs-attribute">optional</span> int64 n12;<br>  <span class="hljs-attribute">optional</span> int64 n13;<br>  <span class="hljs-attribute">optional</span> int64 n14;<br>  <span class="hljs-attribute">optional</span> int64 n15;<br>  <span class="hljs-attribute">optional</span> int64 n16;<br>  <span class="hljs-attribute">optional</span> int64 n17;<br>  <span class="hljs-attribute">optional</span> int64 n18;<br>  <span class="hljs-attribute">optional</span> int64 n21;<br>  <span class="hljs-attribute">optional</span> int64 n22;<br>  <span class="hljs-attribute">optional</span> int64 n23;<br>  <span class="hljs-attribute">optional</span> int64 n24;<br>  <span class="hljs-attribute">optional</span> int64 n25;<br>  <span class="hljs-attribute">optional</span> int64 n26;<br>  <span class="hljs-attribute">optional</span> int64 n27;<br>  <span class="hljs-attribute">optional</span> int64 n28;<br>  <span class="hljs-attribute">optional</span> int64 n31;<br>  <span class="hljs-attribute">optional</span> int64 n32;<br>  <span class="hljs-attribute">optional</span> int64 n33;<br>  <span class="hljs-attribute">optional</span> int64 n34;<br>  <span class="hljs-attribute">optional</span> int64 n35;<br>  <span class="hljs-attribute">optional</span> int64 n36;<br>  <span class="hljs-attribute">optional</span> int64 n37;<br>  <span class="hljs-attribute">optional</span> int64 n38;<br>  <span class="hljs-attribute">optional</span> int64 n41;<br>  <span class="hljs-attribute">optional</span> int64 n42;<br>  <span class="hljs-attribute">optional</span> int64 n43;<br>  <span class="hljs-attribute">optional</span> int64 n44;<br>  <span class="hljs-attribute">optional</span> int64 n45;<br>  <span class="hljs-attribute">optional</span> int64 n46;<br>  <span class="hljs-attribute">optional</span> int64 n47;<br>  <span class="hljs-attribute">optional</span> int64 n48;<br>  <span class="hljs-attribute">optional</span> int64 n51;<br>  <span class="hljs-attribute">optional</span> int64 n52;<br>  <span class="hljs-attribute">optional</span> int64 n53;<br>  <span class="hljs-attribute">optional</span> int64 n54;<br>  <span class="hljs-attribute">optional</span> int64 n55;<br>  <span class="hljs-attribute">optional</span> int64 n56;<br>  <span class="hljs-attribute">optional</span> int64 n57;<br>  <span class="hljs-attribute">optional</span> int64 n58;<br>  <span class="hljs-attribute">optional</span> int64 n61;<br>  <span class="hljs-attribute">optional</span> int64 n62;<br>  <span class="hljs-attribute">optional</span> int64 n63;<br>  <span class="hljs-attribute">optional</span> int64 n64;<br>  <span class="hljs-attribute">optional</span> int64 n65;<br>  <span class="hljs-attribute">optional</span> int64 n66;<br>  <span class="hljs-attribute">optional</span> int64 n67;<br>  <span class="hljs-attribute">optional</span> int64 n68;<br>  <span class="hljs-attribute">optional</span> int64 n71;<br>  <span class="hljs-attribute">optional</span> int64 n72;<br>  <span class="hljs-attribute">optional</span> int64 n73;<br>  <span class="hljs-attribute">optional</span> int64 n74;<br>  <span class="hljs-attribute">optional</span> int64 n75;<br>  <span class="hljs-attribute">optional</span> int64 n76;<br>  <span class="hljs-attribute">optional</span> int64 n77;<br>  <span class="hljs-attribute">optional</span> int64 n78;<br>  <span class="hljs-attribute">optional</span> int64 n81;<br>  <span class="hljs-attribute">optional</span> int64 n82;<br>  <span class="hljs-attribute">optional</span> int64 n83;<br>  <span class="hljs-attribute">optional</span> int64 n84;<br>  <span class="hljs-attribute">optional</span> int64 n85;<br>  <span class="hljs-attribute">optional</span> int64 n86;<br>  <span class="hljs-attribute">optional</span> int64 n87;<br>  <span class="hljs-attribute">optional</span> int64 n88;<br>  <span class="hljs-attribute">optional</span> int64 n91;<br>  <span class="hljs-attribute">optional</span> int64 n92;<br>  <span class="hljs-attribute">optional</span> int64 n93;<br>  <span class="hljs-attribute">optional</span> int64 n94;<br>  <span class="hljs-attribute">optional</span> int64 n95;<br>  <span class="hljs-attribute">optional</span> int64 n96;<br>  <span class="hljs-attribute">optional</span> int64 n97;<br>  <span class="hljs-attribute">optional</span> int64 n98;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>遇到的坑：</strong></p><p><a href="https://blog.csdn.net/HeyShHeyou/article/details/103441110">(113条消息) 大数据学习踩坑之 HADOOP_HOME and hadoop.home.dir are unset._偷偷玩两下的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/whs0329/article/details/121878162">关于IDEA出现报错： java.io.FileNotFoundException: HADOOP_HOME and hadoop.home.dir are unset.</a></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>常用大数据数据格式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux之硬盘</title>
    <link href="/2023/06/05/Linux%E4%B9%8B%E7%A1%AC%E7%9B%98%E7%9A%84%E6%A0%B9%E7%9B%AE%E5%BD%95%E6%89%A9%E5%AE%B9%E3%80%81%E6%96%B0%E5%BB%BA%E5%88%86%E5%8C%BA%E3%80%81%E5%88%A0%E9%99%A4%E5%88%86%E5%8C%BA%EF%BC%8C%E6%8C%82%E8%BD%BD%E5%88%86%E5%8C%BA/"/>
    <url>/2023/06/05/Linux%E4%B9%8B%E7%A1%AC%E7%9B%98%E7%9A%84%E6%A0%B9%E7%9B%AE%E5%BD%95%E6%89%A9%E5%AE%B9%E3%80%81%E6%96%B0%E5%BB%BA%E5%88%86%E5%8C%BA%E3%80%81%E5%88%A0%E9%99%A4%E5%88%86%E5%8C%BA%EF%BC%8C%E6%8C%82%E8%BD%BD%E5%88%86%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux之硬盘的根目录扩容、新建分区、删除分区，挂载分区"><a href="#Linux之硬盘的根目录扩容、新建分区、删除分区，挂载分区" class="headerlink" title="Linux之硬盘的根目录扩容、新建分区、删除分区，挂载分区"></a>Linux之硬盘的根目录扩容、新建分区、删除分区，挂载分区</h1><h2 id="一、新建分区、删除分区、挂载分区："><a href="#一、新建分区、删除分区、挂载分区：" class="headerlink" title="一、新建分区、删除分区、挂载分区："></a>一、新建分区、删除分区、挂载分区：</h2><p>root权限下操作：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span>、fdisk -l    <span class="hljs-comment">#查看硬盘信息</span><br><br><span class="hljs-number">2</span>、fdsik <span class="hljs-regexp">/dev/</span>sda   <span class="hljs-comment">#对该硬盘进行操作   （一般硬盘为 /dev/sda）</span><br><br><span class="hljs-number">3</span>、键入：n    <span class="hljs-comment">#n为新建分区</span><br>   键入：d    <span class="hljs-comment">#键入d为删除分区，根据提示选择1,2,3来进行删除分区</span><br><br><br>我们以主分区为例:<br><span class="hljs-number">4</span>、键入：p         <span class="hljs-comment">#键入：p    #创建主分区</span><br>                  <span class="hljs-comment">#键入：l    #创建逻辑分区</span><br><br><br><span class="hljs-number">5</span>、此时会提示默认分区名：<br>如果直接回车则为默认分区名，也可指定分区名。指定分区名则<br>键入：sda4        因为我这里已经有sda1，sda2，sda3分区了<br><br><span class="hljs-number">6</span>、此时要输入硬盘的起始大小：<br>直接回车默认即可<br><br><span class="hljs-number">7</span>、此时要输入硬盘的结束大小：<br>可以输入提示的值，或者直接回车默认值（建议直接回车，选择默认最好）<br><br><span class="hljs-number">8</span>、键入：w    <span class="hljs-comment">#保存退出的意思</span><br><br>---此时已经分区完毕---<br><br><span class="hljs-number">9</span>、执行：reboot        <span class="hljs-comment">#重启系统</span><br><br><br><span class="hljs-number">10</span>、格式化该新添加的分区：<br><br>mkfs.ext4  <span class="hljs-regexp">/dev/</span>sda4  <span class="hljs-comment">#格式化指定的分区,依次类推（格式化之后，执行df -l 或者fdisk -l进行查看）</span><br><br><span class="hljs-number">11</span>、挂载分区<br>本案例为开机自动挂载<br><br>执行：vim <span class="hljs-regexp">/etc/</span>fstab<br><span class="hljs-regexp">/dev/</span>sda3           /挂载路径        ext4     defaults        <span class="hljs-number">0</span>     <span class="hljs-number">0</span><br><br><span class="hljs-comment">#挂载路径为想要挂载到的地方，可以选择新创建一个文件夹，然后这里为该文件夹的路径，挂载到该文件夹下面，打开创建好的文件夹后，终端执行pwd可查看路径</span><br></code></pre></td></tr></table></figure><h2 id="二、对根目录进行扩容"><a href="#二、对根目录进行扩容" class="headerlink" title="二、对根目录进行扩容"></a>二、对根目录进行扩容</h2><p>#虚拟机扩展硬盘后，系统本身无法识别这些多出来的空间，此时就需要对硬盘进行扩容。</p><p>root权限下操作：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>、查看磁盘信息,确定总盘符大小<br><span class="hljs-attribute">fdisk</span> -l<br><br><span class="hljs-attribute">2</span>、删除无用的扇区<br><span class="hljs-attribute">fdisk</span> /dev/sda<br><br><span class="hljs-attribute">3</span>、键入：d  #选择：提示的<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>。。。扇区<br><br><span class="hljs-attribute">4</span>、键入：w保存<br></code></pre></td></tr></table></figure><p>开始扩容：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span>、parted <span class="hljs-regexp">/dev/</span>sda   <span class="hljs-comment">#对总盘符进行操作</span><br><br><span class="hljs-number">2</span>、resizepart <span class="hljs-number">1</span>   <span class="hljs-comment">#1代表盘符序号，可选择想要扩容的盘符</span><br><span class="hljs-comment">#会提示根分区正在使用，输入yes，然后提示输入要扩到多大的容量，例如：原本是40G，现在输入60G，</span><br><span class="hljs-comment">#也可以输入-0，-0的意思是将剩余所有空间都分给1分区</span><br><br><span class="hljs-number">3</span>、q     <span class="hljs-comment">#退出</span><br><br><span class="hljs-number">4</span>、更新磁盘信息<br>resize2fs sda2   <span class="hljs-comment">#刚刚扩容的盘符</span><br><br><span class="hljs-number">5</span>、df -l 或 fdisk -l  <span class="hljs-comment">#查看更新后的分区大小</span><br></code></pre></td></tr></table></figure><p>示例图：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/7854d0d4e4344a099bedd66fa6e8edd5.png" alt="img"></p><p>————————————————<br>版权声明：本文为CSDN博主「奋斗的小蛇蛇」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/risingsmallsnake/article/details/128454679">https://blog.csdn.net/risingsmallsnake/article/details/128454679</a></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作方法</title>
    <link href="/2023/06/05/%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/"/>
    <url>/2023/06/05/%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h1><h2 id="远程方法"><a href="#远程方法" class="headerlink" title="远程方法"></a>远程方法</h2><p><strong>工具：</strong>向日葵远程控制</p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230604102527370.png" alt="image-20230604102527370" style="zoom:50%;" /><table><thead><tr><th>向日葵远程控制</th><th>识别码：522403730</th><th>************</th></tr></thead></table><h2 id="已安装环境："><a href="#已安装环境：" class="headerlink" title="已安装环境："></a>已安装环境：</h2><p><strong>anaconda路径:</strong><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230604103003619.png" alt="image-20230604103003619"></p><p><strong>windows下Pytorch环境：</strong><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230604103105658.png" alt="image-20230604103105658"></p><p><strong>VM虚拟机：</strong></p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230604103307536.png" alt="image-20230604103307536" style="zoom:50%;" /><p><strong>VM虚拟机连接工具Mobaxterm：</strong></p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230604103414725.png" alt="image-20230604103414725" style="zoom: 50%;" /><p><strong>debian11账户密码：</strong></p><table><thead><tr><th>账户</th><th>密码</th></tr></thead><tbody><tr><td>root</td><td>************</td></tr></tbody></table><p><strong>文件存放目录：</strong></p><table><thead><tr><th>windows</th><th>debian</th></tr></thead><tbody><tr><td>E:\workSpace\自己姓名</td><td>/home_extro/自己姓名</td></tr></tbody></table><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230604103948524.png" alt="image-20230604103948524"></p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230604103924943.png" alt="image-20230604103924943" style="zoom:50%;" /><p><strong>windows远程连接Linux vscode</strong>:</p><p>打开windows下VScode</p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230604104303858.png" alt="image-20230604104303858" style="zoom:50%;" /><p>输入Linux账户（root）的密码:</p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230604104416415.png" alt="image-20230604104416415" style="zoom:50%;" /><p><strong>PS：</strong>windows安装的pytorch版本为GPU版，用于训练</p><p>虚拟机Linux（debian11）安装的pytorch版本为cpu版，用于推理（onnx）</p><p><a href="https://datawhalechina.github.io/thorough-pytorch/%E7%AC%AC%E4%B9%9D%E7%AB%A0/9.1%20%E4%BD%BF%E7%94%A8ONNX%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2%E5%B9%B6%E6%8E%A8%E7%90%86.html">onnx使用方法</a></p><p>此外安装了netron,可以可视化onnx模型：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230604105620391.png" alt="image-20230604105620391"></p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230604105657486.png" alt="image-20230604105657486" style="zoom:50%;" />]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>xx电脑操作方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>环境安装</title>
    <link href="/2023/06/05/%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
    <url>/2023/06/05/%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h1><p><a href="https://blog.csdn.net/dtc1261/article/details/127041364">模型部署</a></p><p><a href="https://datawhalechina.github.io/thorough-pytorch/index.html">深入浅出PyTorch</a></p><p><a href="http://www.taodudu.cc/news/show-363608.html?action=onClick">机器学习——Java调用sklearn生成好的Logistic模型进行鸢尾花的预测</a></p><p><a href="https://github.com/lutzroeder/netron">ONNX可视化</a></p>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
      <category>环境部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文框架</title>
    <link href="/2023/06/05/%E8%AE%BA%E6%96%87%E6%A1%86%E6%9E%B6/"/>
    <url>/2023/06/05/%E8%AE%BA%E6%96%87%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="航空发动机时间序列的填补重构及剩余使用寿命预测研究"><a href="#航空发动机时间序列的填补重构及剩余使用寿命预测研究" class="headerlink" title="航空发动机时间序列的填补重构及剩余使用寿命预测研究"></a>航空发动机时间序列的填补重构及剩余使用寿命预测研究</h1><p>之前标题：（航空发动机缺失数据重构的生成对抗填补网络建模研究）</p><h2 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1 绪论"></a>1 绪论</h2><h3 id="1-1-研究背景与意义"><a href="#1-1-研究背景与意义" class="headerlink" title="1.1 研究背景与意义"></a>1.1 研究背景与意义</h3><h3 id="1-2-国内外研究现状"><a href="#1-2-国内外研究现状" class="headerlink" title="1.2 国内外研究现状"></a>1.2 国内外研究现状</h3><h4 id="1-2-1-数据缺失机制"><a href="#1-2-1-数据缺失机制" class="headerlink" title="1.2.1 数据缺失机制"></a>1.2.1 数据缺失机制</h4><h4 id="1-2-2-时间序列数据填补"><a href="#1-2-2-时间序列数据填补" class="headerlink" title="1.2.2 时间序列数据填补"></a>1.2.2 时间序列数据填补</h4><h4 id="1-2-3-剩余使用寿命预测"><a href="#1-2-3-剩余使用寿命预测" class="headerlink" title="1.2.3 剩余使用寿命预测"></a>1.2.3 剩余使用寿命预测</h4><h3 id="1-3-本文研究内容"><a href="#1-3-本文研究内容" class="headerlink" title="1.3 本文研究内容"></a>1.3 本文研究内容</h3><h3 id="1-4-本文结构安排"><a href="#1-4-本文结构安排" class="headerlink" title="1.4 本文结构安排"></a>1.4 本文结构安排</h3><h2 id="2-注意力机制下生成对抗填补网络"><a href="#2-注意力机制下生成对抗填补网络" class="headerlink" title="2 注意力机制下生成对抗填补网络"></a>2 注意力机制下生成对抗填补网络</h2><h3 id="2-1-生成对抗网络"><a href="#2-1-生成对抗网络" class="headerlink" title="2.1 生成对抗网络"></a>2.1 生成对抗网络</h3><h3 id="2-2-生成对抗填补网络"><a href="#2-2-生成对抗填补网络" class="headerlink" title="2.2 生成对抗填补网络"></a>2.2 生成对抗填补网络</h3><h3 id="2-3-注意力机制"><a href="#2-3-注意力机制" class="headerlink" title="2.3 注意力机制"></a>2.3 注意力机制</h3><h3 id="2-4-模型框架"><a href="#2-4-模型框架" class="headerlink" title="2.4 模型框架"></a>2.4 模型框架</h3><h3 id="2-5-本章小结"><a href="#2-5-本章小结" class="headerlink" title="2.5 本章小结"></a>2.5 本章小结</h3><h2 id="3-并行卷积和预填补下生成对抗填补网络"><a href="#3-并行卷积和预填补下生成对抗填补网络" class="headerlink" title="3 并行卷积和预填补下生成对抗填补网络"></a>3 并行卷积和预填补下生成对抗填补网络</h2><h3 id="3-1-预填补"><a href="#3-1-预填补" class="headerlink" title="3.1 预填补"></a>3.1 预填补</h3><h3 id="3-2-并行卷积"><a href="#3-2-并行卷积" class="headerlink" title="3.2 并行卷积"></a>3.2 并行卷积</h3><h3 id="3-3-并行卷积和预填补下生成对抗填补网络框架"><a href="#3-3-并行卷积和预填补下生成对抗填补网络框架" class="headerlink" title="3.3 并行卷积和预填补下生成对抗填补网络框架"></a>3.3 并行卷积和预填补下生成对抗填补网络框架</h3><h3 id="3-4-本章小结"><a href="#3-4-本章小结" class="headerlink" title="3.4 本章小结"></a>3.4 本章小结</h3><h2 id="4-缺失时间序列的剩余使用寿命预测"><a href="#4-缺失时间序列的剩余使用寿命预测" class="headerlink" title="4.缺失时间序列的剩余使用寿命预测"></a>4.缺失时间序列的剩余使用寿命预测</h2><h3 id="4-1-剩余使用寿命预测模型"><a href="#4-1-剩余使用寿命预测模型" class="headerlink" title="4.1 剩余使用寿命预测模型"></a>4.1 剩余使用寿命预测模型</h3><h3 id="4-2-模型框架"><a href="#4-2-模型框架" class="headerlink" title="4.2 模型框架"></a>4.2 模型框架</h3><h3 id="4-3-本章小结"><a href="#4-3-本章小结" class="headerlink" title="4.3 本章小结"></a>4.3 本章小结</h3><h2 id="5-结论与展望"><a href="#5-结论与展望" class="headerlink" title="5 结论与展望"></a>5 结论与展望</h2>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
      <category>论文写作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA基础-String</title>
    <link href="/2023/04/07/JAVA%E5%9F%BA%E7%A1%80-String/"/>
    <url>/2023/04/07/JAVA%E5%9F%BA%E7%A1%80-String/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><strong>字符串</strong></h1><table><thead><tr><th align="left">【本章内容】1. 字符串的定义 2. 字符串操作 3. 字符串与基本类型的转换</th></tr></thead><tbody><tr><td align="left">【能力目标】1. 掌握字符串对象与字面量的区别2. 掌握字符串常用方法3. 掌握字符串与基本类型的转换</td></tr></tbody></table><h2 id="1-String类的定义"><a href="#1-String类的定义" class="headerlink" title="1.String类的定义"></a>1.String类的定义</h2><p>1、String表示字符串类型，属于引用数据类型，不属于基本数据类型。</p><p>2、在java中随便使用 双引号括起来 的都是String对象。</p><p>例如：“abc”，“def”，“hello world!”，这是3个String对象。</p><p>3、java中规定，双引号括起来的字符串，是 不可变 的，也就是说”abc”自出生到最终死亡，不可变，不能变成”abcd”，也不能变成”ab”</p><p>4、在JDK当中双引号括起来的字符串，例如：“abc” “def”都是直接存储在“方法区”的“字符串常量池”当中的。</p><p>5、为什么SUN公司把字符串存储在一个“字符串常量池”当中呢？</p><p>因为字符串在实际的开发中使用太频繁。为了执行效率，所以把字符串放到了方法区的字符串常量池当中。</p><h2 id="2-String类源码解读"><a href="#2-String类源码解读" class="headerlink" title="2.String类源码解读"></a>2.String类源码解读</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;<br><br> <span class="hljs-comment">/**用来存储字符串  */</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> value[];<br><br> <span class="hljs-comment">/** 缓存字符串的哈希码 */</span><br> <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> hash; <span class="hljs-comment">// Default to 0</span><br><br> <span class="hljs-comment">/** 实现序列化的标识 */</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">6849794470754667710L</span>;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>​        这是一个用 final 声明的常量类，不能被任何类所继承,而且一旦一个String对象被创建, 包含在这个对象中的字符序列是不可改变的, 包括该类后续的所有方法都是不能修改该对象的，直至该对象被销毁，这是我们需要特别注意的（该类的一些方法看似改变了字符串，其实内部都是创建一个新的字符串，下面讲解方法时会介绍）。</p><p>　　通过上述代码可以发现，一个 String 字符串实际上是一个 char 数组。</p><h2 id="3-声明方式"><a href="#3-声明方式" class="headerlink" title="3.声明方式"></a>3.声明方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<span class="hljs-comment">//注意这种字面量声明的区别</span><br><br> <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br></code></pre></td></tr></table></figure><p>那么这两种声明方式有什么区别呢？在讲解之前，我们先介绍 <strong>JDK1.7（不包括1.7）</strong>以前的 JVM 的内存分布：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/dc500928a6f74a5188250d4db38c0938.png" alt="img"></p><p>①、程序计数器：也称为 PC 寄存器，保存的是程序当前执行的指令的地址（也可以说保存下一条指令的所在存储单元的地址），当CPU需要执行指令时，需要从程序计数器中得到当前需要执行的指令所在存储单元的地址，然后根据得到的地址获取到指令，在得到指令之后，程序计数器便自动加1或者根据转移指针得到下一条指令的地址，如此循环，直至执行完所有的指令。线程私有。</p><p>　　②、虚拟机栈：基本数据类型、对象的引用都存放在这。线程私有。</p><p>　　③、本地方法栈：虚拟机栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的。在JVM规范中，并没有对本地方法栈的具体实现方法以及数据结构作强制规定，虚拟机可以自由实现它。在HotSopt虚拟机中直接就把本地方法栈和虚拟机栈合二为一。</p><p>　　④、方法区：存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。注意：在Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池，用来存储编译期间生成的字面量和符号引用。</p><p>　　⑤、堆：用来存储对象本身的以及数组（当然，数组引用是存放在Java栈中的）。</p><p>　　在 JDK1.7 以后，方法区的常量池被移除放到堆中了，如下：<br><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/f97f7965f50c4279a1e8bc2a88fb8147.png" alt="img"></p><p>常量池：Java运行时会维护一个String Pool（String池）， 也叫“字符串缓冲区”。String池用来存放运行时中产生的各种字符串，并且池中的字符串的内容不重复。</p><p>　　①、字面量创建字符串或者纯字符串（常量）拼接字符串会先在字符串池中找，看是否有相等的对象，没有的话就在字符串池创建该对象；有的话则直接用池中的引用，避免重复创建对象。</p><p>　　②、new关键字创建时，直接在堆中创建一个新对象，变量所引用的都是这个新对象的地址，但是如果通过new关键字创建的字符串内容在常量池中存在了，那么会由堆在指向常量池的对应字符；但是反过来，如果通过new关键字创建的字符串对象在常量池中没有，那么通过new关键词创建的字符串对象是不会额外在常量池中维护的。</p><p>　　③、使用包含变量表达式来创建String对象，则不仅会检查维护字符串池，还会在堆区创建这个对象，最后是指向堆内存的对象。</p><p>内存分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> “Hello”<br><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">stringclass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        String str=<span class="hljs-string">&quot;Hello&quot;</span>;<br>        String str2=<span class="hljs-string">&quot;Hello&quot;</span>;<br>        System.out.println(str==str2);<br>        str=<span class="hljs-string">&quot;World&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>//输出结果：<br>true<br><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/2edbb0f9bc0a47afaf51510f22e78e9d.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span> (“Hello”)<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">stringclass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>            String str= <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        String str2= <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>        System.out.println(str==str2);<br>        System.out.println(str==str3);<br>    &#125;<br>&#125;  <br><br></code></pre></td></tr></table></figure><p>//输出结果：<br>false<br>false<br>String str = “Hello” + “World”</p><p>public class stringclass {<br>    public static void main(String[] args) {<br>        //当一个字符串由多个字符串常量连接而成时，它自己肯定也是字符串常量。<br>        //该字符串是在编译期就能确定。先是在池里生成“a”和“b”，再通过拼接的方式在池里生成”ab”。<br>        String str=”Hello” + “World”;<br>    }<br>}<br><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/5b93143d57b64463808f9e8629e35fca.png" alt="img"></p><p>String str = new String (“Hello”) + new String(“World”) 当使用了变量字符串的拼接(+, sb.append)都只会在堆区创建该字符串对象, 并不会在常量池创建新生成的字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">stringclass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        String str=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Hello&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;World&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/8d065c9e556e4f5c8e4ed0b45bc83a43.png" alt="img"></p><h2 id="4-常见操作"><a href="#4-常见操作" class="headerlink" title="4. 常见操作"></a>4. 常见操作</h2><h3 id="4-1-equals-Object-anObject-方法"><a href="#4-1-equals-Object-anObject-方法" class="headerlink" title="4.1 equals(Object anObject) 方法"></a>4.1 equals(Object anObject) 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object anObject)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == anObject) &#123;<br>             <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>         &#125;<br>         <span class="hljs-keyword">if</span> (anObject <span class="hljs-keyword">instanceof</span> String) &#123;<br>             <span class="hljs-type">String</span> <span class="hljs-variable">anotherString</span> <span class="hljs-operator">=</span> (String)anObject;<br>             <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> value.length;<br>             <span class="hljs-keyword">if</span> (n == anotherString.value.length) &#123;<br>                 <span class="hljs-type">char</span> v1[] = value;<br>                <span class="hljs-type">char</span> v2[] = anotherString.value;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> (n-- != <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (v1[i] != v2[i])<br>                       <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    i++;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>　　String 类重写了 equals 方法，比较的是组成字符串的每一个字符是否相同，如果都相同则返回true，否则返回false。</p><h3 id="4-2-hashCode-方法"><a href="#4-2-hashCode-方法" class="headerlink" title="4.2 hashCode() 方法"></a>4.2 hashCode() 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> hash;<br>          <span class="hljs-keyword">if</span> (h == <span class="hljs-number">0</span> &amp;&amp; value.length &gt; <span class="hljs-number">0</span>) &#123;<br>              <span class="hljs-type">char</span> val[] = value;<br><br>​          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; value.length; i++) &#123;<br>​              h = <span class="hljs-number">31</span> * h + val[i];<br>​          &#125;<br>​          hash = h;<br>​     &#125;<br>​     <span class="hljs-keyword">return</span> h;<br> &#125;<br><br>　　<br></code></pre></td></tr></table></figure><p>String 类的 hashCode 算法很简单，主要就是中间的 for 循环，计算公式如下：</p><p>s[0]*31^(n-1) + s[1]*31^(n-2) + … + s[n-1]<br>　　s 数组即源码中的 val 数组，也就是构成字符串的字符数组。这里有个数字 31 ，为什么选择31作为乘积因子，而且没有用一个常量来声明？主要原因有两个：</p><p>　　①、31是一个不大不小的质数，是作为 hashCode 乘子的优选质数之一。</p><p>　　②、31可以被 JVM 优化，</p><p>31 * i = (i &lt;&lt; 5) - i。因为移位运算比乘法运行更快更省性能。</p><h3 id="4-3-charAt-int-index-方法"><a href="#4-3-charAt-int-index-方法" class="headerlink" title="4.3 charAt(int index) 方法"></a>4.3 charAt(int index) 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">charAt</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-comment">//如果传入的索引大于字符串的长度或者小于0，直接抛出索引越界异常</span><br>        <span class="hljs-keyword">if</span> ((index &lt; <span class="hljs-number">0</span>) || (index &gt;= value.length)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(index);<br>        &#125;<br>        <span class="hljs-keyword">return</span> value[index];<span class="hljs-comment">//返回指定索引的单个字符</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>　　我们知道一个字符串是由一个字符数组组成，这个方法是通过传入的索引（数组下标），返回指定索引的单个字符。</p><h3 id="4-4-compareTo-String-anotherString-和-compareToIgnoreCase-String-str-方法"><a href="#4-4-compareTo-String-anotherString-和-compareToIgnoreCase-String-str-方法" class="headerlink" title="4.4 compareTo(String anotherString) 和 compareToIgnoreCase(String str) 方法"></a>4.4 compareTo(String anotherString) 和 compareToIgnoreCase(String str) 方法</h3><p>　　我们先看看 compareTo 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(String anotherString)</span> &#123;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> value.length;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">len2</span> <span class="hljs-operator">=</span> anotherString.value.length;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">lim</span> <span class="hljs-operator">=</span> Math.min(len1, len2);<br>          <span class="hljs-type">char</span> v1[] = value;<br>          <span class="hljs-type">char</span> v2[] = anotherString.value;<br><br>​      <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>​      <span class="hljs-keyword">while</span> (k &lt; lim) &#123;<br>​         <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> v1[k];<br>​         <span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> v2[k];<br>​         <span class="hljs-keyword">if</span> (c1 != c2) &#123;<br>​             <span class="hljs-keyword">return</span> c1 - c2;<br>​         &#125;<br>​         k++;<br>​     &#125;<br>​     <span class="hljs-keyword">return</span> len1 - len2;<br> &#125;<br><br><br></code></pre></td></tr></table></figure><p>　　源码也很好理解，该方法是按字母顺序比较两个字符串，是基于字符串中每个字符的 Unicode 值。当两个字符串某个位置的字符不同时，返回的是这一位置的字符 Unicode 值之差，当两个字符串都相同时，返回两个字符串长度之差。</p><p>　compareToIgnoreCase() 方法在 compareTo 方法的基础上忽略大小写，我们知道大写字母是比小写字母的Unicode值小32的，底层实现是先都转换成大写比较，然后都转换成小写进行比较。</p><h3 id="4-5-concat-String-str-方法"><a href="#4-5-concat-String-str-方法" class="headerlink" title="4.5 concat(String str) 方法"></a>4.5 concat(String str) 方法</h3><p>　　该方法是将指定的字符串连接到此字符串的末尾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">concat</span><span class="hljs-params">(String str)</span> &#123;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">otherLen</span> <span class="hljs-operator">=</span> str.length();<br>          <span class="hljs-keyword">if</span> (otherLen == <span class="hljs-number">0</span>) &#123;<br>              <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>          &#125;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> value.length;<br>          <span class="hljs-type">char</span> buf[] = Arrays.copyOf(value, len + otherLen);<br>          str.getChars(buf, len);<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buf, <span class="hljs-literal">true</span>);<br>     &#125;<br></code></pre></td></tr></table></figure><p>首先判断要拼接的字符串长度是否为0，如果为0，则直接返回原字符串。如果不为0，则通过 Arrays 工具类的copyOf方法创建一个新的字符数组，长度为原字符串和要拼接的字符串之和，前面填充原字符串，后面为空。接着在通过 getChars 方法将要拼接的字符串放入新字符串后面为空的位置。</p><p>　　注意：返回值是 new String(buf, true)，也就是重新通过 new 关键字创建了一个新的字符串，原字符串是不变的。这也是前面我们说的一旦一个String对象被创建, 包含在这个对象中的字符序列是不可改变的。</p><h3 id="4-6-indexOf-int-ch-和-indexOf-int-ch-int-fromIndex-方法"><a href="#4-6-indexOf-int-ch-和-indexOf-int-ch-int-fromIndex-方法" class="headerlink" title="4.6 indexOf(int ch) 和 indexOf(int ch, int fromIndex) 方法"></a>4.6 indexOf(int ch) 和 indexOf(int ch, int fromIndex) 方法</h3><p>　　indexOf(int ch)，参数 ch 其实是字符的 Unicode 值，这里也可以放单个字符（默认转成int），作用是返回指定字符第一次出现的此字符串中的索引。其内部是调用 indexOf(int ch, int fromIndex)，只不过这里的 fromIndex =0 ，因为是从 0 开始搜索；而 indexOf(int ch, int fromIndex) 作用也是返回首次出现的此字符串内的索引，但是从指定索引处开始搜索。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(<span class="hljs-type">int</span> ch)</span> &#123;<br>        <span class="hljs-keyword">return</span> indexOf(ch, <span class="hljs-number">0</span>);<span class="hljs-comment">//从第一个字符开始搜索</span><br>    &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(<span class="hljs-type">int</span> ch, <span class="hljs-type">int</span> fromIndex)</span> &#123;<br>      <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> value.length;<span class="hljs-comment">//max等于字符的长度</span><br>      <span class="hljs-keyword">if</span> (fromIndex &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//指定索引的位置如果小于0，默认从 0 开始搜索</span><br>          fromIndex = <span class="hljs-number">0</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fromIndex &gt;= max) &#123;<br>          <span class="hljs-comment">//如果指定索引值大于等于字符的长度（因为是数组，下标最多只能是max-1），直接返回-1</span><br>          <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>      &#125;<br><br> <span class="hljs-keyword">if</span> (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) &#123;<span class="hljs-comment">//一个char占用两个字节，如果ch小于2的16次方（65536），绝大多数字符都在此范围内</span><br>     <span class="hljs-keyword">final</span> <span class="hljs-type">char</span>[] value = <span class="hljs-built_in">this</span>.value;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> fromIndex; i &lt; max; i++) &#123;<span class="hljs-comment">//for循环依次判断字符串每个字符是否和指定字符相等</span><br>         <span class="hljs-keyword">if</span> (value[i] == ch) &#123;<br>             <span class="hljs-keyword">return</span> i;<span class="hljs-comment">//存在相等的字符，返回第一次出现该字符的索引位置，并终止循环</span><br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<span class="hljs-comment">//不存在相等的字符，则返回 -1</span><br>  &#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//当字符大于 65536时，处理的少数情况，该方法会首先判断是否是有效字符，然后依次进行比较</span><br>     <span class="hljs-keyword">return</span> indexOfSupplementary(ch, fromIndex);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-7-substring-int-beginIndex-和-substring-int-beginIndex-int-endIndex-方法"><a href="#4-7-substring-int-beginIndex-和-substring-int-beginIndex-int-endIndex-方法" class="headerlink" title="4.7 substring(int beginIndex) 和 substring(int beginIndex, int endIndex) 方法"></a>4.7 substring(int beginIndex) 和 substring(int beginIndex, int endIndex) 方法</h3><p>　　①、substring(int beginIndex)：返回一个从索引 beginIndex 开始一直到结尾的子字符串。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public String substring(<span class="hljs-built_in">int</span> beginIndex) &#123;<br>    <span class="hljs-keyword">if</span> (beginIndex &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//如果索引小于0，直接抛出异常</span><br>        throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringIndexOutOfBoundsException(<span class="hljs-params">beginIndex</span>)</span>;<br>    &#125;<br>    <span class="hljs-built_in">int</span> subLen = value.length - beginIndex;<span class="hljs-comment">//subLen等于字符串长度减去索引</span><br>    <span class="hljs-keyword">if</span> (subLen &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//如果subLen小于0，也是直接抛出异常</span><br>        throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringIndexOutOfBoundsException(<span class="hljs-params">subLen</span>)</span>;<br>    &#125;<br>    <span class="hljs-comment">//1、如果索引值beginIdex == 0，直接返回原字符串</span><br>    <span class="hljs-comment">//2、如果不等于0，则返回从beginIndex开始，一直到结尾</span><br>    return (beginIndex<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) ? this : <span class="hljs-keyword">new</span> <span class="hljs-constructor">String(<span class="hljs-params">value</span>, <span class="hljs-params">beginIndex</span>, <span class="hljs-params">subLen</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　②、 substring(int beginIndex, int endIndex)：返回一个从索引 beginIndex 开始，到 endIndex 结尾的子字符串。</p><h2 id="5-字符串常用的API"><a href="#5-字符串常用的API" class="headerlink" title="5.字符串常用的API"></a>5.字符串常用的API</h2><pre><code class="hljs">    在编程开发中，经常需要对字符串进行各种操作，熟练掌握字符串的各种操作，对提高编程技巧很有帮助。要学习字符串的操作，首先要了解字符串的组成。字符串内部使用char数组来保存字符串的内容，数组中的每一位存放一个字符，char数组的长度也就是字符串的长度，下图以字符串“Hello World”为例说明其在内存中的分配：</code></pre><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/dc96bbf0d1e741cba78deee8dfd87d34.jpeg" alt="img"></p><p>下表中列出了字符串中提供的常用操作方法：</p><table><thead><tr><th align="left"><strong>返回类型</strong></th><th align="left"><strong>方法名称</strong></th><th align="left"><strong>作用</strong></th></tr></thead><tbody><tr><td align="left">boolean</td><td align="left">equals(String)</td><td align="left">比较两个字符串是否相等</td></tr><tr><td align="left">boolean</td><td align="left">equalsIgnoreCase(String)</td><td align="left">忽略大小写比较两个字符串是否相等</td></tr><tr><td align="left">int</td><td align="left">length()</td><td align="left">获取字符串的长度</td></tr><tr><td align="left">char</td><td align="left">charAt(int)</td><td align="left">获取字符串中的一个字符</td></tr><tr><td align="left">int</td><td align="left">indexOf(String)</td><td align="left">判断传入字符串在原字符串中第一次出现的位置</td></tr><tr><td align="left">int</td><td align="left">lastIndexOf(String)</td><td align="left">判断传入字符串在原字符串中最后一次出现的位置</td></tr><tr><td align="left">boolean</td><td align="left">startsWith(String)</td><td align="left">判断原字符串是否以传入字符串开头</td></tr><tr><td align="left">boolean</td><td align="left">endsWith(String)</td><td align="left">判断原字符串是否以传入字符串结尾</td></tr><tr><td align="left">int</td><td align="left">compareTo(String)</td><td align="left">判断两个字符串的大小</td></tr><tr><td align="left">String</td><td align="left">toLowerCase()</td><td align="left">获取小写字符串</td></tr><tr><td align="left">String</td><td align="left">toUpperCase()</td><td align="left">获取大学字符串</td></tr><tr><td align="left">String</td><td align="left">substring(int)</td><td align="left">截取字符串，从传入参数位置开始截取到末尾</td></tr><tr><td align="left">String</td><td align="left">substring(int,int)</td><td align="left">截取字符串，从参数1位置开始截取到参数2位置</td></tr><tr><td align="left">String</td><td align="left">trim()</td><td align="left">去掉字符串首尾的空格</td></tr><tr><td align="left">String[]</td><td align="left">split(String)</td><td align="left">将原字符串按照传入参数分割为字符串数组</td></tr><tr><td align="left">String</td><td align="left">replace(String,String)</td><td align="left">将字符串中指定的内容替换成另外的内容</td></tr></tbody></table><p>表 字符串常用操作方法</p><p>下面通过典型的例子演示字符串各种方法的应用。</p><h3 id="5-1-验证用户名的长度"><a href="#5-1-验证用户名的长度" class="headerlink" title="5.1 验证用户名的长度"></a>5.1 验证用户名的长度</h3><p>从键盘上输入用户名，对用户名进行验证，合法的用户名长度在6到20之间。如果在这区间，输出用户名长度合法，否则输出用户名长度不合法。</p><p>任务1：用户名长度验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>    System.out.println(<span class="hljs-string">&quot;请输入用户名&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> input.next();<br>    <span class="hljs-keyword">if</span>(name.length()&gt;=<span class="hljs-number">6</span> &amp;&amp; name.length()&lt;=<span class="hljs-number">20</span>)&#123;<br>        System.out.println(<span class="hljs-string">&quot;用户名长度合法&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;用户名长度不合法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：字符串的length()方法用于获取字符串的长度。</p><h3 id="5-2-验证Email地址是否合法"><a href="#5-2-验证Email地址是否合法" class="headerlink" title="5.2 验证Email地址是否合法"></a>5.2 验证Email地址是否合法</h3><p>从键盘上输入email，对email进行验证，合法的email的条件是：</p><p>必须包含“@”和“.”</p><p>“@”必须在“.”的前面</p><p>“@”只能出现一次</p><p>任务2：验证Email地址是否合法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>    System.out.println(<span class="hljs-string">&quot;请输入Email&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">email</span> <span class="hljs-operator">=</span> input.next();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">atIndex</span> <span class="hljs-operator">=</span> email.indexOf(<span class="hljs-string">&quot;@&quot;</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">dotIndex</span> <span class="hljs-operator">=</span> email.indexOf(<span class="hljs-string">&quot;.&quot;</span>);<br>    <span class="hljs-comment">//必须包含“@”和“.”</span><br>    <span class="hljs-keyword">if</span>(atIndex== -<span class="hljs-number">1</span> || dotIndex == -<span class="hljs-number">1</span> )&#123;<br>        System.out.println(<span class="hljs-string">&quot;Email非法，不存在@或.&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//“@”必须在“.”的前面</span><br>    <span class="hljs-keyword">if</span>(atIndex&gt;dotIndex)&#123;<br>        System.out.println(<span class="hljs-string">&quot;Email非法，不允许@在.的后面&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//“@”不在开头和结尾，并且只能出现一次</span><br>    <span class="hljs-keyword">if</span>(email.startsWith(<span class="hljs-string">&quot;@&quot;</span>)==<span class="hljs-literal">false</span> &amp;&amp; email. endsWith(<span class="hljs-string">&quot;@&quot;</span>))&#123;<br>        String array[] = email.split(<span class="hljs-string">&quot;@&quot;</span>);<br>        <span class="hljs-keyword">if</span>(array.length!=<span class="hljs-number">2</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;Email非法，要求@有且只有一个&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;Email合法&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：</p><p>int atIndex = email.indexOf(“@”)，indexOf方法表示在email中查找是否包含“@”，返回“@”在email中的下标，若不存在返回-1。</p><p>email.split(“@”)，split方法表示将email中的字符串以“@”为标志，将email切割成多个字符，并将切割后的字符串存储到array数组中。</p><h3 id="5-3-验证类名是否以-java结尾，以com开头"><a href="#5-3-验证类名是否以-java结尾，以com开头" class="headerlink" title="5.3 验证类名是否以.java结尾，以com开头"></a>5.3 验证类名是否以.java结尾，以com开头</h3><p>任务3：验证类名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>    System.out.println(<span class="hljs-string">&quot;请输入类名&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">classname</span> <span class="hljs-operator">=</span> input.next();<br>    classname = classname.toLowerCase();<br>    <span class="hljs-keyword">if</span>(classname.startsWith(<span class="hljs-string">&quot;com&quot;</span>)==<span class="hljs-literal">false</span>)&#123;<br>        System.out.println(<span class="hljs-string">&quot;类名不是以com开头的&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!classname.endsWith(<span class="hljs-string">&quot;.java&quot;</span>))&#123;<br>        System.out.println(<span class="hljs-string">&quot;类名不是以.结尾的&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;类名是以com开头，.java结尾的&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：</p><p>classname=classname.toLowerCase()，toLowerCase方法用于将字符串转换成小写。</p><p>classname.startsWith(“com”),startWith方法用于判断字符串是否以“com”开头。</p><p>classname.endsWith(“.java”),endsWith方法用于判断字符串是否以“.java”结尾。</p><h3 id="5-4-将新闻标题中的“爪洼”换成“java”"><a href="#5-4-将新闻标题中的“爪洼”换成“java”" class="headerlink" title="5.4 将新闻标题中的“爪洼”换成“java”"></a>5.4 将新闻标题中的“爪洼”换成“java”</h3><p>任务4：字符串内容替换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">title</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;爪哇技术发展这些年&quot;</span>;<br>    System.out.println(<span class="hljs-string">&quot;替换前的标题&quot;</span>+title);<br>    title = title.replace(<span class="hljs-string">&quot;爪哇&quot;</span>,<span class="hljs-string">&quot;java&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;替换后的标题&quot;</span>+title);<br>&#125;<br></code></pre></td></tr></table></figure><p>说明</p><p>title = title.replace(“爪哇”,”java”)，replace方法用于将title字符串中所有的“爪哇”替换成“java”。</p><h3 id="5-5-将路径中的文件名截取出来"><a href="#5-5-将路径中的文件名截取出来" class="headerlink" title="5.5 将路径中的文件名截取出来"></a>5.5 将路径中的文件名截取出来</h3><p>任务5：字符串截取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;C:\\HTML\\front\\assets\\img\\pc\\logo.png&quot;</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">startIndex</span> <span class="hljs-operator">=</span> path.lastIndexOf(<span class="hljs-string">&quot;\\&quot;</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">endIndex</span> <span class="hljs-operator">=</span> path.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> path.substring(startIndex+<span class="hljs-number">1</span>,endIndex);<br>    System.out.println(path+<span class="hljs-string">&quot;路径中的文件是：&quot;</span>+fileName);<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：</p><p>path变量中的\中第一个表示转义字符。</p><p>substring方法用于从一个字符串中截取部分字符串，第一个参数是从第几位截取，第二个参数是截取到第几位。</p><p>问：    字符串的方法好多，我如何去学习呢？<br>答：    Java提供了JDK的API文档，你必须学会查询API文档学习知识，不仅仅是字符串类。5.6 字符串格式化</p><p>String类的format()方法用于创建格式化的字符串以及连接多个字符串对象。format方法定义是format(String format, Object… args)；第一个参数是被格式化的字符串，第二个参数是替换格式符的字符串，第二个参数中的…表示方法可变参数（后续课程中讲解），即参数的个数根据格式符个个数来确定。字符串格式化就是使用第二个可变参数中的值按照顺序替换第一个参数中的格式符。format方法的格式符定义如下：</p><table><thead><tr><th align="left">格式符</th><th align="left">说明</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">%s</td><td align="left">字符串类型</td><td align="left">“李逵”</td></tr><tr><td align="left">%c</td><td align="left">字符类型</td><td align="left">‘m’</td></tr><tr><td align="left">%b</td><td align="left">布尔类型</td><td align="left">true</td></tr><tr><td align="left">%d</td><td align="left">整数类型（十进制）</td><td align="left">100</td></tr><tr><td align="left">%x</td><td align="left">整数类型（十六进制）</td><td align="left">FF</td></tr><tr><td align="left">%o</td><td align="left">整数类型（八进制）</td><td align="left">77</td></tr><tr><td align="left">%f</td><td align="left">浮点类型</td><td align="left">99.99</td></tr></tbody></table><p><strong>任务6：字符串格式化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    String str=<span class="hljs-literal">null</span>;<br>    str=String.format(<span class="hljs-string">&quot;见过,%s及%s&quot;</span>, <span class="hljs-string">&quot;晁天王&quot;</span>,<span class="hljs-string">&quot;众位头领&quot;</span>);<br>    System.out.println(str);<br>    str=String.format(<span class="hljs-string">&quot;字母a的大写是：%c&quot;</span>, <span class="hljs-string">&#x27;A&#x27;</span>);<br>    System.out.println(str);<br>    str=String.format(<span class="hljs-string">&quot;3&gt;7的结果是：%b&quot;</span>, <span class="hljs-number">3</span>&gt;<span class="hljs-number">7</span>);<br>    System.out.println(str);<br>    str=String.format(<span class="hljs-string">&quot;100的一半是：%d&quot;</span>, <span class="hljs-number">100</span>/<span class="hljs-number">2</span>);<br><br>    System.out.println(str);<br><br>    <span class="hljs-comment">//使用printf代替format方法来格式化字符串</span><br>    System.out.printf(<span class="hljs-string">&quot;50元的书打8.5折扣是：%f 元&quot;</span>, <span class="hljs-number">50</span>*<span class="hljs-number">0.85</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>见过,晁天王及众位头领</p><p>字母a的大写是：A</p><p>3&gt;7的结果是：false</p><p>100的一半是：50</p><p>50元的书打8.5折扣是：42.500000 元</p></blockquote><p>说明：</p><ol><li>字符串的格式化避免了使用+来连接字符串，使得字符串的构建更方便。</li><li>是否System.out.printf()可以代替String.format()方法格式化字符串</li></ol><h2 id="6-StringBuilder、StringBuffer"><a href="#6-StringBuilder、StringBuffer" class="headerlink" title="6. StringBuilder、StringBuffer"></a>6. StringBuilder、StringBuffer</h2><h3 id="6-1-“-”连接符"><a href="#6-1-“-”连接符" class="headerlink" title="6.1 “+”连接符"></a>6.1 “+”连接符</h3><p>“+”连接符的实现原理<br>Java语言为“+”连接符以及对象转换为字符串提供了特殊的支持，字符串对象可以使用“+”连接其他对象。其中字符串连接是通过 StringBuilder（或 StringBuffer）类及其append 方法实现的，对象转换为字符串是通过 toString 方法实现的，该方法由 Object 类定义，并可被 Java 中的所有类继承。有关字符连接和转换的更多信息，可以参阅 Gosling、Joy 和 Steele 合著的 《The Java Language Specification》</p><p>我们可以通过反编译验证一下</p><ul><li>```java<br>/**<ul><li>测试代码<br>*/<br>public class Test {<br>public static void main(String[] args) {<pre><code class="hljs">int i = 10;String s = &quot;abc&quot;;System.out.println(s + i);</code></pre>}<br>  }</li></ul>/**<ul><li>反编译后<br>*/<br>public class Test {<br>public static void main(String args[]) {    //删除了默认构造函数和字节码<pre><code class="hljs">byte byte0 = 10;      String s = &quot;abc&quot;;      System.out.println((new StringBuilder()).append(s).append(byte0).toString());</code></pre>}<br> }<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">   <br>   由上可以看出，Java中使用<span class="hljs-string">&quot;+&quot;</span>连接字符串对象时，会创建一个<span class="hljs-constructor">StringBuilder()</span>对象，并调用append<span class="hljs-literal">()</span>方法将数据拼接，最后调用<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>方法返回拼接好的字符串。由于append<span class="hljs-literal">()</span>方法的各种重载形式会调用<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>valueOf方法，所以我们可以认为：<br><br><span class="hljs-comment">//以下两者是等价的</span><br><br>```java<br>s = i + <span class="hljs-string">&quot;&quot;</span><br>s = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">i</span>)</span>;<br></code></pre></td></tr></table></figure></li></ul></li></ul><p>//以下两者也是等价的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">s = <span class="hljs-string">&quot;abc&quot;</span> + i;<br>s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;abc&quot;</span>).append(i).toString();<br></code></pre></td></tr></table></figure><h3 id="6-2-“-”连接符的效率"><a href="#6-2-“-”连接符的效率" class="headerlink" title="6.2 “+”连接符的效率"></a>6.2 “+”连接符的效率</h3><p>使用“+”连接符时，JVM会隐式创建StringBuilder对象，这种方式在大部分情况下并不会造成效率的损失，不过在进行大量循环拼接字符串时则需要注意。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10000</span>; i++) &#123;<br>    s += <span class="hljs-string">&quot;abc&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>```java<br>/**<ul><li>反编译后<br>*/<br>String s = “abc”;<br>for(int i = 0; i &lt; 1000; i++) {<br> s = (new StringBuilder()).append(s).append(“abc”).toString();<br>}<br>这样由于大量StringBuilder创建在堆内存中，肯定会造成效率的损失，所以在这种情况下建议在循环体外创建一个StringBuilder对象调用append()方法手动拼接（如上面例子如果使用手动拼接运行时间将缩小到1/200左右）。</li></ul>/**<ul><li>循环中使用StringBuilder代替“+”连接符<br>*/<br>StringBuilder sb = new StringBuilder(“abc”);<br>for (int i = 0; i &lt; 1000; i++) {<br>sb.append(“abc”);<br>}<br>sb.toString();<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">   <br>   与此之外还有一种特殊情况，也就是当<span class="hljs-string">&quot;+&quot;</span>两端均为编译期确定的字符串常量时，编译器会进行相应的优化，直接将两个字符串常量拼接好，例如：<br><br>```<span class="hljs-keyword">java</span><br><span class="hljs-keyword"></span>System.out.println(<span class="hljs-string">&quot;Hello&quot;</span> + <span class="hljs-string">&quot;World&quot;</span>);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * 反编译后</span><br><span class="hljs-comment">   */</span><br>   System.out.println(<span class="hljs-string">&quot;HelloWorld&quot;</span>);<br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 编译期确定</span><br><span class="hljs-comment"> * 对于final修饰的变量，它在编译时被解析为常量值的一个本地拷贝存储到自己的常量池中或嵌入到它的字节码流中。</span><br><span class="hljs-comment"> * 所以此时的&quot;a&quot; + s1和&quot;a&quot; + &quot;b&quot;效果是一样的。故结果为true。</span><br><span class="hljs-comment">   */</span><br>   String <span class="hljs-built_in">s0</span> = <span class="hljs-string">&quot;ab&quot;</span>; <br>   final String <span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;b&quot;</span>; <br>   String <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-built_in">s1</span>;  <br>   System.out.println((<span class="hljs-built_in">s0</span> == <span class="hljs-built_in">s2</span>))<span class="hljs-comment">; //result = true</span><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 编译期无法确定</span><br><span class="hljs-comment"> * 这里面虽然将s1用final修饰了，但是由于其赋值是通过方法调用返回的，那么它的值只能在运行期间确定</span><br><span class="hljs-comment"> * 因此s0和s2指向的不是同一个对象，故上面程序的结果为false。</span><br><span class="hljs-comment">   */</span><br>   String <span class="hljs-built_in">s0</span> = <span class="hljs-string">&quot;ab&quot;</span>; <br>   final String <span class="hljs-built_in">s1</span> = getS1(); <br>   String <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-built_in">s1</span>; <br>   System.out.println((<span class="hljs-built_in">s0</span> == <span class="hljs-built_in">s2</span>))<span class="hljs-comment">; //result = false </span><br><br>public String getS1() &#123;  <br>    return <span class="hljs-string">&quot;b&quot;</span>;   <br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><p>综上，“+”连接符对于直接相加的字符串常量效率很高，因为在编译期间便确定了它的值，也就是说形如”I”+“love”+“java”; 的字符串相加，在编译期间便被优化成了”Ilovejava”。对于间接相加（即包含字符串引用，且编译期无法确定值的），形如s1+s2+s3; 效率要比直接相加低，因为在编译器不会对引用变量进行优化。</p><h2 id="7-StringBuffer源码解析"><a href="#7-StringBuffer源码解析" class="headerlink" title="7. StringBuffer源码解析"></a>7. StringBuffer源码解析</h2><p>String 是我们用到非常多的一个类，对于 String 做大量的操作，如果只使用 String 的话，效率没有那么高。一般会推荐使用 StringBuffer 和 Stringbuilder 来做字符串的操作。 那么 StringBuffer 和 StringBuilder 的区别是什么呢？ StringBuffer 是线程安全的，因为它里面的方法都被 synchronized 关键字修饰，例如 append 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title function_">append</span><span class="hljs-params">(String str)</span> &#123;<br>        toStringCache = <span class="hljs-literal">null</span>;<br>        <span class="hljs-built_in">super</span>.append(str);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br>StringBuilder 是线程不安全的，他里面没有使用 <span class="hljs-keyword">synchronized</span> 关键字修饰<br><br><span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title function_">append</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-built_in">super</span>.append(str);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>其中两个类都是在调用父类的 append 方法，只是 StringBuffer 通过 synchronized 关键字来保证线程安全，当然这样做同时也会降低效率。除非是在单线程环境下，并且非常追求速率的情况下使用 StringBuilder，其他情况下还是推荐使用 StringBuffer 来做字符串的操作。我们的重点不是对比两个类的优缺点，直接去看这两个类的父类 AbstractStringBuilder 。父类中的 append 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title function_">append</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-keyword">if</span> (str == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> appendNull();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> str.length();<br>        ensureCapacityInternal(count + len); <span class="hljs-comment">// 扩容</span><br>        str.getChars(<span class="hljs-number">0</span>, len, value, count); <span class="hljs-comment">// 添加新的 String 到尾部</span><br>        count += len; <span class="hljs-comment">// 长度加上添加进来的长度</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>实际上不管是哪一个，都是在使用父类的方法以及成员变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** 存储字符的数组 */</span><br>    <span class="hljs-type">char</span>[] value;<br><br><span class="hljs-comment">/** 字符数组中已经使用得到长度 */</span><br><span class="hljs-type">int</span> count;<br></code></pre></td></tr></table></figure><p>父类 AbstractStringBuilder 中维护了一个存储字符的数组 value，用来保存字符串的全部字符。count 是用来表示使用了多长的数组。 接下来看一下扩容方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minimumCapacity)</span> &#123;<br>        <span class="hljs-comment">// overflow-conscious code</span><br>        <span class="hljs-keyword">if</span> (minimumCapacity - value.length &gt; <span class="hljs-number">0</span>)<br>            expandCapacity(minimumCapacity);<br>    &#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">expandCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minimumCapacity)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> value.length * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>; <span class="hljs-comment">// 扩容为原来的 2 倍加 2</span><br>    <span class="hljs-keyword">if</span> (newCapacity - minimumCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 如果扩容后的长度仍然小于最小扩容长度，则新长度赋值为最小扩容长度</span><br>        newCapacity = minimumCapacity;<br>    <span class="hljs-keyword">if</span> (newCapacity &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 新长度为负数，超过 int 的最大值，变为了负数</span><br>        <span class="hljs-keyword">if</span> (minimumCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow // 最小的扩容长度为负数，也是超过了 int 最大值</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>();<br>        newCapacity = Integer.MAX_VALUE; <span class="hljs-comment">// 如果最小扩容长度没有超过 int 最大值，但是原长度翻倍加2后超过了，则把新长度赋值为 int 最大值</span><br>    &#125;<br>    value = Arrays.copyOf(value, newCapacity); <span class="hljs-comment">// 调用 Arrays.copyOf 生成新长度的数组</span><br>&#125;<br></code></pre></td></tr></table></figure><p>扩容方法就是扩容为原来的 2 倍再加 2 ，然后判断新长度的合法性，不合法会抛出 OOM ，合法会复制一个新长度的数组覆盖原来的数组。</p><p>真正添加 String 的方法是 getChars</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getChars</span><span class="hljs-params">(<span class="hljs-type">int</span> srcBegin, <span class="hljs-type">int</span> srcEnd, <span class="hljs-type">char</span> dst[], <span class="hljs-type">int</span> dstBegin)</span> &#123;<br>        <span class="hljs-keyword">if</span> (srcBegin &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(srcBegin);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (srcEnd &gt; value.length) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(srcEnd);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (srcBegin &gt; srcEnd) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(srcEnd - srcBegin);<br>        &#125;<br>        <span class="hljs-comment">// 执行到这里，说明没有出现下标越界，调用 arraycopy 把该字符串追加到尾部</span><br>        System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);<br>    &#125;<br></code></pre></td></tr></table></figure><p>此时，StringBuffer 的 append 方法才算结束执行。 看完在尾部添加 String 的 append 方法，看一下可以在指定下标处添加的 insert 方法，直接贴出调用的父类的 insert 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> offset, String str)</span> &#123;<br>        <span class="hljs-keyword">if</span> ((offset &lt; <span class="hljs-number">0</span>) || (offset &gt; length()))<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(offset);<br>        <span class="hljs-keyword">if</span> (str == <span class="hljs-literal">null</span>)<br>            str = <span class="hljs-string">&quot;null&quot;</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> str.length();<br>        ensureCapacityInternal(count + len); <span class="hljs-comment">// 扩容</span><br>        <span class="hljs-comment">// 从 offset 处开始之后的字符都向后移动 len 长度的位置</span><br>        System.arraycopy(value, offset, value, offset + len, count - offset);<br>        <span class="hljs-comment">// 把新添加的 String 添加到 offset 位置处</span><br>        str.getChars(value, offset);<br>        count += len;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>检查下标的合法性后就做扩容操作，然后在将指定位置处以后的元素向后移动新加 String 长度的距离，然后将新 String 添加至指定位置。 删除指定区间的 delete 方法如下，依然用 synchronized 控制，并调用父类方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(start);<br>        <span class="hljs-keyword">if</span> (end &gt; count)<br>            end = count;<br>        <span class="hljs-keyword">if</span> (start &gt; end)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> end - start;<br>        <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 把 start + len 位置开始的元素向前移动 len 个距离</span><br>            System.arraycopy(value, start+len, value, start, count-end);<br>            count -= len;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>也是使用了 arraycopy 来操作内部维护的字符数组。</p><p>最后看一下字符串反转方法 reverse</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title function_">reverse</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">hasSurrogates</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> count - <span class="hljs-number">1</span>; <span class="hljs-comment">// 得到下标最大值</span><br>        <span class="hljs-comment">/* 循环，从中间向两边移动，并交换位置</span><br><span class="hljs-comment">           count = 长度   n = 下表最大值  j = 下标减一后除</span><br><span class="hljs-comment">           如果是偶数个-&gt;user count  = 4, n = 3, j = 1  交换下标为 1 和 3-1 的两个值，即 s 和 e，然后向两头移动</span><br><span class="hljs-comment">           如果奇数个-&gt;hello count = 5, n = 4, j = 1 交换下标为 1 和 4-1 的两个值，即 e 和第二个 l，然后向两头移动</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> (n-<span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> n - j;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">cj</span> <span class="hljs-operator">=</span> value[j];<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ck</span> <span class="hljs-operator">=</span> value[k];<br>            value[j] = ck;<br>            value[k] = cj;<br>            <span class="hljs-keyword">if</span> (Character.isSurrogate(cj) ||<br>                Character.isSurrogate(ck)) &#123;<br>                hasSurrogates = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (hasSurrogates) &#123;<br>            reverseAllValidSurrogatePairs();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="8-String-intern-方法"><a href="#8-String-intern-方法" class="headerlink" title="8. String.intern() 方法"></a>8. String.intern() 方法</h2><p>这是一个本地方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> String <span class="hljs-title function_">intern</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>　　当调用intern方法时，如果池中已经包含一个与该String确定的字符串相同equals(Object)的字符串，则返回该字符串。否则，将此String对象添加到池中，并返回此对象的引用。</p><p>　　这句话什么意思呢？就是说调用一个String对象的intern()方法，如果常量池中有该对象了，直接返回该字符串的引用（存在堆中就返回堆中，存在池中就返回池中），如果没有，则将该对象添加到池中，并返回池中的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<span class="hljs-comment">//字面量 只会在常量池中创建对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> str1.intern();<br>System.out.println(str1==str2);<span class="hljs-comment">//true</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;world&quot;</span>);<span class="hljs-comment">//new 关键字只会在堆中创建对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str4</span> <span class="hljs-operator">=</span> str3.intern();<br>System.out.println(str3 == str4);<span class="hljs-comment">//false</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">str5</span> <span class="hljs-operator">=</span> str1 + str2;<span class="hljs-comment">//变量拼接的字符串，会在常量池中和堆中都创建对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str6</span> <span class="hljs-operator">=</span> str5.intern();<span class="hljs-comment">//这里由于池中已经有对象了，直接返回的是对象本身，也就是堆中的对象</span><br>System.out.println(str5 == str6);<span class="hljs-comment">//true</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">str7</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello1&quot;</span> + <span class="hljs-string">&quot;world1&quot;</span>;<span class="hljs-comment">//常量拼接的字符串，只会在常量池中创建对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str8</span> <span class="hljs-operator">=</span> str7.intern();<br>System.out.println(str7 == str8);<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h2 id="9-String不可变性"><a href="#9-String不可变性" class="headerlink" title="9. String不可变性"></a>9. String不可变性</h2><p>String 类为什么要这样设计成不可变呢？我们可以从性能以及安全方面来考虑：</p><p>安全</p><p>引发安全问题，譬如，数据库的用户名、密码都是以字符串的形式传入来获得数据库的连接，或者在socket编程中，主机名和端口都是以字符串的形式传入。因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子，改变字符串指向的对象的值，造成安全漏洞。</p><p>保证线程安全，在并发场景下，多个线程同时读写资源时，会引竞态条件，由于 String 是不可变的，不会引发线程的问题而保证了线程。</p><p>HashCode，当 String 被创建出来的时候，hashcode也会随之被缓存，hashcode的计算与value有关，若 String 可变，那么 hashcode 也会随之变化，针对于 Map、Set 等容器，他们的键值需要保证唯一性和一致性，因此，String 的不可变性使其比其他对象更适合当容器的键值。</p><p>性能</p><p>当字符串是不可变时，字符串常量池才有意义。字符串常量池的出现，可以减少创建相同字面量的字符串，让不同的引用指向池中同一个字符串，为运行时节约很多的堆内存。若字符串可变，字符串常量池失去意义，基于常量池的String.intern()方法也失效，每次创建新的 String 将在堆内开辟出新的空间，占据更多的内存。</p><p>————————————————<br>版权声明：本文为CSDN博主「酱紫学Java」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_52519008/article/details/124786234">https://blog.csdn.net/qq_52519008/article/details/124786234</a></p>]]></content>
    
    
    <categories>
      
      <category>JAVA学习</category>
      
      <category>java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git常用命令</title>
    <link href="/2023/03/30/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/03/30/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/u013302168/article/details/124360566">Git常用命令</a></p><h1 id="一、概念理解"><a href="#一、概念理解" class="headerlink" title="一、概念理解"></a>一、概念理解</h1><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/8205a12c11fc45ba4ee13a5af081577c.png" alt="img"></p><h2 id="（一）工作区、暂存区、本地仓库、远程仓库"><a href="#（一）工作区、暂存区、本地仓库、远程仓库" class="headerlink" title="（一）工作区、暂存区、本地仓库、远程仓库"></a>（一）工作区、暂存区、本地仓库、远程仓库</h2><ul><li>workspace：工作区</li><li>staging area：暂存区/缓存区</li><li>local repository：本地仓库</li><li>remote repository：远程仓库</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http">https://github.com/liyinchigithub/Git-commands<br>https://github.com/liyinchigithub/Git-commands<br></code></pre></td></tr></table></figure><h2 id="（二）远程分支、当前本地分支"><a href="#（二）远程分支、当前本地分支" class="headerlink" title="（二）远程分支、当前本地分支"></a>（二）远程分支、当前本地分支</h2><h2 id="（三）常用命令"><a href="#（三）常用命令" class="headerlink" title="（三）常用命令"></a>（三）常用命令</h2><h3 id="1-git-init"><a href="#1-git-init" class="headerlink" title="1.git init"></a>1.git init</h3><p>新项目执行Git初始化，并进行第一次提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs git">git init<br>git add .<br>git commit -m &quot;first commit&quot;<br>git remote add origin https://github.com/liyinchigithub/Git-commands.git<br>git push origin master<br></code></pre></td></tr></table></figure><h3 id="2-git-clone"><a href="#2-git-clone" class="headerlink" title="2.git clone"></a>2.git clone</h3><p>对github、gitlab远程仓库，已有项目进行克隆</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/liyinchigithub/</span>Git-commands.git<br></code></pre></td></tr></table></figure><h3 id="3-git-pull、git-fetch"><a href="#3-git-pull、git-fetch" class="headerlink" title="3.git pull、git fetch"></a>3.git pull、git fetch</h3><h4 id="（1）将远程主机-origin-的-master-分支拉取过来，与本地的-brantest-分支合并。"><a href="#（1）将远程主机-origin-的-master-分支拉取过来，与本地的-brantest-分支合并。" class="headerlink" title="（1）将远程主机 origin 的 master 分支拉取过来，与本地的 brantest 分支合并。"></a>（1）将远程主机 origin 的 master 分支拉取过来，与本地的 brantest 分支合并。</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">git pull origin<br>git pull https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/liyinchigithub/</span>Git-commands.git<br></code></pre></td></tr></table></figure><p> 远程分支是与当前分支合并</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git pull origin <span class="hljs-literal">master</span><br></code></pre></td></tr></table></figure><h4 id="（2）拉取代码，但不合并到本地"><a href="#（2）拉取代码，但不合并到本地" class="headerlink" title="（2）拉取代码，但不合并到本地"></a>（2）拉取代码，但不合并到本地</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">fetch</span> <span class="hljs-comment">--all</span><br>git <span class="hljs-keyword">fetch</span> <span class="hljs-comment">--tags</span><br>git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard origin/master</span><br></code></pre></td></tr></table></figure><h4 id="（3）git-pull-与git-fetch区别："><a href="#（3）git-pull-与git-fetch区别：" class="headerlink" title="（3）git pull 与git fetch区别："></a>（3）git pull 与git fetch区别：</h4><ul><li>远端跟踪分支不同</li></ul><p>git fetch能够直接更改远端跟踪分支。</p><p>git pull无法直接对远程跟踪分支操作，我们必须先切回本地分支然后创建一个新的commit提交。</p><ul><li>拉取不同</li></ul><p>git fetch会将数据拉取到本地仓库，它并不会自动合并或修改当前的工作。</p><p>git pull是从远程获取最新版本并merge到本地，会自动合并或修改当前的工作。</p><ul><li>commitID不同</li></ul><p>使用git fetch更新代码，本地的库中master的commitID不变，还是等于1。</p><p>使用git pull更新代码，本地的库中master的commitID发生改变，变成了2。</p><h3 id="4-git-add"><a href="#4-git-add" class="headerlink" title="4.git add"></a>4.git add</h3><h4 id="（1）添加指定目录到暂存区，包括子目录："><a href="#（1）添加指定目录到暂存区，包括子目录：" class="headerlink" title="（1）添加指定目录到暂存区，包括子目录："></a>（1）添加指定目录到暂存区，包括子目录：</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">git <span class="hljs-keyword">add</span><span class="language-bash"> [<span class="hljs-built_in">dir</span>]</span><br></code></pre></td></tr></table></figure><p>例如：添加2个文件到暂存区</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">add </span>README hello.<span class="hljs-keyword">js </span><br></code></pre></td></tr></table></figure><h4 id="（2）添加当前目录下的所有文件到暂存区："><a href="#（2）添加当前目录下的所有文件到暂存区：" class="headerlink" title="（2）添加当前目录下的所有文件到暂存区："></a>（2）添加当前目录下的所有文件到暂存区：</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git <span class="hljs-built_in">add</span> .<br></code></pre></td></tr></table></figure><h3 id="5-git-commit"><a href="#5-git-commit" class="headerlink" title="5.git commit"></a>5.git commit</h3><p>将暂存区内容添加到本地仓库中</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> commit -m <span class="hljs-string">&quot;提交内容备注&quot;</span><br></code></pre></td></tr></table></figure><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/ffd33730ae3b4880be7cc4083a04bf23.png" alt="img">在执行git add .  之后执行git commit</p><h3 id="6-git-reset"><a href="#6-git-reset" class="headerlink" title="6.git reset"></a>6.git reset</h3><h4 id="（1）回滚代码，撤销某一次commit，并强推到远程仓库"><a href="#（1）回滚代码，撤销某一次commit，并强推到远程仓库" class="headerlink" title="（1）回滚代码，撤销某一次commit，并强推到远程仓库"></a>（1）回滚代码，撤销某一次commit，并强推到远程仓库</h4><p>如果需要删除的 commit 是最新的，那么可以通过 git reset 命令将代码回滚到之前某次提交的状态，但一定要将现有的代码做好备份，否则回滚之后这些变动都会消失。具体操作如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">git log <span class="hljs-regexp">//</span> 查询要回滚的 commit_id<br><br>git reset --hard commit_id <span class="hljs-regexp">//</span> HEAD 就会指向此次的提交记录<br><br>git push origin HEAD --force <span class="hljs-regexp">//</span> 强制推送到远端<br></code></pre></td></tr></table></figure><h4 id="（2）回退所有内容到上一个版本"><a href="#（2）回退所有内容到上一个版本" class="headerlink" title="（2）回退所有内容到上一个版本"></a>（2）回退所有内容到上一个版本</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">reset</span> HEAD^<br></code></pre></td></tr></table></figure><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/1b93704d177a4e478cfc46df7cd786e3.png" alt="img"></p><h4 id="（3）回退-hello-js-文件的版本到上一个版本"><a href="#（3）回退-hello-js-文件的版本到上一个版本" class="headerlink" title="（3）回退 hello.js 文件的版本到上一个版本"></a>（3）回退 hello.js 文件的版本到上一个版本</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">reset</span> HEAD^ hello.js<br></code></pre></td></tr></table></figure><p>执行 git reset HEAD 命令用于取消已缓存的内容。</p><p>执行 git reset HEAD 以取消之前 git add 添加，但不希望包含在下一提交快照中的缓存 。</p><h4 id="（4）回退到指定版本"><a href="#（4）回退到指定版本" class="headerlink" title="（4）回退到指定版本"></a>（4）回退到指定版本</h4><p>查看提交日志，回退到指定commit_id</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/4907f75c58724455a6494213bf57723d.png" alt="img"></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">log</span><br>git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard commit_id</span><br> 或者<br><br>git <span class="hljs-keyword">reset</span> <span class="hljs-number">052</span>e<br></code></pre></td></tr></table></figure><h4 id="（5）回退上上上一个版本"><a href="#（5）回退上上上一个版本" class="headerlink" title="（5）回退上上上一个版本"></a>（5）回退上上上一个版本</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--soft HEAD~3</span><br></code></pre></td></tr></table></figure><p>备注：此次提交之后的修改会被退回到暂存区</p><h4 id="（6）回退到某个版本回退点之前的所有信息。"><a href="#（6）回退到某个版本回退点之前的所有信息。" class="headerlink" title="（6）回退到某个版本回退点之前的所有信息。"></a>（6）回退到某个版本回退点之前的所有信息。</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">reset</span> –hard bae128<br></code></pre></td></tr></table></figure><p>备注：此次提交之后的修改不做任何保留，git status 查看工作区是没有记录的。</p><h4 id="（7）将本地的状态回退到和远程的一样"><a href="#（7）将本地的状态回退到和远程的一样" class="headerlink" title="（7）将本地的状态回退到和远程的一样"></a>（7）将本地的状态回退到和远程的一样</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">reset</span> --hard <span class="hljs-built_in">origin</span>/master<br></code></pre></td></tr></table></figure><p>注意：谨慎使用 –hard 参数，它会删除回退点之前的所有信息。</p><h4 id="（8）HEAD-说明："><a href="#（8）HEAD-说明：" class="headerlink" title="（8）HEAD 说明："></a>（8）HEAD 说明：</h4><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs latex">HEAD 表示当前版本<br><br>HEAD<span class="hljs-built_in">^</span> 上一个版本<br><br>HEAD^^ 上上一个版本<br><br>HEAD^^^ 上上上一个版本<br><br>以此类推...<br><br>可以使用 ～数字表示<br><br>HEAD~0 表示当前版本<br><br>HEAD~1 上一个版本<br><br>HEAD<span class="hljs-built_in">^</span>2 上上一个版本<br><br>HEAD<span class="hljs-built_in">^</span>3 上上上一个版本<br></code></pre></td></tr></table></figure><p>以此类推…</p><h4 id="（9）误删恢复"><a href="#（9）误删恢复" class="headerlink" title="（9）误删恢复"></a>（9）误删恢复</h4><p>如果回滚代码之后发现复制错了 commit_id，或者误删了某次 commit 记录，也可以通过下方代码恢复：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">git relog <span class="hljs-regexp">//</span> 复制要恢复操作的前面的 hash 值<br><br>git reset --hard hash <span class="hljs-regexp">//</span> 将 hash 换成要恢复的历史记录的 hash 值<br></code></pre></td></tr></table></figure><p>注意：删除中间某次提交时最好不要用 git reset 回退远程库，因为之后其他人提交代码时用 git pull 也会把自己的本地仓库回退到之前的版本，容易出现差错进而增加不必要的工作量。</p><h3 id="7-git-branch"><a href="#7-git-branch" class="headerlink" title="7.git branch"></a>7.git branch</h3><h4 id="（1）新建分支"><a href="#（1）新建分支" class="headerlink" title="（1）新建分支"></a>（1）新建分支</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">branch </span>新建的分支名<br></code></pre></td></tr></table></figure><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/9374b06094ee4cb09443716db626f031.png" alt="img"></p><h4 id="（2）查看所有分支信息"><a href="#（2）查看所有分支信息" class="headerlink" title="（2）查看所有分支信息"></a>（2）查看所有分支信息</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git branch</span><br></code></pre></td></tr></table></figure><h4 id="（3）-删除分支"><a href="#（3）-删除分支" class="headerlink" title="（3） 删除分支"></a>（3） 删除分支</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git branch <span class="hljs-keyword">master</span><br><span class="hljs-title">git</span> branch -d 分支名称<br>删除分支前，需要切换到其他分支 <br></code></pre></td></tr></table></figure><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/240ef3ba1d714272817a95f91408cfad.png" alt="img"></p><h5 id="①删除本地分支"><a href="#①删除本地分支" class="headerlink" title="①删除本地分支"></a>①删除本地分支</h5><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git branch<br>git checkout <span class="hljs-keyword">master</span><br><span class="hljs-title">git</span> branch -d 本地分支名<br></code></pre></td></tr></table></figure><h5 id="②删除远程分支"><a href="#②删除远程分支" class="headerlink" title="②删除远程分支"></a>②删除远程分支</h5><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> --<span class="hljs-built_in">delete</span> 远程分支名称<br></code></pre></td></tr></table></figure><p>如何本地分支已提交到远程仓库，想删除这个分支，除了删除本地分支，还需要远程分支也要删除，以上两个命令都要执行一次。</p><h3 id="8-git-status"><a href="#8-git-status" class="headerlink" title="8.git status"></a>8.git status</h3><p>查看当前分支状态</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">$ git status<br><span class="hljs-keyword">On</span> branch master<br><br>Initial commit<br><br>Changes <span class="hljs-keyword">to</span> be committed:<br>  (<span class="hljs-keyword">use</span> <span class="hljs-string">&quot;git rm --cached &lt;file&gt;...&quot;</span> <span class="hljs-keyword">to</span> unstage)<br></code></pre></td></tr></table></figure><pre><code class="hljs">new file:   READMEnew file:   hello.php</code></pre><h3 id="9-git-checkout"><a href="#9-git-checkout" class="headerlink" title="9.git checkout"></a>9.git checkout</h3><p>切换分支</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/0b4b1d669e354a588526163a51739436.png" alt="img"></p><h3 id="10-git-push"><a href="#10-git-push" class="headerlink" title="10.git push"></a>10.git push</h3><h4 id="（1）将本地的-master-分支推送到-origin-主机的-master-分支。"><a href="#（1）将本地的-master-分支推送到-origin-主机的-master-分支。" class="headerlink" title="（1）将本地的 master 分支推送到 origin 主机的 master 分支。"></a>（1）将本地的 master 分支推送到 origin 主机的 master 分支。</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> master<br></code></pre></td></tr></table></figure><h4 id="（2）本地版本与远程版本有差异，但又要强制推送可以使用-–force-参数："><a href="#（2）本地版本与远程版本有差异，但又要强制推送可以使用-–force-参数：" class="headerlink" title="（2）本地版本与远程版本有差异，但又要强制推送可以使用 –force 参数："></a>（2）本地版本与远程版本有差异，但又要强制推送可以使用 –force 参数：</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> --force <span class="hljs-built_in">origin</span> master<br></code></pre></td></tr></table></figure><h4 id="（3）指定分支"><a href="#（3）指定分支" class="headerlink" title="（3）指定分支"></a>（3）指定分支</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> <span class="hljs-keyword">push</span> &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;<br> 完整操作<br><br><span class="hljs-symbol">git</span> branch<br><span class="hljs-symbol">git</span> checkout 分支名<br>修改代码<br><span class="hljs-symbol">git</span> <span class="hljs-keyword">add</span> .<br><span class="hljs-symbol">git</span> commit -m <span class="hljs-string">&quot;提交内容注释&quot;</span><br><span class="hljs-symbol">git</span> <span class="hljs-keyword">push</span> origin master<br></code></pre></td></tr></table></figure><p>远程项目仓库对提交上来的分支代码还有做merge操作，才可以把分支代码合并到master中</p><h3 id="11-git-merge"><a href="#11-git-merge" class="headerlink" title="11.git merge"></a>11.git merge</h3><h4 id="（1）开发分支（dev）上的代码达到上线的标准后，要合并到-master-分支"><a href="#（1）开发分支（dev）上的代码达到上线的标准后，要合并到-master-分支" class="headerlink" title="（1）开发分支（dev）上的代码达到上线的标准后，要合并到 master 分支"></a>（1）开发分支（dev）上的代码达到上线的标准后，要合并到 master 分支</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git checkout dev<br>git pull<br>git checkout <span class="hljs-keyword">master</span><br><span class="hljs-title">git</span> merge dev<br>git push -u origin <span class="hljs-literal">master</span><br></code></pre></td></tr></table></figure><h4 id="（2）当master代码改动了，需要更新开发分支（dev）上的代码"><a href="#（2）当master代码改动了，需要更新开发分支（dev）上的代码" class="headerlink" title="（2）当master代码改动了，需要更新开发分支（dev）上的代码"></a>（2）当master代码改动了，需要更新开发分支（dev）上的代码</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git checkout <span class="hljs-keyword">master</span> <br><span class="hljs-title">git</span> pull <br>git checkout dev<br>git merge <span class="hljs-keyword">master</span> <br><span class="hljs-title">git</span> push -u origin dev<br></code></pre></td></tr></table></figure><h3 id="12-git-rebase"><a href="#12-git-rebase" class="headerlink" title="12.git rebase"></a>12.git rebase</h3><p>当两个分支不在一条线上，需要执行 merge 操作时使用该命令。</p><h4 id="（1）撤销提交"><a href="#（1）撤销提交" class="headerlink" title="（1）撤销提交"></a>（1）撤销提交</h4><p>如果中间的某次 commit 需要删除，可以通过 git rebase 命令实现，方法如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">git log <span class="hljs-regexp">//</span> 查找要删除的前一次提交的 commit_id<br><br>git rebase -i commit_id <span class="hljs-regexp">//</span> 将 commit_id 替换成复制的值<br></code></pre></td></tr></table></figure><p>进入 Vim 编辑模式，将要删除的 commit 前面的 <code>pick</code> 改成 <code>drop</code></p><p>保存并退出 Vim</p><h4 id="（2）解决冲突"><a href="#（2）解决冲突" class="headerlink" title="（2）解决冲突"></a>（2）解决冲突</h4><p>该命令执行时极有可能出现 reabase 冲突，可以通过以下方法解决：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">git diff <span class="hljs-regexp">//</span> 查看冲突内容<br><br><span class="hljs-regexp">//</span> 手动解决冲突（冲突位置已在文件中标明）<br><br>git add &lt;file&gt; 或 git add -A <span class="hljs-regexp">//</span> 添加<br><br>git rebase --<span class="hljs-keyword">continue</span> <span class="hljs-regexp">//</span> 继续 rebase<br><br><span class="hljs-regexp">//</span> 若还在 rebase 状态，则重复 <span class="hljs-number">2</span>、<span class="hljs-number">3</span>、<span class="hljs-number">4</span>，直至 rebase 完成出现 applying 字样<br><br>git push<br></code></pre></td></tr></table></figure><h3 id="13-git-revert"><a href="#13-git-revert" class="headerlink" title="13.git revert"></a>13.git revert</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">revert</span>：放弃某次提交。<br>git <span class="hljs-built_in">revert</span> 之前的提交仍会保留在 git <span class="hljs-built_in">log</span> 中，而此次撤销会做为一次新的提交。<br>git <span class="hljs-built_in">revert</span> -m：用于对 merge 节点的操作，-m 指定具体某个提交点。<br></code></pre></td></tr></table></figure><h4 id="（1）撤销提交-1"><a href="#（1）撤销提交-1" class="headerlink" title="（1）撤销提交"></a>（1）撤销提交</h4><p>要撤销中间某次提交时，使用 git revert 也是一个很好的选择：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">git log <span class="hljs-regexp">//</span> 查找需要撤销的 commit_id<br><br>git revert commit_id  <span class="hljs-regexp">//</span> 撤销这次提交<br></code></pre></td></tr></table></figure><h4 id="（2）撤销-merge-节点提交"><a href="#（2）撤销-merge-节点提交" class="headerlink" title="（2）撤销 merge 节点提交"></a>（2）撤销 merge 节点提交</h4><p>如果这次提交是 merge 节点的话，则需要加上 -m 指令：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">git revert commit_id -m <span class="hljs-number">1</span> <span class="hljs-regexp">//</span> 第一个提交点<br><br><span class="hljs-regexp">//</span> 手动解决冲突<br><br>git add -A<br><br>git commit -m <span class="hljs-string">&quot;&quot;</span><br><br>git revert commit_id -m <span class="hljs-number">2</span> <span class="hljs-regexp">//</span> 第二个提交点<br><br><span class="hljs-regexp">//</span> 重复 <span class="hljs-number">2</span>，<span class="hljs-number">3</span>，<span class="hljs-number">4</span><br><br>git push<br></code></pre></td></tr></table></figure><h3 id="14-git-log"><a href="#14-git-log" class="headerlink" title="14.git log"></a>14.git log</h3><h4 id="（1）查看提交历史"><a href="#（1）查看提交历史" class="headerlink" title="（1）查看提交历史"></a>（1）查看提交历史</h4><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/187898c5092342e7ba94f66906583846.png" alt="img"></p><h4 id="（2）用-–oneline-选项来查看历史记录的简洁的版本"><a href="#（2）用-–oneline-选项来查看历史记录的简洁的版本" class="headerlink" title="（2）用 –oneline 选项来查看历史记录的简洁的版本"></a>（2）用 –oneline 选项来查看历史记录的简洁的版本</h4><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/70901c43d1c4451fb1b52714231236ac.png" alt="img"></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">git <span class="hljs-built_in">log</span> <span class="hljs-comment">--oneline</span><br></code></pre></td></tr></table></figure><h4 id="（3）可以用-–graph-选项，查看历史中什么时候出现了分支、合并。"><a href="#（3）可以用-–graph-选项，查看历史中什么时候出现了分支、合并。" class="headerlink" title="（3）可以用 –graph 选项，查看历史中什么时候出现了分支、合并。"></a>（3）可以用 –graph 选项，查看历史中什么时候出现了分支、合并。</h4><p> <img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/11dde835e0bf42ff958e3272fc5d072d.png" alt="img"></p><h4 id="（4）可以用-–reverse-参数来逆向显示所有日志。"><a href="#（4）可以用-–reverse-参数来逆向显示所有日志。" class="headerlink" title="（4）可以用 –reverse 参数来逆向显示所有日志。"></a>（4）可以用 –reverse 参数来逆向显示所有日志。</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">git <span class="hljs-built_in">log</span> <span class="hljs-comment">--reverse --oneline</span><br></code></pre></td></tr></table></figure><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/98d723aab9ef4d98856e5d5c15be5f53.png" alt="img"></p><h4 id="（5）如果只想查找指定用户的提交日志"><a href="#（5）如果只想查找指定用户的提交日志" class="headerlink" title="（5）如果只想查找指定用户的提交日志"></a>（5）如果只想查找指定用户的提交日志</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">git <span class="hljs-built_in">log</span> <span class="hljs-comment">--author</span><br> 例如，比方说我们要找 Git 源码中 liyinchi 提交的部分<br><br>git <span class="hljs-built_in">log</span> <span class="hljs-comment">--author=Linus --oneline -5</span><br></code></pre></td></tr></table></figure><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/4197b596cfb442918124bce64a58c334.png" alt="img"></p><h4 id="（6）如果你要指定日期，可以执行几个选项：–since-和-–before，但是你也可以用-–until-和-–after。"><a href="#（6）如果你要指定日期，可以执行几个选项：–since-和-–before，但是你也可以用-–until-和-–after。" class="headerlink" title="（6）如果你要指定日期，可以执行几个选项：–since 和 –before，但是你也可以用 –until 和 –after。"></a>（6）如果你要指定日期，可以执行几个选项：–since 和 –before，但是你也可以用 –until 和 –after。</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git log <span class="hljs-attr">--oneline</span> <span class="hljs-attr">--before</span>=&#123;<span class="hljs-number">3</span><span class="hljs-selector-class">.weeks</span>.ago&#125; <span class="hljs-attr">--after</span>=&#123;<span class="hljs-number">2020</span>-<span class="hljs-number">04</span>-<span class="hljs-number">23</span>&#125; <span class="hljs-attr">--no-merges</span><br></code></pre></td></tr></table></figure><h4 id="（7）git-blame"><a href="#（7）git-blame" class="headerlink" title="（7）git blame"></a>（7）git blame</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">git blame &lt;<span class="hljs-built_in">file</span>&gt;<br></code></pre></td></tr></table></figure><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/b711a0bba0eb442d9afb94b946d2f935.png" alt="img"></p><h3 id="15-git-remote"><a href="#15-git-remote" class="headerlink" title="15.git remote"></a>15.git remote</h3><p>远程仓库操作</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">git remote show [remote]<br>git remote show https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/liyinchigithub/</span>Git-commands<br></code></pre></td></tr></table></figure><h4 id="（1）添加远程版本库"><a href="#（1）添加远程版本库" class="headerlink" title="（1）添加远程版本库"></a>（1）添加远程版本库</h4><p>一般在新建项目时使用</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> init<br><span class="hljs-symbol">git</span> <span class="hljs-keyword">add</span> .<br><span class="hljs-symbol">git</span> commit -m <span class="hljs-string">&quot;first commit&quot;</span><br><span class="hljs-symbol">git</span> remote <span class="hljs-keyword">add</span> origin https:<span class="hljs-comment">//github.com/liyinchigithub/Git-commands.git</span><br><span class="hljs-symbol">git</span> <span class="hljs-keyword">push</span> -u origin master<br></code></pre></td></tr></table></figure><h4 id="（2）删除远程仓库"><a href="#（2）删除远程仓库" class="headerlink" title="（2）删除远程仓库"></a>（2）删除远程仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote <span class="hljs-built_in">rm</span> name<br></code></pre></td></tr></table></figure><h4 id="（3）修改仓库名"><a href="#（3）修改仓库名" class="headerlink" title="（3）修改仓库名"></a>（3）修改仓库名</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">git remote rename old_name <span class="hljs-keyword">new</span><span class="hljs-type">_name</span> <br></code></pre></td></tr></table></figure><h3 id="15-git-config-命令"><a href="#15-git-config-命令" class="headerlink" title="15.git config 命令"></a>15.git config 命令</h3><h4 id="（1）显示当前的-git-配置信息"><a href="#（1）显示当前的-git-配置信息" class="headerlink" title="（1）显示当前的 git 配置信息"></a>（1）显示当前的 git 配置信息</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git<span class="hljs-built_in"> config </span>--list<br>credential.<span class="hljs-attribute">helper</span>=osxkeychain<br>core.<span class="hljs-attribute">repositoryformatversion</span>=0<br>core.<span class="hljs-attribute">filemode</span>=<span class="hljs-literal">true</span><br>core.<span class="hljs-attribute">bare</span>=<span class="hljs-literal">false</span><br>core.<span class="hljs-attribute">logallrefupdates</span>=<span class="hljs-literal">true</span><br>core.<span class="hljs-attribute">ignorecase</span>=<span class="hljs-literal">true</span><br>core.<span class="hljs-attribute">precomposeunicode</span>=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h4 id="（2）编辑当前的-git-配置信息"><a href="#（2）编辑当前的-git-配置信息" class="headerlink" title="（2）编辑当前的 git 配置信息"></a>（2）编辑当前的 git 配置信息</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">git config -e<br></code></pre></td></tr></table></figure><h3 id="16-git-rm"><a href="#16-git-rm" class="headerlink" title="16.git rm"></a>16.git rm</h3><p>如果需要删除的 commit 是一个或多个文件，可以进行以下操作。</p><h4 id="（1）被提交到仓库的某个文件需要删除，可以使用-git-rm-命令："><a href="#（1）被提交到仓库的某个文件需要删除，可以使用-git-rm-命令：" class="headerlink" title="（1）被提交到仓库的某个文件需要删除，可以使用 git rm 命令："></a>（1）被提交到仓库的某个文件需要删除，可以使用 git rm 命令：</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">git rm &lt;file&gt; <span class="hljs-regexp">//</span> 从工作区和暂存区删除某个文件<br><br>git commit -m <span class="hljs-string">&quot;&quot;</span> <span class="hljs-regexp">//</span> 再次提交到仓库<br></code></pre></td></tr></table></figure><h4 id="（2）如果只想从暂存区删除文件，本地工作区不做出改变，可以："><a href="#（2）如果只想从暂存区删除文件，本地工作区不做出改变，可以：" class="headerlink" title="（2）如果只想从暂存区删除文件，本地工作区不做出改变，可以："></a>（2）如果只想从暂存区删除文件，本地工作区不做出改变，可以：</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">git <span class="hljs-keyword">rm</span> --cached &lt;<span class="hljs-keyword">file</span>&gt;<br></code></pre></td></tr></table></figure><h4 id="（3）如果在工作区不小心删错了某个文件，可以用-git-checkout-将暂存区的文件覆盖工作区的文件，从而把误删的文件恢复："><a href="#（3）如果在工作区不小心删错了某个文件，可以用-git-checkout-将暂存区的文件覆盖工作区的文件，从而把误删的文件恢复：" class="headerlink" title="（3）如果在工作区不小心删错了某个文件，可以用 git checkout 将暂存区的文件覆盖工作区的文件，从而把误删的文件恢复："></a>（3）如果在工作区不小心删错了某个文件，可以用 git checkout 将暂存区的文件覆盖工作区的文件，从而把误删的文件恢复：</h4><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">git checkout <span class="hljs-comment">-- &lt;file&gt;</span><br></code></pre></td></tr></table></figure><h4 id="（4）用-git-rm-删除文件，同时还会将这个删除操作记录下来；"><a href="#（4）用-git-rm-删除文件，同时还会将这个删除操作记录下来；" class="headerlink" title="（4）用 git rm 删除文件，同时还会将这个删除操作记录下来；"></a>（4）用 git rm 删除文件，同时还会将这个删除操作记录下来；</h4><p>用 rm 删除文件，删除的仅仅是本地物理文件，没有将其从 git 的记录中剔除。</p><h4 id="（5）git-add-和-git-rm-区别，"><a href="#（5）git-add-和-git-rm-区别，" class="headerlink" title="（5）git add 和 git rm 区别，"></a>（5）git add 和 git rm 区别，</h4><p>git add 仅能记录添加、改动的动作，删除的动作需靠 git rm 来完成。</p><h3 id="17-git-tag"><a href="#17-git-tag" class="headerlink" title="17.git tag"></a>17.git tag</h3><h4 id="（1）打标签"><a href="#（1）打标签" class="headerlink" title="（1）打标签"></a>（1）打标签</h4><p>到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> tag -a <span class="hljs-built_in">v1</span>.<span class="hljs-number">0</span> -m <span class="hljs-string">&quot;release 1.0 version&quot;</span><br><br><span class="hljs-symbol">git</span> <span class="hljs-keyword">push</span> origin :<span class="hljs-built_in">v1</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>或者，每次</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git push origin <span class="hljs-keyword">tag</span> <span class="hljs-title">v1</span>.x<br></code></pre></td></tr></table></figure><h4 id="（2）查看本地标签"><a href="#（2）查看本地标签" class="headerlink" title="（2）查看本地标签"></a>（2）查看本地标签</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">tag</span><br></code></pre></td></tr></table></figure><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/d6081cbf280d50ff723260341909ecae.png" alt="img"></p><h4 id="（3）查看远程-tag"><a href="#（3）查看远程-tag" class="headerlink" title="（3）查看远程 tag"></a>（3）查看远程 tag</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">git <span class="hljs-keyword">ls</span>-remote --<span class="hljs-keyword">tags</span> origin<br></code></pre></td></tr></table></figure><h4 id="（4）将本地tag推送到远程"><a href="#（4）将本地tag推送到远程" class="headerlink" title="（4）将本地tag推送到远程"></a>（4）将本地tag推送到远程</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> <span class="hljs-keyword">push</span> origin <span class="hljs-built_in">v1</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>也可以仅执行该句，会自动生成本地tag并推送到远程<img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/1f287279ce8c5febddcc7c0e04533fe4.png" alt="img"></p><h4 id="（5）完整打标签并推送到远程仓库"><a href="#（5）完整打标签并推送到远程仓库" class="headerlink" title="（5）完整打标签并推送到远程仓库"></a>（5）完整打标签并推送到远程仓库</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git add .<br><br>git commit -m <span class="hljs-string">&quot;first commit&quot;</span><br><br>git push origin <span class="hljs-keyword">master</span><br><br><span class="hljs-title">git</span> push origin v1.<span class="hljs-number">0</span><br>或者 <br><br>git add .<br><br>git commit -m <span class="hljs-string">&quot;first commit&quot;</span><br><br>git push origin <span class="hljs-keyword">master</span><br><br><span class="hljs-title">git</span> <span class="hljs-keyword">tag</span> <span class="hljs-title">-a</span> v1.<span class="hljs-number">1</span> -m <span class="hljs-string">&quot;release 1.0 version&quot;</span><br><br>git <span class="hljs-keyword">tag</span><br><br><span class="hljs-title">git</span> push origin :v1.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="（6）删除本地标签"><a href="#（6）删除本地标签" class="headerlink" title="（6）删除本地标签"></a>（6）删除本地标签</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">tag</span><br><span class="hljs-title">git</span> <span class="hljs-keyword">tag</span> <span class="hljs-title">-d</span> 标签名<br></code></pre></td></tr></table></figure><h4 id="（7）删除远程标签"><a href="#（7）删除远程标签" class="headerlink" title="（7）删除远程标签"></a>（7）删除远程标签</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">git push origin <span class="hljs-symbol">:refs/tags/v1</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="（8）追加标签"><a href="#（8）追加标签" class="headerlink" title="（8）追加标签"></a>（8）追加标签</h4><p>如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。</p><ul><li>```<br>$ git tag -a v0.9 85fc7e7<br>$ git log –oneline –decorate –graph<ul><li>d5e9fc2 (HEAD -&gt; master) Merge branch ‘change_site’<br>|\<br>| * 7774248 (change_site) changed the runoob.php</li><li>| c68142b 修改代码<br>|/  </li><li> c1501a2 removed test.txt、add runoob.php</li><li> 3e92c19 add test.txt</li><li> 3b58100 (tag: v0.9) 第一次版本提交<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>  <br><br>  ### 常见问题<br><br>  #### <span class="hljs-number">1.</span>执行git push origin 提示”git hint: Please, commit your changes before merging“<br><br>解决办法：<br><br>简洁显示日志记录<br><br></code></pre></td></tr></table></figure>git log –pretty=oneline </li></ul></li></ul><p>git reset –hard 提交id</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>![img](https:<span class="hljs-regexp">//</span>fastly.jsdelivr.net<span class="hljs-regexp">/gh/</span>xuzengsong<span class="hljs-regexp">/picbed@main/</span><span class="hljs-regexp">/img/</span>c91fcc831bbc40d9bcb556eb54982bde.png)<br><br><span class="hljs-comment">#### 2.执行git pull 提示”error: You have not concluded your merge (MERGE_HEAD exists).</span><br><br>hint: Please, commit your changes before merging.<br>fatal: Exiting because of unfinished merge.“<br><br>![img](https:<span class="hljs-regexp">//</span>fastly.jsdelivr.net<span class="hljs-regexp">/gh/</span>xuzengsong<span class="hljs-regexp">/picbed@main/</span><span class="hljs-regexp">/img/</span>faacb4cf348546d0bc54d437c064aa5d.png)<br><br> 解决办法：<br><br></code></pre></td></tr></table></figure><p>git reset –soft HEAD^</p><pre><code class="hljs">版权声明：本文为CSDN博主「liyinchi1988」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/u013302168/article/details/124360566</code></pre>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DL学习路径建议</title>
    <link href="/2023/03/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/"/>
    <url>/2023/03/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h1 id="DL学习路径建议"><a href="#DL学习路径建议" class="headerlink" title="DL学习路径建议"></a>DL学习路径建议</h1><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/uTools_1678265406750.png" alt="uTools_1678265406750"></p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="1、Python学习"><a href="#1、Python学习" class="headerlink" title="1、Python学习"></a>1、Python学习</h3><p>主要帮助大家掌握    <strong>表示，清洗，统计，展示数据</strong>  的能力，打好基础。（粗略看）</p><p><a href="https://www.bilibili.com/video/BV1L64y1X7om/?vd_source=c5c4bdd8a8e3ff586145c67e72ab2bf6">北理-Python数据分析与展示-Numpy、Matplotlib、Pandas</a></p><p>**IDE: **Pychram(建议)，Vscode</p><h3 id="2、PyTorch学习"><a href="#2、PyTorch学习" class="headerlink" title="2、PyTorch学习"></a>2、PyTorch学习</h3><p>Pytorch是一个开源深度学习框架，类似的框架还有TensorFlow, PaddlePaddle等。PyTorch是深度学习的一个很好的切入点，Pytorch的风格与Python风格一致性较高。如果有一定的Python基础，那么会发现PyTorch是一种直观、高效和启发性的体验。PyTorch的核心优势在于快速原型实验和测试想法的能力，另外具备将实验转化为生产性、可部署资源的可能性的能力。</p><p><a href="https://www.bilibili.com/video/BV1Kp4y147Rw/?spm_id_from=333.999.0.0&vd_source=c5c4bdd8a8e3ff586145c67e72ab2bf6">Pytorch框架搭建（痛苦面具）</a></p><p>课程（边学边练，不用太细致）：</p><p><a href="https://www.bilibili.com/medialist/detail/ml1689407997?type=1&spm_id_from=333.999.0.0">李沐的动手深度学习</a></p><p><a href="https://pytorch.org/tutorials/">官网教程</a></p><h3 id="3、文献检索"><a href="#3、文献检索" class="headerlink" title="3、文献检索"></a>3、文献检索</h3><p><a href="https://www.cnki.net/">中国知网</a>、<a href="https://www.wanfangdata.com.cn/index.html?index=true">万方</a>、<a href="https://paperswithcode.com/">paperswithcode</a>（文献较少，但有代码）、<a href="https://sci-hub.se/">sci-hub</a>、<a href="https://scholar.google.com.hk/">谷歌学术</a></p><h3 id="4、文献管理"><a href="#4、文献管理" class="headerlink" title="4、文献管理"></a>4、文献管理</h3><p>文件管理软件</p><p><a href="https://www.bilibili.com/video/BV1xg411f736/?spm_id_from=333.337.search-card.all.click&vd_source=c5c4bdd8a8e3ff586145c67e72ab2bf6">Zotero</a></p><h3 id="5、写论文"><a href="#5、写论文" class="headerlink" title="5、写论文"></a>5、写论文</h3><p><strong>论文润色，语法修改，综述撰写……:</strong></p><p>Chatgpt，New Bing（与时俱进，合理利用)</p><p><strong>公式识别：</strong></p><p>Mathpix Snipping Tool</p><p><strong>Latex在线编辑器，需要学习latex语法：</strong></p><p><a href="https://www.overleaf.com/">Overleaf</a></p><table><thead><tr><th>信息</th><th></th></tr></thead><tbody><tr><td>整理人</td><td>徐赠淞</td></tr><tr><td>时间</td><td>2023-03-08</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud下JNA调用Cpp</title>
    <link href="/2023/03/29/SpringCloud%E4%B8%8BJNA%E8%B0%83%E7%94%A8Cpp/"/>
    <url>/2023/03/29/SpringCloud%E4%B8%8BJNA%E8%B0%83%E7%94%A8Cpp/</url>
    
    <content type="html"><![CDATA[<h1 id="1、Idea准备"><a href="#1、Idea准备" class="headerlink" title="1、Idea准备"></a>1、Idea准备</h1><h2 id="1、创建Spring-cloud工程"><a href="#1、创建Spring-cloud工程" class="headerlink" title="1、创建Spring cloud工程"></a>1、创建Spring cloud工程</h2><p><a href="https://xuzengsong.github.io/2023/03/28/springCloud/#SpringCloud01">参考SpringCloud资料</a></p><p><a href="https://www.cnblogs.com/teach/p/16300271.html">Springboot创建</a></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230329193530840.png" alt="image-20230329193530840"></p><h2 id="2、在需要调用的微服务中引入坐标"><a href="#2、在需要调用的微服务中引入坐标" class="headerlink" title="2、在需要调用的微服务中引入坐标"></a>2、在需要调用的微服务中引入坐标</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>  &lt;groupId&gt;net.java.dev.jna&lt;/groupId&gt;<br>  &lt;artifactId&gt;jna&lt;/artifactId&gt;<br>  &lt;version&gt;<span class="hljs-number">5.5</span><span class="hljs-number">.0</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br><br>&lt;dependency&gt;<br>  &lt;groupId&gt;net.java.dev.jna&lt;/groupId&gt;<br>  &lt;artifactId&gt;jna-platform&lt;/artifactId&gt;<br>  &lt;version&gt;<span class="hljs-number">5.5</span><span class="hljs-number">.0</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;!--整合Dll开发--&gt;<br></code></pre></td></tr></table></figure><p>比如我这的user-service</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230329194136294.png" alt="image-20230329194136294"></p><h2 id="3、调用dll库"><a href="#3、调用dll库" class="headerlink" title="3、调用dll库"></a>3、调用dll库</h2><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230329194305495.png" alt="image-20230329194305495"></p><h1 id="2、cpp动态库准备（这里Windows环境）"><a href="#2、cpp动态库准备（这里Windows环境）" class="headerlink" title="2、cpp动态库准备（这里Windows环境）"></a>2、cpp动态库准备（这里Windows环境）</h1><h2 id="1、创建一个dll项目"><a href="#1、创建一个dll项目" class="headerlink" title="1、创建一个dll项目"></a>1、创建一个dll项目</h2><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230329194439076.png" alt="image-20230329194439076"></p><h2 id="2、编辑cpp"><a href="#2、编辑cpp" class="headerlink" title="2、编辑cpp"></a>2、编辑cpp</h2><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230329194957984.png" alt="image-20230329194957984"></p><h2 id="3、编辑头文件"><a href="#3、编辑头文件" class="headerlink" title="3、编辑头文件"></a>3、编辑头文件</h2><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230329195029298.png" alt="image-20230329195029298"></p><h2 id="4、生成dll"><a href="#4、生成dll" class="headerlink" title="4、生成dll"></a>4、生成dll</h2><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230329195146473.png" alt="image-20230329195146473"></p><h1 id="3、JAVA与C-的类型对应"><a href="#3、JAVA与C-的类型对应" class="headerlink" title="3、JAVA与C++的类型对应"></a>3、JAVA与C++的类型对应</h1><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230329195637241.png" alt="image-20230329195637241"></p><p><a href="https://blog.csdn.net/weixin_44120785/article/details/128046886">Linux下JAVA使用JNA调用C++的动态链接库（g++或者gcc编译的.so文件）</a></p><p><a href="https://blog.csdn.net/m0_37787662/article/details/105818459">Java-JNA框架调用dll动态库实例</a></p><p><a href="https://blog.csdn.net/redchairman/article/details/108438202">彻底解决JNA String(Java)转char*(c++)乱码问题</a></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>C++&amp;JAVA微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JNAvsJNI</title>
    <link href="/2023/03/29/JNAvsJNI/"/>
    <url>/2023/03/29/JNAvsJNI/</url>
    
    <content type="html"><![CDATA[<p>Jna与Jni调用C/C++效率比较</p><p>前言：       </p><pre><code class="hljs">   JNA是建立在JNI技术基础之上的一个Java类库，它使您可以方便地使用java直接访问动态链接库中的函数。原来使用JNI，你必须手工用C写一个动态链接库，在C语言中映射Java的数据类型。JNA中，它提供了一个动态的C语言编写的转发器，可以自动实现Java和C的数据类型映射。你不再需要编写C动态链接库。当然，这也意味着，使用JNA技术比使用JNI技术调用动态链接库会有些微的性能损失。可能速度会降低十几倍。就看你的需求来用了。</code></pre><p>Jna：花时131ms如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20190402110836618.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hxeTE3MTkyMzkzMzc=,size_16,color_FFFFFF,t_70" alt="img"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/20190402111012441.PNG" alt="img"></p><p>Jni：花时8ms如下图所示：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/20190402111144866.PNG" alt="img"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/20190402111232503.PNG" alt="img"></p><p> 总结：可见Jna调用C函数效率比jni低，但jna不用自己用c写一系列动态库等配置，用法比较简单。所以现在一般都使用jna调用c/c++函数。</p><p>可参考博客：<a href="https://blog.csdn.net/drifterj/article/details/7841810">https://blog.csdn.net/drifterj/article/details/7841810</a></p><p>附上jna java端代码：</p><p>import com.sun.jna.Library;<br>import com.sun.jna.Native;</p><p>import sun.security.jca.GetInstance.Instance;</p><p>public class TestJna {</p><pre><code class="hljs"> public interface CLibrary extends Library &#123;        CLibrary INSTANCE = (CLibrary)Native.loadLibrary(&quot;TestDll&quot;, CLibrary.class); void testJnaTime();       // int add(int a, int b);    &#125;     public static void main(String[] args) &#123;     //   int sum = CLibrary.INSTANCE.add(3, 6);// CLibrary.INSTANCE.testJnaTime();      //  System.out.println(sum); long beginTime = System.currentTimeMillis();    int i;int j;    for(i=1;i&lt;21;i++)&#123;        for(j=i;j&lt;51;j++)&#123;            System.out.println(j);            CLibrary.INSTANCE.testJnaTime();            &#125;    &#125;    long totalTime = System.currentTimeMillis()-beginTime;    System.out.println(&quot;JNI AllTime（ms）：&quot;+totalTime);     &#125;</code></pre><p>​<br>}<br>Jni  java端代码：</p><p>package cn.com.infosec.test;</p><p>public class TestJniTime {<br>    public native  void testTime();<br>     public static void main(String[] args){<br>         System.loadLibrary(“TestJniTime”);<br>         TestJniTime t=new TestJniTime();<br>         long beginTime = System.currentTimeMillis();<br>            int i;int j;<br>            for(i=1;i&lt;51;i++){<br>                for(j=i;j&lt;51;j++){<br>                    System.out.println(j);<br>                     t.testTime();<br>                }<br>            }<br>            long totalTime = System.currentTimeMillis()-beginTime;<br>            System.out.println(“JNI AllTime（ms）：”+totalTime);<br>     }<br>}<br> JniC端代码：</p><p>#include “TestJniTime.h”<br>#include “cn_com_infosec_test_TestJniTime.h”</p><p>JNIEXPORT void JNICALL Java_cn_com_infosec_test_TestJniTime_testTime<br>(JNIEnv *, jobject) {<br>    printf(“hi jni \n”);</p><p>}<br>（其余就不写的，百度上很多）</p><p>Jni教程推荐看博客：<a href="http://www.runoob.com/w3cnote/jni-getting-started-tutorials.html">http://www.runoob.com/w3cnote/jni-getting-started-tutorials.html</a></p><p>不同的是：在生成.h文件时，我用的是以下方法：</p><p>javah -jni -classpath E:\eclipse.sts\Test\src  cn.com.infosec.test.TestJniTime</p><p>E:\eclipse.sts\Test\src这个路径是你的包所在的路径，后面的是全包名+class文件</p><p>Jni教程推荐看博客：</p><p><a href="https://blog.csdn.net/gwd1154978352/article/details/55097376/">https://blog.csdn.net/gwd1154978352/article/details/55097376/</a></p><p>不同：在c代码处：<br><code>extern &quot;C&quot;_declspec(dllexport) int add(int a, int b);</code></p><p>直接复制以上博客的这个代码时候会报错，于是我把“C”右边的行线删了，自己写个下划线，就好了。如下：</p><p><code>extern &quot;C&quot; —declspec(dllexport) int add(int a, int b);</code><br>————————————————<br>版权声明：本文为CSDN博主「么滴感情de杀手」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/hqy1719239337/article/details/88966183">https://blog.csdn.net/hqy1719239337/article/details/88966183</a></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>C++&amp;JAVA微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++利用Sidecar模式实现微服务化的流程</title>
    <link href="/2023/03/29/C++%E5%88%A9%E7%94%A8Sidecar%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8C%96%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
    <url>/2023/03/29/C++%E5%88%A9%E7%94%A8Sidecar%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8C%96%E7%9A%84%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="C-利用Sidecar模式实现微服务化的流程"><a href="#C-利用Sidecar模式实现微服务化的流程" class="headerlink" title="C++利用Sidecar模式实现微服务化的流程"></a>C++利用Sidecar模式实现微服务化的流程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  公司近期要将园区所有的服务做成微服务模式，因之前负责的网关服务是C++来实现的，因此研究了一下非jvm语言实现向Eureka注册中心注册的过程，特此记录，以便后续的温习，初次了解微服务，如有错误，欢迎指正。<br>  关于sidecar模式的原理和为何采用sidecar模式在网上能够找到相关的博客去了解，这里转载几篇好的文章，大家可以学习了解一下。</p><p><a href="https://blog.csdn.net/StarskyBoy/article/details/85012642">https://blog.csdn.net/StarskyBoy/article/details/85012642</a><br><a href="https://blog.csdn.net/yang00322/article/details/77964703">https://blog.csdn.net/yang00322/article/details/77964703</a><br><a href="https://www.jianshu.com/p/a96056870143">https://www.jianshu.com/p/a96056870143</a></p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p> 下面主要来记录一下服务和Eureka注册中心交互的过程，以下的过程是根据java的同事在通过配置Eureka客户端，来向Eureka服务器发起请求时，用wireshark抓包工具查看完整的交互流程。再通过Eureka提供的REST接口，利用C++里面的Poco库的http相关接口，来实现微服务化向Eureka注册，并实现服务的监控。<br>1、服务注册<br>REST接口：POST /eureka/v2/apps/appID<br>代码段如下：</p><pre><code class="hljs">    Poco::URI uri(&quot;http://ip:port/eureka/apps/appID&quot;);    Poco::Net::HTTPClientSession session(uri.getHost(), uri.getPort());    session.setKeepAlive(true);    //创建 HTTP request    Poco::Net::HTTPRequest request(Poco::Net::HTTPRequest::HTTP_PUT, uri.getPathAndQuery(),               Poco::Net::HTTPMessage::HTTP_1_1);    request.setContentType(&quot;application/json; charset=utf-8&quot;);    request.setContentLength((int)msg.length());        std::ostream &amp;reqOstr = session.sendRequest(request);    reqOstr &lt;&lt; msg;</code></pre><p>其中，appID是要向Eureka注册的服务名，msg是一个标准的json字符串，json字符串的基本内容如下图：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/20191109112024899.png" alt="在这里插入图片描述"></p><p>*以下是我整理的注册发给Eureka的json字符串的相关字段释义：</p><p>InstanceInfo服务实例信息字段：<br>1）instanceId : 实例id<br>2）hostName: 主机名称<br>3）app：应用名<br>4）ipAddr：ip地址<br>5）status：实例状态，如UP，DOWN,STARTING,OUT_OF_SERVICE,UNKOWN<br>6）overriddenStatus：外界需要强制覆盖的状态值，默认为UNKOWN<br>7）port：端口号<br>8）securePort：https的端口号<br>9）countryId：被废弃的属性，属性为1，代表US<br>10）dataCenterInfo：dataCenter的信息，Netflix或者Amazon或者MyOwn<br>11）leaseInfo：租约信息<br>12）metadata：应用实例的元数据信息<br>13）homePageUrl：应用实例的首页url<br>14）statusPageUrl：应用实例的状态页<br>15）healthCheckUrl；应用实例的健康检查url<br>16）vipAddress：虚拟ip地址<br>17）secureVipAddress：https的虚拟ip地址<br>18）isCoordinatingDiscoveryServer：首先标识是否是DiscoveryServer,其次标识该DiscoveryServer是否是响应你请求的实例<br>19）lastUpdatedTimestamp：状态信息最后更新时间<br>20）lastDirtyTimestamp：实例信息最新的过期时间，在client端用于标识<br>21）sid：被废弃的属性，默认为na<br>22）actionType：标识EurekaServer对该实例执行的操作，包括ADDED,MODIFIED,DELETE这三类<br>23）asgName：在AWS的autoscaling group的名称<br>LeaseInfo租约信息字段：<br>以下参数主要用于标识应用实例的心跳情况，比如约定的心跳周期，租约有效期，最后一次续约时间等。<br>1）renewalIntervalInSecs：client端续约的间隔时间<br>2）durationInSecs：client端需要设定的租约的有效时长<br>3）registrationTimestamp: Server端设置的该租约第一次注册时间<br>4）lastRenewalTimestamp: Server端设置的该租约最后一次续约时间<br>5）evictionTimestamp；Server端设置的该租约被剔除的时间<br>6）serviceUpTimestamp：Server端设置的该服务实例标记为Up的时间*</p><h2 id="2、获取服务实例"><a href="#2、获取服务实例" class="headerlink" title="2、获取服务实例"></a>2、获取服务实例</h2><p>获取服务实例的接口有两个，一个是获取全量服务实例列表，即每次获取Eureka服务器上的所有实例，另外一个是实现增量实例列表，增量拉取变化的服务信息，然后本地去做更新。<br>REST接口：<br>全量：GET /eureka/apps<br>增量：GET /eureka/apps/delta<br>这里为了方便只是做了全量的实现，代码段如下：</p><pre><code class="hljs">    Poco::URI uri(&quot;http://ip:port/eureka/apps&quot;);    Poco::Net::HTTPClientSession session(uri.getHost(), uri.getPort());    Poco::Net::HTTPRequest request(Poco::Net::HTTPRequest::HTTP_GET, uri.getPathAndQuery());    session.sendRequest(request);</code></pre><p>这里通过抓包来分析，只有第一次调用的是全量的接口，后面每次发送心跳后都会调用一次获取增量的接口，来做本地服务实例的更新。</p><h2 id="3、心跳检测-心跳续约"><a href="#3、心跳检测-心跳续约" class="headerlink" title="3、心跳检测/心跳续约"></a>3、心跳检测/心跳续约</h2><p>注册完之后，会根据配置的心跳时间来规律的向Eureka发送心跳，告诉它还“活着”，如果超过续约时间还没有发接收到心跳，Eureka服务端会将服务自动剔除。这个时间间隔是可配的，上面字段释义里面已经提到。<br>REST接口：PUT /eureka/apps/appID/instanceID<br>（instanceId是和服务实例相关联的唯一id，默认组成为hostname+appId+端口号）<br>代码同注册的代码段，只需要将http的请求方式post改成put即可。</p><h2 id="4、服务下线"><a href="#4、服务下线" class="headerlink" title="4、服务下线"></a>4、服务下线</h2><p>服务下线，当服务主动停止后，会触发一个服务下线的REST请求，告诉Eureka下线，此时Eureka会将服务设置为DWON，并将消息广播发送出去，并更新缓存清单。<br>REST接口：DELETE/eureka/apps/appId/instanceId</p><h2 id="5、健康检查"><a href="#5、健康检查" class="headerlink" title="5、健康检查"></a>5、健康检查</h2><p>服务微服务化之后，会对里面的业务进行自我监控，如果某个业务断开连接或者不正常工作，就需要发送给Eureka注册中心，将服务的状态从UP改为DOWN，Eureka注册中心就不会再向客户端发起请求，这样的一个流程就叫做健康检测。健康状态接口还可以通过<a href="http://ip:port/health来查看，内容如下：">http://ip:port/health来查看，内容如下：</a><br>Example：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot; Eureka  Client&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;UP&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure><p>总结<br>整个流程下来其实不难，我理解的是这样，sidecar模式其实也是在本身存在的服务基础上实现一个健康检查接口，向Eureka服务端注册，并向Eureka服务端反馈自身的一个健康情况。<br>第一次写博客，如有错误或者不当的地方，欢迎指正！如果有侵权的地方，请及时告知，谢谢！<br>————————————————<br>版权声明：本文为CSDN博主「天真无邪的小白程序员」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_45857272/article/details/102983834">https://blog.csdn.net/qq_45857272/article/details/102983834</a></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>C++&amp;JAVA微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nacos集群搭建</title>
    <link href="/2023/03/28/nacos%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <url>/2023/03/28/nacos%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Nacos集群搭建"><a href="#Nacos集群搭建" class="headerlink" title="Nacos集群搭建"></a>Nacos集群搭建</h1><h1 id="1-集群结构图"><a href="#1-集群结构图" class="headerlink" title="1.集群结构图"></a>1.集群结构图</h1><p>官方给出的Nacos集群图：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210409210621117.png" alt="image-20210409210621117"></p><p>其中包含3个nacos节点，然后一个负载均衡器代理3个Nacos。这里负载均衡器可以使用nginx。</p><p>我们计划的集群结构：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210409211355037.png" alt="image-20210409211355037"></p><p>三个nacos节点的地址：</p><table><thead><tr><th>节点</th><th>ip</th><th>port</th></tr></thead><tbody><tr><td>nacos1</td><td>192.168.150.1</td><td>8845</td></tr><tr><td>nacos2</td><td>192.168.150.1</td><td>8846</td></tr><tr><td>nacos3</td><td>192.168.150.1</td><td>8847</td></tr></tbody></table><h1 id="2-搭建集群"><a href="#2-搭建集群" class="headerlink" title="2.搭建集群"></a>2.搭建集群</h1><p>搭建集群的基本步骤：</p><ul><li>搭建数据库，初始化数据库表结构</li><li>下载nacos安装包</li><li>配置nacos</li><li>启动nacos集群</li><li>nginx反向代理</li></ul><h2 id="2-1-初始化数据库"><a href="#2-1-初始化数据库" class="headerlink" title="2.1.初始化数据库"></a>2.1.初始化数据库</h2><p>Nacos默认数据存储在内嵌数据库Derby中，不属于生产可用的数据库。</p><p>官方推荐的最佳实践是使用带有主从的高可用数据库集群，主从模式的高可用数据库可以参考<strong>传智教育</strong>的后续高手课程。</p><p>这里我们以单点的数据库为例来讲解。</p><p>首先新建一个数据库，命名为nacos，而后导入下面的SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `config_info` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;id&#x27;</span>,<br>  `data_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;data_id&#x27;</span>,<br>  `group_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `content` longtext <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;content&#x27;</span>,<br>  `md5` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;md5&#x27;</span>,<br>  `gmt_create` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>  `gmt_modified` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;修改时间&#x27;</span>,<br>  `src_user` text COMMENT <span class="hljs-string">&#x27;source user&#x27;</span>,<br>  `src_ip` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;source ip&#x27;</span>,<br>  `app_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `tenant_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;租户字段&#x27;</span>,<br>  `c_desc` <span class="hljs-type">varchar</span>(<span class="hljs-number">256</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `c_use` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `effect` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `type` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `c_schema` text,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8_bin COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;config_info&#x27;</span>;<br><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-comment">/*   数据库全名 = nacos_config   */</span><br><span class="hljs-comment">/*   表名称 = config_info_aggr   */</span><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `config_info_aggr` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;id&#x27;</span>,<br>  `data_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;data_id&#x27;</span>,<br>  `group_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;group_id&#x27;</span>,<br>  `datum_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;datum_id&#x27;</span>,<br>  `content` longtext <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;内容&#x27;</span>,<br>  `gmt_modified` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;修改时间&#x27;</span>,<br>  `app_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `tenant_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;租户字段&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8_bin COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;增加租户字段&#x27;</span>;<br><br><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-comment">/*   数据库全名 = nacos_config   */</span><br><span class="hljs-comment">/*   表名称 = config_info_beta   */</span><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `config_info_beta` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;id&#x27;</span>,<br>  `data_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;data_id&#x27;</span>,<br>  `group_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;group_id&#x27;</span>,<br>  `app_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;app_name&#x27;</span>,<br>  `content` longtext <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;content&#x27;</span>,<br>  `beta_ips` <span class="hljs-type">varchar</span>(<span class="hljs-number">1024</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;betaIps&#x27;</span>,<br>  `md5` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;md5&#x27;</span>,<br>  `gmt_create` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>  `gmt_modified` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;修改时间&#x27;</span>,<br>  `src_user` text COMMENT <span class="hljs-string">&#x27;source user&#x27;</span>,<br>  `src_ip` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;source ip&#x27;</span>,<br>  `tenant_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;租户字段&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8_bin COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;config_info_beta&#x27;</span>;<br><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-comment">/*   数据库全名 = nacos_config   */</span><br><span class="hljs-comment">/*   表名称 = config_info_tag   */</span><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `config_info_tag` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;id&#x27;</span>,<br>  `data_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;data_id&#x27;</span>,<br>  `group_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;group_id&#x27;</span>,<br>  `tenant_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;tenant_id&#x27;</span>,<br>  `tag_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;tag_id&#x27;</span>,<br>  `app_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;app_name&#x27;</span>,<br>  `content` longtext <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;content&#x27;</span>,<br>  `md5` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;md5&#x27;</span>,<br>  `gmt_create` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>  `gmt_modified` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;修改时间&#x27;</span>,<br>  `src_user` text COMMENT <span class="hljs-string">&#x27;source user&#x27;</span>,<br>  `src_ip` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;source ip&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8_bin COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;config_info_tag&#x27;</span>;<br><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-comment">/*   数据库全名 = nacos_config   */</span><br><span class="hljs-comment">/*   表名称 = config_tags_relation   */</span><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `config_tags_relation` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;id&#x27;</span>,<br>  `tag_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;tag_name&#x27;</span>,<br>  `tag_type` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;tag_type&#x27;</span>,<br>  `data_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;data_id&#x27;</span>,<br>  `group_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;group_id&#x27;</span>,<br>  `tenant_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;tenant_id&#x27;</span>,<br>  `nid` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`nid`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`),<br>  KEY `idx_tenant_id` (`tenant_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8_bin COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;config_tag_relation&#x27;</span>;<br><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-comment">/*   数据库全名 = nacos_config   */</span><br><span class="hljs-comment">/*   表名称 = group_capacity   */</span><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `group_capacity` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;主键ID&#x27;</span>,<br>  `group_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;Group ID，空字符表示整个集群&#x27;</span>,<br>  `quota` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;配额，0表示使用默认值&#x27;</span>,<br>  `usage` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;使用量&#x27;</span>,<br>  `max_size` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,<br>  `max_aggr_count` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;聚合子配置最大个数，，0表示使用默认值&#x27;</span>,<br>  `max_aggr_size` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,<br>  `max_history_count` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;最大变更历史数量&#x27;</span>,<br>  `gmt_create` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>  `gmt_modified` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;修改时间&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `uk_group_id` (`group_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8_bin COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;集群、各Group容量信息表&#x27;</span>;<br><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-comment">/*   数据库全名 = nacos_config   */</span><br><span class="hljs-comment">/*   表名称 = his_config_info   */</span><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `his_config_info` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">64</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `nid` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `data_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `group_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `app_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;app_name&#x27;</span>,<br>  `content` longtext <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `md5` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `gmt_create` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>  `gmt_modified` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>  `src_user` text,<br>  `src_ip` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `op_type` <span class="hljs-type">char</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `tenant_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;租户字段&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`nid`),<br>  KEY `idx_gmt_create` (`gmt_create`),<br>  KEY `idx_gmt_modified` (`gmt_modified`),<br>  KEY `idx_did` (`data_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8_bin COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;多租户改造&#x27;</span>;<br><br><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-comment">/*   数据库全名 = nacos_config   */</span><br><span class="hljs-comment">/*   表名称 = tenant_capacity   */</span><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `tenant_capacity` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;主键ID&#x27;</span>,<br>  `tenant_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;Tenant ID&#x27;</span>,<br>  `quota` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;配额，0表示使用默认值&#x27;</span>,<br>  `usage` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;使用量&#x27;</span>,<br>  `max_size` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,<br>  `max_aggr_count` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;聚合子配置最大个数&#x27;</span>,<br>  `max_aggr_size` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,<br>  `max_history_count` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;最大变更历史数量&#x27;</span>,<br>  `gmt_create` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>  `gmt_modified` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;修改时间&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `uk_tenant_id` (`tenant_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8_bin COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;租户容量信息表&#x27;</span>;<br><br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `tenant_info` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;id&#x27;</span>,<br>  `kp` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;kp&#x27;</span>,<br>  `tenant_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;tenant_id&#x27;</span>,<br>  `tenant_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;tenant_name&#x27;</span>,<br>  `tenant_desc` <span class="hljs-type">varchar</span>(<span class="hljs-number">256</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;tenant_desc&#x27;</span>,<br>  `create_source` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;create_source&#x27;</span>,<br>  `gmt_create` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>  `gmt_modified` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;修改时间&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`),<br>  KEY `idx_tenant_id` (`tenant_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8_bin COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;tenant_info&#x27;</span>;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `users` (<br>`username` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>`password` <span class="hljs-type">varchar</span>(<span class="hljs-number">500</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`enabled` <span class="hljs-type">boolean</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br>);<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `roles` (<br>`username` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`role` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-keyword">UNIQUE</span> INDEX `idx_user_role` (`username` <span class="hljs-keyword">ASC</span>, `role` <span class="hljs-keyword">ASC</span>) <span class="hljs-keyword">USING</span> BTREE<br>);<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `permissions` (<br>    `role` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `resource` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `action` <span class="hljs-type">varchar</span>(<span class="hljs-number">8</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">UNIQUE</span> INDEX `uk_role_permission` (`role`,`resource`,`action`) <span class="hljs-keyword">USING</span> BTREE<br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> users (username, password, enabled) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;nacos&#x27;</span>, <span class="hljs-string">&#x27;$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#x27;</span>, <span class="hljs-literal">TRUE</span>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> roles (username, role) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;nacos&#x27;</span>, <span class="hljs-string">&#x27;ROLE_ADMIN&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="2-2-下载nacos"><a href="#2-2-下载nacos" class="headerlink" title="2.2.下载nacos"></a>2.2.下载nacos</h2><p>nacos在GitHub上有下载地址：<a href="https://github.com/alibaba/nacos/tags%EF%BC%8C%E5%8F%AF%E4%BB%A5%E9%80%89%E6%8B%A9%E4%BB%BB%E6%84%8F%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD%E3%80%82">https://github.com/alibaba/nacos/tags，可以选择任意版本下载。</a></p><p>本例中才用1.4.1版本：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210409212119411.png" alt="image-20210409212119411"></p><h2 id="2-3-配置Nacos"><a href="#2-3-配置Nacos" class="headerlink" title="2.3.配置Nacos"></a>2.3.配置Nacos</h2><p>将这个包解压到任意非中文目录下，如图：</p><p><img src="D:\workspace\java学习\17、微服务开发框架SpringCloud+RabbitMQ+Docker+Redis+搜索+分布式史上最全面的微服务全技术栈课程\day02-SpringCloud02\资料\assets\image-20210402161843337.png" alt="image-20210402161843337"></p><p>目录说明：</p><ul><li>bin：启动脚本</li><li>conf：配置文件</li></ul><p>进入nacos的conf目录，修改配置文件cluster.conf.example，重命名为cluster.conf：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210409212459292.png" alt="image-20210409212459292"></p><p>然后添加内容：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:8845</span><br><span class="hljs-number">127.0.0.1</span>.<span class="hljs-number">8846</span><br><span class="hljs-number">127.0.0.1</span>.<span class="hljs-number">8847</span><br></code></pre></td></tr></table></figure><p>然后修改application.properties文件，添加数据库配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.datasource.platform</span>=<span class="hljs-string">mysql</span><br><br><span class="hljs-attr">db.num</span>=<span class="hljs-string">1</span><br><br><span class="hljs-attr">db.url.0</span>=<span class="hljs-string">jdbc:mysql://127.0.0.1:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span><br><span class="hljs-attr">db.user.0</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">db.password.0</span>=<span class="hljs-string">123</span><br></code></pre></td></tr></table></figure><h2 id="2-4-启动"><a href="#2-4-启动" class="headerlink" title="2.4.启动"></a>2.4.启动</h2><p>将nacos文件夹复制三份，分别命名为：nacos1、nacos2、nacos3</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210409213335538.png" alt="image-20210409213335538"> </p><p>然后分别修改三个文件夹中的application.properties，</p><p>nacos1:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">8845</span><br></code></pre></td></tr></table></figure><p>nacos2:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">8846</span><br></code></pre></td></tr></table></figure><p>nacos3:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">8847</span><br></code></pre></td></tr></table></figure><p>然后分别启动三个nacos节点：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">startup.<span class="hljs-built_in">cmd</span><br></code></pre></td></tr></table></figure><h2 id="2-5-nginx反向代理"><a href="#2-5-nginx反向代理" class="headerlink" title="2.5.nginx反向代理"></a>2.5.nginx反向代理</h2><p>找到课前资料提供的nginx安装包： </p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210410103253355.png" alt="image-20210410103253355"> </p><p>解压到任意非中文目录下：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210410103322874.png" alt="image-20210410103322874"> </p><p>修改conf/nginx.conf文件，配置如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> nacos-cluster &#123;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8845</span>;<br><span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8846</span>;<br><span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8847</span>;<br>&#125;<br><br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span>  localhost;<br><br>    <span class="hljs-section">location</span> /nacos &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://nacos-cluster;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而后在浏览器访问：<a href="http://localhost/nacos%E5%8D%B3%E5%8F%AF%E3%80%82">http://localhost/nacos即可。</a></p><p>代码中application.yml文件配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:80</span> <span class="hljs-comment"># Nacos地址</span><br></code></pre></td></tr></table></figure><h2 id="2-6-优化"><a href="#2-6-优化" class="headerlink" title="2.6.优化"></a>2.6.优化</h2><ul><li><p>实际部署时，需要给做反向代理的nginx服务器设置一个域名，这样后续如果有服务器迁移nacos的客户端也无需更改配置.</p></li><li><p>Nacos的各个节点应该部署到多个不同服务器，做好容灾和隔离</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>JAVA学习</category>
      
      <category>springCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nacos安装指南</title>
    <link href="/2023/03/28/Nacos%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/"/>
    <url>/2023/03/28/Nacos%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="Nacos安装指南"><a href="#Nacos安装指南" class="headerlink" title="Nacos安装指南"></a>Nacos安装指南</h1><h1 id="1-Windows安装"><a href="#1-Windows安装" class="headerlink" title="1.Windows安装"></a>1.Windows安装</h1><p>开发阶段采用单机安装即可。</p><h2 id="1-1-下载安装包"><a href="#1-1-下载安装包" class="headerlink" title="1.1.下载安装包"></a>1.1.下载安装包</h2><p>在Nacos的GitHub页面，提供有下载链接，可以下载编译好的Nacos服务端或者源代码：</p><p>GitHub主页：<a href="https://github.com/alibaba/nacos">https://github.com/alibaba/nacos</a></p><p>GitHub的Release下载页：<a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a></p><p>如图：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210402161102887.png" alt="image-20210402161102887"></p><p>本课程采用1.4.1.版本的Nacos，课前资料已经准备了安装包：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210402161130261.png" alt="image-20210402161130261"></p><p>windows版本使用<code>nacos-server-1.4.1.zip</code>包即可。</p><h2 id="1-2-解压"><a href="#1-2-解压" class="headerlink" title="1.2.解压"></a>1.2.解压</h2><p>将这个包解压到任意非中文目录下，如图：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210402161843337.png" alt="image-20210402161843337"></p><p>目录说明：</p><ul><li>bin：启动脚本</li><li>conf：配置文件</li></ul><h2 id="1-3-端口配置"><a href="#1-3-端口配置" class="headerlink" title="1.3.端口配置"></a>1.3.端口配置</h2><p>Nacos的默认端口是8848，如果你电脑上的其它进程占用了8848端口，请先尝试关闭该进程。</p><p><strong>如果无法关闭占用8848端口的进程</strong>，也可以进入nacos的conf目录，修改配置文件中的端口：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210402162008280.png" alt="image-20210402162008280"></p><p>修改其中的内容：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210402162251093.png" alt="image-20210402162251093"></p><h2 id="1-4-启动"><a href="#1-4-启动" class="headerlink" title="1.4.启动"></a>1.4.启动</h2><p>启动非常简单，进入bin目录，结构如下：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210402162350977.png" alt="image-20210402162350977"></p><p>然后执行命令即可：</p><ul><li><p>windows命令：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">startup.<span class="hljs-built_in">cmd</span> -m standalone<br></code></pre></td></tr></table></figure></li></ul><p>执行后的效果如图：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210402162526774.png" alt="image-20210402162526774"></p><h2 id="1-5-访问"><a href="#1-5-访问" class="headerlink" title="1.5.访问"></a>1.5.访问</h2><p>在浏览器输入地址：<a href="http://127.0.0.1:8848/nacos%E5%8D%B3%E5%8F%AF%EF%BC%9A">http://127.0.0.1:8848/nacos即可：</a></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210402162630427.png" alt="image-20210402162630427"></p><p>默认的账号和密码都是nacos，进入后：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210402162709515.png" alt="image-20210402162709515"></p><h1 id="2-Linux安装"><a href="#2-Linux安装" class="headerlink" title="2.Linux安装"></a>2.Linux安装</h1><p>Linux或者Mac安装方式与Windows类似。</p><h2 id="2-1-安装JDK"><a href="#2-1-安装JDK" class="headerlink" title="2.1.安装JDK"></a>2.1.安装JDK</h2><p>Nacos依赖于JDK运行，索引Linux上也需要安装JDK才行。</p><p>上传jdk安装包：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210402172334810.png" alt="image-20210402172334810"></p><p>上传到某个目录，例如：<code>/usr/local/</code></p><p>然后解压缩：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -xvf jdk-8u144-linux-x64.tar.gz<br></code></pre></td></tr></table></figure><p>然后重命名为java</p><p>配置环境变量：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">export</span> JAVA_HOME=/usr/local/java<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$JAVA_HOME</span>/bin<br></code></pre></td></tr></table></figure><p>设置环境变量：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure><h2 id="2-2-上传安装包"><a href="#2-2-上传安装包" class="headerlink" title="2.2.上传安装包"></a>2.2.上传安装包</h2><p>如图：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210402161102887.png" alt="image-20210402161102887"></p><p>也可以直接使用课前资料中的tar.gz：</p><p><img src="D:\workspace\java学习\17、微服务开发框架SpringCloud+RabbitMQ+Docker+Redis+搜索+分布式史上最全面的微服务全技术栈课程\day01-SpringCloud01\资料\assets\image-20210402161130261.png" alt="image-20210402161130261"></p><p>上传到Linux服务器的某个目录，例如<code>/usr/local/src</code>目录下：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210402163715580.png" alt="image-20210402163715580"></p><h2 id="2-3-解压"><a href="#2-3-解压" class="headerlink" title="2.3.解压"></a>2.3.解压</h2><p>命令解压缩安装包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -xvf nacos-server-1.4.1.tar.gz<br></code></pre></td></tr></table></figure><p>然后删除安装包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">rm</span> -rf nacos-server-1.4.1.tar.gz<br></code></pre></td></tr></table></figure><p>目录中最终样式：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210402163858429.png" alt="image-20210402163858429"></p><p>目录内部：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210402164414827.png" alt="image-20210402164414827"></p><h2 id="2-4-端口配置"><a href="#2-4-端口配置" class="headerlink" title="2.4.端口配置"></a>2.4.端口配置</h2><p>与windows中类似</p><h2 id="2-5-启动"><a href="#2-5-启动" class="headerlink" title="2.5.启动"></a>2.5.启动</h2><p>在nacos/bin目录中，输入命令启动Nacos：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sh startup.sh -m standalone<br></code></pre></td></tr></table></figure><h1 id="3-Nacos的依赖"><a href="#3-Nacos的依赖" class="headerlink" title="3.Nacos的依赖"></a>3.Nacos的依赖</h1><p>父工程：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- nacos客户端依赖包 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JAVA学习</category>
      
      <category>springCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springCloud</title>
    <link href="/2023/03/28/springCloud/"/>
    <url>/2023/03/28/springCloud/</url>
    
    <content type="html"><![CDATA[<p>来源：黑马资料</p><h1 id="SpringCloud01"><a href="#SpringCloud01" class="headerlink" title="SpringCloud01"></a>SpringCloud01</h1><h2 id="0-初识"><a href="#0-初识" class="headerlink" title="0 初识"></a>0 初识</h2><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230328182949123.png" alt="image-20230328182949123"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230328183103245.png" alt="image-20230328183103245"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230328183137912.png" alt="image-20230328183137912"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230328183228218.png" alt="image-20230328183228218"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230328183300614.png" alt="image-20230328183300614"></p><h2 id="1-认识微服务"><a href="#1-认识微服务" class="headerlink" title="1.认识微服务"></a>1.认识微服务</h2><p>随着互联网行业的发展，对服务的要求也越来越高，服务架构也从单体架构逐渐演变为现在流行的微服务架构。这些架构之间有怎样的差别呢？</p><h2 id="1-0-学习目标"><a href="#1-0-学习目标" class="headerlink" title="1.0.学习目标"></a>1.0.学习目标</h2><p>了解微服务架构的优缺点</p><h2 id="1-1-单体架构"><a href="#1-1-单体架构" class="headerlink" title="1.1.单体架构"></a>1.1.单体架构</h2><p><strong>单体架构</strong>：将业务的所有功能集中在一个项目中开发，打成一个包部署。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713202807818.png" alt="image-20210713202807818"></p><p>单体架构的优缺点如下：</p><p><strong>优点：</strong></p><ul><li>架构简单</li><li>部署成本低</li></ul><p><strong>缺点：</strong></p><ul><li>耦合度高（维护困难、升级困难）</li></ul><h2 id="1-2-分布式架构"><a href="#1-2-分布式架构" class="headerlink" title="1.2.分布式架构"></a>1.2.分布式架构</h2><p><strong>分布式架构</strong>：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713203124797.png" alt="image-20210713203124797"></p><p>分布式架构的优缺点：</p><p><strong>优点：</strong></p><ul><li>降低服务耦合</li><li>有利于服务升级和拓展</li></ul><p><strong>缺点：</strong></p><ul><li>服务调用关系错综复杂</li></ul><p>分布式架构虽然降低了服务耦合，但是服务拆分时也有很多问题需要思考：</p><ul><li>服务拆分的粒度如何界定？</li><li>服务之间如何调用？</li><li>服务的调用关系如何管理？</li></ul><p>人们需要制定一套行之有效的标准来约束分布式架构。</p><h2 id="1-3-微服务"><a href="#1-3-微服务" class="headerlink" title="1.3.微服务"></a>1.3.微服务</h2><p>微服务的架构特征：</p><ul><li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责</li><li>自治：团队独立、技术独立、数据独立，独立部署和交付</li><li>面向服务：服务提供统一标准的接口，与语言和技术无关</li><li>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</li></ul><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713203753373.png" alt="image-20210713203753373"></p><p>微服务的上述特性其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。</p><p>因此，可以认为<strong>微服务</strong>是一种经过良好架构设计的<strong>分布式架构方案</strong> 。</p><p>但方案该怎么落地？选用什么样的技术栈？全球的互联网公司都在积极尝试自己的微服务落地方案。</p><p>其中在Java领域最引人注目的就是SpringCloud提供的方案了。</p><h2 id="1-4-SpringCloud"><a href="#1-4-SpringCloud" class="headerlink" title="1.4.SpringCloud"></a>1.4.SpringCloud</h2><p>SpringCloud是目前国内使用最广泛的微服务框架。官网地址：<a href="https://spring.io/projects/spring-cloud%E3%80%82">https://spring.io/projects/spring-cloud。</a></p><p>SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验。</p><p>其中常见的组件包括：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713204155887.png" alt="image-20210713204155887"></p><p>另外，SpringCloud底层是依赖于SpringBoot的，并且有版本的兼容关系，如下：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713205003790.png" alt="image-20210713205003790"></p><p>我们课堂学习的版本是 Hoxton.SR10，因此对应的SpringBoot版本是2.3.x版本。</p><h2 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5.总结"></a>1.5.总结</h2><ul><li><p>单体架构：简单方便，高度耦合，扩展性差，适合小型项目。例如：学生管理系统</p></li><li><p>分布式架构：松耦合，扩展性好，但架构复杂，难度大。适合大型互联网项目，例如：京东、淘宝</p></li><li><p>微服务：一种良好的分布式架构方案</p><p>①优点：拆分粒度更小、服务更独立、耦合度更低</p><p>②缺点：架构非常复杂，运维、监控、部署难度提高</p></li><li><p>SpringCloud是微服务架构的一站式解决方案，集成了各种优秀微服务功能组件</p></li></ul><h1 id="2-服务拆分和远程调用"><a href="#2-服务拆分和远程调用" class="headerlink" title="2.服务拆分和远程调用"></a>2.服务拆分和远程调用</h1><p>任何分布式架构都离不开服务的拆分，微服务也是一样。</p><h2 id="2-1-服务拆分原则"><a href="#2-1-服务拆分原则" class="headerlink" title="2.1.服务拆分原则"></a>2.1.服务拆分原则</h2><p>这里我总结了微服务拆分时的几个原则：</p><ul><li>不同微服务，不要重复开发相同业务</li><li>微服务数据独立，不要访问其它微服务的数据库</li><li>微服务可以将自己的业务暴露为接口，供其它微服务调用</li></ul><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713210800950.png" alt="image-20210713210800950"></p><h2 id="2-2-服务拆分示例"><a href="#2-2-服务拆分示例" class="headerlink" title="2.2.服务拆分示例"></a>2.2.服务拆分示例</h2><p>以课前资料中的微服务cloud-demo为例，其结构如下：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713211009593.png" alt="image-20210713211009593"></p><p>cloud-demo：父工程，管理依赖</p><ul><li>order-service：订单微服务，负责订单相关业务</li><li>user-service：用户微服务，负责用户相关业务</li></ul><p>要求：</p><ul><li>订单微服务和用户微服务都必须有各自的数据库，相互独立</li><li>订单服务和用户服务都对外暴露Restful的接口</li><li>订单服务如果需要查询用户信息，只能调用用户服务的Restful接口，不能查询用户数据库</li></ul><h3 id="2-2-1-导入Sql语句"><a href="#2-2-1-导入Sql语句" class="headerlink" title="2.2.1.导入Sql语句"></a>2.2.1.导入Sql语句</h3><p>首先，将课前资料提供的<code>cloud-order.sql</code>和<code>cloud-user.sql</code>导入到mysql中：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713211417049.png" alt="image-20210713211417049"></p><p>cloud-user表中初始数据如下：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713211550169.png" alt="image-20210713211550169"></p><p>cloud-order表中初始数据如下：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713211657319.png" alt="image-20210713211657319"></p><p>cloud-order表中持有cloud-user表中的id字段。</p><h3 id="2-2-2-导入demo工程"><a href="#2-2-2-导入demo工程" class="headerlink" title="2.2.2.导入demo工程"></a>2.2.2.导入demo工程</h3><p>用IDEA导入课前资料提供的Demo：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713211814094.png" alt="image-20210713211814094"></p><p>项目结构如下：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713212656887.png" alt="image-20210713212656887"></p><p>导入后，会在IDEA右下角出现弹窗：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713212349272.png" alt="image-20210713212349272"></p><p>点击弹窗，然后按下图选择：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713212336185.png" alt="image-20210713212336185"></p><p>会出现这样的菜单：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713212513324.png" alt="image-20210713212513324"></p><p>配置下项目使用的JDK：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713220736408.png" alt="image-20210713220736408"></p><h2 id="2-3-实现远程调用案例"><a href="#2-3-实现远程调用案例" class="headerlink" title="2.3.实现远程调用案例"></a>2.3.实现远程调用案例</h2><p>在order-service服务中，有一个根据id查询订单的接口：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713212749575.png" alt="image-20210713212749575"></p><p>根据id查询订单，返回值是Order对象，如图：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713212901725.png" alt="image-20210713212901725"></p><p>其中的user为null</p><p>在user-service中有一个根据id查询用户的接口：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713213146089.png" alt="image-20210713213146089"></p><p>查询的结果如图：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713213213075.png" alt="image-20210713213213075"></p><h3 id="2-3-1-案例需求："><a href="#2-3-1-案例需求：" class="headerlink" title="2.3.1.案例需求："></a>2.3.1.案例需求：</h3><p>修改order-service中的根据id查询订单业务，要求在查询订单的同时，根据订单中包含的userId查询出用户信息，一起返回。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713213312278.png" alt="image-20210713213312278"></p><p>因此，我们需要在order-service中 向user-service发起一个http的请求，调用<a href="http://localhost:8081/user/%7BuserId%7D%E8%BF%99%E4%B8%AA%E6%8E%A5%E5%8F%A3%E3%80%82">http://localhost:8081/user/{userId}这个接口。</a></p><p>大概的步骤是这样的：</p><ul><li>注册一个RestTemplate的实例到Spring容器</li><li>修改order-service服务中的OrderService类中的queryOrderById方法，根据Order对象中的userId查询User</li><li>将查询的User填充到Order对象，一起返回</li></ul><h3 id="2-3-2-注册RestTemplate"><a href="#2-3-2-注册RestTemplate" class="headerlink" title="2.3.2.注册RestTemplate"></a>2.3.2.注册RestTemplate</h3><p>首先，我们在order-service服务中的OrderApplication启动类中，注册RestTemplate实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.order;<br><br><span class="hljs-keyword">import</span> org.mybatis.spring.annotation.MapperScan;<br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.web.client.RestTemplate;<br><br><span class="hljs-meta">@MapperScan(&quot;cn.itcast.order.mapper&quot;)</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(OrderApplication.class, args);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title function_">restTemplate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-3-实现远程调用"><a href="#2-3-3-实现远程调用" class="headerlink" title="2.3.3.实现远程调用"></a>2.3.3.实现远程调用</h3><p>修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713213959569.png" alt="image-20210713213959569"></p><h2 id="2-4-提供者与消费者"><a href="#2-4-提供者与消费者" class="headerlink" title="2.4.提供者与消费者"></a>2.4.提供者与消费者</h2><p>在服务调用关系中，会有两个不同的角色：</p><p><strong>服务提供者</strong>：一次业务中，被其它微服务调用的服务。（提供接口给其它微服务）</p><p><strong>服务消费者</strong>：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口）</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713214404481.png" alt="image-20210713214404481"></p><p>但是，服务提供者与服务消费者的角色并不是绝对的，而是相对于业务而言。</p><p>如果服务A调用了服务B，而服务B又调用了服务C，服务B的角色是什么？</p><ul><li>对于A调用B的业务而言：A是服务消费者，B是服务提供者</li><li>对于B调用C的业务而言：B是服务消费者，C是服务提供者</li></ul><p>因此，服务B既可以是服务提供者，也可以是服务消费者。</p><h1 id="3-Eureka注册中心"><a href="#3-Eureka注册中心" class="headerlink" title="3.Eureka注册中心"></a>3.Eureka注册中心</h1><p>假如我们的服务提供者user-service部署了多个实例，如图：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713214925388.png" alt="image-20210713214925388"></p><p>大家思考几个问题：</p><ul><li>order-service在发起远程调用的时候，该如何得知user-service实例的ip地址和端口？</li><li>有多个user-service实例地址，order-service调用时该如何选择？</li><li>order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</li></ul><h2 id="3-1-Eureka的结构和作用"><a href="#3-1-Eureka的结构和作用" class="headerlink" title="3.1.Eureka的结构和作用"></a>3.1.Eureka的结构和作用</h2><p>这些问题都需要利用SpringCloud中的注册中心来解决，其中最广为人知的注册中心就是Eureka，其结构如下：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713220104956.png" alt="image-20210713220104956"></p><p>回答之前的各个问题。</p><p>问题1：order-service如何得知user-service实例地址？</p><p>获取地址信息的流程如下：</p><ul><li>user-service服务实例启动后，将自己的信息注册到eureka-server（Eureka服务端）。这个叫服务注册</li><li>eureka-server保存服务名称到服务实例地址列表的映射关系</li><li>order-service根据服务名称，拉取实例地址列表。这个叫服务发现或服务拉取</li></ul><p>问题2：order-service如何从多个user-service实例中选择具体的实例？</p><ul><li>order-service从实例列表中利用负载均衡算法选中一个实例地址</li><li>向该实例地址发起远程调用</li></ul><p>问题3：order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</p><ul><li>user-service会每隔一段时间（默认30秒）向eureka-server发起请求，报告自己状态，称为心跳</li><li>当超过一定时间没有发送心跳时，eureka-server会认为微服务实例故障，将该实例从服务列表中剔除</li><li>order-service拉取服务时，就能将故障实例排除了</li></ul><blockquote><p>注意：一个微服务，既可以是服务提供者，又可以是服务消费者，因此eureka将服务注册、服务发现等功能统一封装到了eureka-client端</p></blockquote><p>因此，接下来我们动手实践的步骤包括：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713220509769.png" alt="image-20210713220509769"></p><h2 id="3-2-搭建eureka-server"><a href="#3-2-搭建eureka-server" class="headerlink" title="3.2.搭建eureka-server"></a>3.2.搭建eureka-server</h2><p>首先大家注册中心服务端：eureka-server，这必须是一个独立的微服务</p><h3 id="3-2-1-创建eureka-server服务"><a href="#3-2-1-创建eureka-server服务" class="headerlink" title="3.2.1.创建eureka-server服务"></a>3.2.1.创建eureka-server服务</h3><p>在cloud-demo父工程下，创建一个子模块：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713220605881.png" alt="image-20210713220605881"></p><p>填写模块信息：</p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713220857396.png" alt="image-20210713220857396" style="zoom:50%;" /><p>然后填写服务信息：</p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713221339022.png" alt="image-20210713221339022" style="zoom:50%;" /><h3 id="3-2-2-引入eureka依赖"><a href="#3-2-2-引入eureka依赖" class="headerlink" title="3.2.2.引入eureka依赖"></a>3.2.2.引入eureka依赖</h3><p>引入SpringCloud为eureka提供的starter依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-2-3-编写启动类"><a href="#3-2-3-编写启动类" class="headerlink" title="3.2.3.编写启动类"></a>3.2.3.编写启动类</h3><p>给eureka-server服务编写一个启动类，一定要添加一个@EnableEurekaServer注解，开启eureka的注册中心功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.eureka;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableEurekaServer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EurekaApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(EurekaApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-4-编写配置文件"><a href="#3-2-4-编写配置文件" class="headerlink" title="3.2.4.编写配置文件"></a>3.2.4.编写配置文件</h3><p>编写一个application.yml文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">10086</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-server</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span> <br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka</span><br></code></pre></td></tr></table></figure><h3 id="3-2-5-启动服务"><a href="#3-2-5-启动服务" class="headerlink" title="3.2.5.启动服务"></a>3.2.5.启动服务</h3><p>启动微服务，然后在浏览器访问：<a href="http://127.0.0.1:10086/">http://127.0.0.1:10086</a></p><p>看到下面结果应该是成功了：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713222157190.png" alt="image-20210713222157190"></p><h2 id="3-3-服务注册"><a href="#3-3-服务注册" class="headerlink" title="3.3.服务注册"></a>3.3.服务注册</h2><p>下面，我们将user-service注册到eureka-server中去。</p><h3 id="1）引入依赖"><a href="#1）引入依赖" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>在user-service的pom文件中，引入下面的eureka-client依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2）配置文件"><a href="#2）配置文件" class="headerlink" title="2）配置文件"></a>2）配置文件</h3><p>在user-service中，修改application.yml文件，添加服务名称、eureka地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">userservice</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka</span><br></code></pre></td></tr></table></figure><h3 id="3）启动多个user-service实例"><a href="#3）启动多个user-service实例" class="headerlink" title="3）启动多个user-service实例"></a>3）启动多个user-service实例</h3><p>为了演示一个服务有多个实例的场景，我们添加一个SpringBoot的启动配置，再启动一个user-service。</p><p>首先，复制原来的user-service启动配置：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713222656562.png" alt="image-20210713222656562"></p><p>然后，在弹出的窗口中，填写信息：</p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713222757702.png" alt="image-20210713222757702" style="zoom:50%;" /><p>现在，SpringBoot窗口会出现两个user-service启动配置：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713222841951.png" alt="image-20210713222841951"></p><p>不过，第一个是8081端口，第二个是8082端口。</p><p>启动两个user-service实例：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713223041491.png" alt="image-20210713223041491"></p><p>查看eureka-server管理页面：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713223150650.png" alt="image-20210713223150650"></p><h2 id="3-4-服务发现"><a href="#3-4-服务发现" class="headerlink" title="3.4.服务发现"></a>3.4.服务发现</h2><p>下面，我们将order-service的逻辑修改：向eureka-server拉取user-service的信息，实现服务发现。</p><h3 id="1）引入依赖-1"><a href="#1）引入依赖-1" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>之前说过，服务发现、服务注册统一都封装在eureka-client依赖，因此这一步与服务注册时一致。</p><p>在order-service的pom文件中，引入下面的eureka-client依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2）配置文件-1"><a href="#2）配置文件-1" class="headerlink" title="2）配置文件"></a>2）配置文件</h3><p>服务发现也需要知道eureka地址，因此第二步与服务注册一致，都是配置eureka信息：</p><p>在order-service中，修改application.yml文件，添加服务名称、eureka地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">orderservice</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka</span><br></code></pre></td></tr></table></figure><h3 id="3）服务拉取和负载均衡"><a href="#3）服务拉取和负载均衡" class="headerlink" title="3）服务拉取和负载均衡"></a>3）服务拉取和负载均衡</h3><p>最后，我们要去eureka-server中拉取user-service服务的实例列表，并且实现负载均衡。</p><p>不过这些动作不用我们去做，只需要添加一些注解即可。</p><p>在order-service的OrderApplication中，给RestTemplate这个Bean添加一个@LoadBalanced注解：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713224049419.png" alt="image-20210713224049419"></p><p>修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法。修改访问的url路径，用服务名代替ip、端口：</p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713224245731.png" alt="image-20210713224245731" style="zoom:50%;" /><p>spring会自动帮助我们从eureka-server端，根据userservice这个服务名称，获取实例列表，而后完成负载均衡。</p><h1 id="4-Ribbon负载均衡"><a href="#4-Ribbon负载均衡" class="headerlink" title="4.Ribbon负载均衡"></a>4.Ribbon负载均衡</h1><p>上一节中，我们添加了@LoadBalanced注解，即可实现负载均衡功能，这是什么原理呢？</p><h2 id="4-1-负载均衡原理"><a href="#4-1-负载均衡原理" class="headerlink" title="4.1.负载均衡原理"></a>4.1.负载均衡原理</h2><p>SpringCloud底层其实是利用了一个名为Ribbon的组件，来实现负载均衡功能的。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713224517686.png" alt="image-20210713224517686"></p><p>那么我们发出的请求明明是<a href="http://userservice/user/1%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8F%98%E6%88%90%E4%BA%86http://localhost:8081%E7%9A%84%E5%91%A2%EF%BC%9F">http://userservice/user/1，怎么变成了http://localhost:8081的呢？</a></p><h2 id="4-2-源码跟踪"><a href="#4-2-源码跟踪" class="headerlink" title="4.2.源码跟踪"></a>4.2.源码跟踪</h2><p>为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。</p><p>显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是<code>LoadBalancerInterceptor</code>，这个类会在对RestTemplate的请求进行拦截，然后从Eureka根据服务id获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务id。</p><p>我们进行源码跟踪：</p><h3 id="1）LoadBalancerIntercepor"><a href="#1）LoadBalancerIntercepor" class="headerlink" title="1）LoadBalancerIntercepor"></a>1）LoadBalancerIntercepor</h3><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/1525620483637.png" alt="1525620483637"></p><p>可以看到这里的intercept方法，拦截了用户的HttpRequest请求，然后做了几件事：</p><ul><li><code>request.getURI()</code>：获取请求uri，本例中就是 <a href="http://user-service/user/8">http://user-service/user/8</a></li><li><code>originalUri.getHost()</code>：获取uri路径的主机名，其实就是服务id，<code>user-service</code></li><li><code>this.loadBalancer.execute()</code>：处理服务id，和用户请求。</li></ul><p>这里的<code>this.loadBalancer</code>是<code>LoadBalancerClient</code>类型，我们继续跟入。</p><h3 id="2）LoadBalancerClient"><a href="#2）LoadBalancerClient" class="headerlink" title="2）LoadBalancerClient"></a>2）LoadBalancerClient</h3><p>继续跟入execute方法：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/1525620787090.png" alt="1525620787090"></p><p>代码是这样的：</p><ul><li>getLoadBalancer(serviceId)：根据服务id获取ILoadBalancer，而ILoadBalancer会拿着服务id去eureka中获取服务列表并保存起来。</li><li>getServer(loadBalancer)：利用内置的负载均衡算法，从服务列表中选择一个。本例中，可以看到获取了8082端口的服务</li></ul><p>放行后，再次访问并跟踪，发现获取的是8081：</p><p> <img src="D:/workspace/java学习/17、微服务开发框架SpringCloud+RabbitMQ+Docker+Redis+搜索+分布式史上最全面的微服务全技术栈课程/day01-SpringCloud01/讲义/assets/1525620835911.png" alt="1525620835911"></p><p>果然实现了负载均衡。</p><h3 id="3）负载均衡策略IRule"><a href="#3）负载均衡策略IRule" class="headerlink" title="3）负载均衡策略IRule"></a>3）负载均衡策略IRule</h3><p>在刚才的代码中，可以看到获取服务使通过一个<code>getServer</code>方法来做负载均衡:</p><p> <img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/1525620835911.png" alt="1525620835911"></p><p>我们继续跟入：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/1544361421671.png" alt="1544361421671"></p><p>继续跟踪源码chooseServer方法，发现这么一段代码：</p><p> <img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/1525622652849.png" alt="1525622652849"></p><p>我们看看这个rule是谁：</p><p> <img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/1525622699666.png" alt="1525622699666"></p><p>这里的rule默认值是一个<code>RoundRobinRule</code>，看类的介绍：</p><p> <img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/1525622754316.png" alt="1525622754316"></p><p>这不就是轮询的意思嘛。</p><p>到这里，整个负载均衡的流程我们就清楚了。</p><h3 id="4）总结"><a href="#4）总结" class="headerlink" title="4）总结"></a>4）总结</h3><p>SpringCloudRibbon的底层采用了一个拦截器，拦截了RestTemplate发出的请求，对地址做了修改。用一幅图来总结一下：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713224724673.png" alt="image-20210713224724673"></p><p>基本流程如下：</p><ul><li>拦截我们的RestTemplate请求<a href="http://userservice/user/1">http://userservice/user/1</a></li><li>RibbonLoadBalancerClient会从请求url中获取服务名称，也就是user-service</li><li>DynamicServerListLoadBalancer根据user-service到eureka拉取服务列表</li><li>eureka返回列表，localhost:8081、localhost:8082</li><li>IRule利用内置负载均衡规则，从列表中选择一个，例如localhost:8081</li><li>RibbonLoadBalancerClient修改请求地址，用localhost:8081替代userservice，得到<a href="http://localhost:8081/user/1%EF%BC%8C%E5%8F%91%E8%B5%B7%E7%9C%9F%E5%AE%9E%E8%AF%B7%E6%B1%82">http://localhost:8081/user/1，发起真实请求</a></li></ul><h2 id="4-3-负载均衡策略"><a href="#4-3-负载均衡策略" class="headerlink" title="4.3.负载均衡策略"></a>4.3.负载均衡策略</h2><h3 id="4-3-1-负载均衡策略"><a href="#4-3-1-负载均衡策略" class="headerlink" title="4.3.1.负载均衡策略"></a>4.3.1.负载均衡策略</h3><p>负载均衡的规则都定义在IRule接口中，而IRule有很多不同的实现类：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713225653000.png" alt="image-20210713225653000"></p><p>不同规则的含义如下：</p><table><thead><tr><th><strong>内置负载均衡规则类</strong></th><th><strong>规则描述</strong></th></tr></thead><tbody><tr><td>RoundRobinRule</td><td>简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td></tr><tr><td>AvailabilityFilteringRule</td><td>对以下两种服务器进行忽略：   （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。  （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的<clientName>.<clientConfigNameSpace>.ActiveConnectionsLimit属性进行配置。</td></tr><tr><td>WeightedResponseTimeRule</td><td>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td></tr><tr><td><strong>ZoneAvoidanceRule</strong></td><td>以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</td></tr><tr><td>BestAvailableRule</td><td>忽略那些短路的服务器，并选择并发数较低的服务器。</td></tr><tr><td>RandomRule</td><td>随机选择一个可用的服务器。</td></tr><tr><td>RetryRule</td><td>重试机制的选择逻辑</td></tr></tbody></table><p>默认的实现就是ZoneAvoidanceRule，是一种轮询方案</p><h3 id="4-3-2-自定义负载均衡策略"><a href="#4-3-2-自定义负载均衡策略" class="headerlink" title="4.3.2.自定义负载均衡策略"></a>4.3.2.自定义负载均衡策略</h3><p>通过定义IRule实现可以修改负载均衡规则，有两种方式：</p><ol><li>代码方式：在order-service中的OrderApplication类中，定义一个新的IRule：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> IRule <span class="hljs-title function_">randomRule</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomRule</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">userservice:</span> <span class="hljs-comment"># 给某个微服务配置负载均衡规则，这里是userservice服务</span><br>  <span class="hljs-attr">ribbon:</span><br>    <span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.netflix.loadbalancer.RandomRule</span> <span class="hljs-comment"># 负载均衡规则 </span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>，一般用默认的负载均衡规则，不做修改。</p></blockquote><h2 id="4-4-饥饿加载"><a href="#4-4-饥饿加载" class="headerlink" title="4.4.饥饿加载"></a>4.4.饥饿加载</h2><p>Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。</p><p>而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">ribbon:</span><br>  <span class="hljs-attr">eager-load:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">clients:</span> <span class="hljs-string">userservice</span><br></code></pre></td></tr></table></figure><h1 id="5-Nacos注册中心"><a href="#5-Nacos注册中心" class="headerlink" title="5.Nacos注册中心"></a>5.Nacos注册中心</h1><p>国内公司一般都推崇阿里巴巴的技术，比如注册中心，SpringCloudAlibaba也推出了一个名为Nacos的注册中心。</p><h2 id="5-1-认识和安装Nacos"><a href="#5-1-认识和安装Nacos" class="headerlink" title="5.1.认识和安装Nacos"></a>5.1.认识和安装Nacos</h2><p><a href="https://nacos.io/">Nacos</a>是阿里巴巴的产品，现在是<a href="https://spring.io/projects/spring-cloud">SpringCloud</a>中的一个组件。相比<a href="https://github.com/Netflix/eureka">Eureka</a>功能更加丰富，在国内受欢迎程度较高。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713230444308.png" alt="image-20210713230444308"></p><p>安装方式可以参考课前资料《Nacos安装指南.md》</p><h2 id="5-2-服务注册到nacos"><a href="#5-2-服务注册到nacos" class="headerlink" title="5.2.服务注册到nacos"></a>5.2.服务注册到nacos</h2><p>Nacos是SpringCloudAlibaba的组件，而SpringCloudAlibaba也遵循SpringCloud中定义的服务注册、服务发现规范。因此使用Nacos和使用Eureka对于微服务来说，并没有太大区别。</p><p>主要差异在于：</p><ul><li>依赖不同</li><li>服务地址不同</li></ul><h3 id="1）引入依赖-2"><a href="#1）引入依赖-2" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>在cloud-demo父工程的pom文件中的<code>&lt;dependencyManagement&gt;</code>中引入SpringCloudAlibaba的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.6.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后在user-service和order-service中的pom文件中引入nacos-discovery依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：不要忘了注释掉eureka的依赖。</p></blockquote><h3 id="2）配置nacos地址"><a href="#2）配置nacos地址" class="headerlink" title="2）配置nacos地址"></a>2）配置nacos地址</h3><p>在user-service和order-service的application.yml中添加nacos地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：不要忘了注释掉eureka的地址</p></blockquote><h3 id="3）重启"><a href="#3）重启" class="headerlink" title="3）重启"></a>3）重启</h3><p>重启微服务后，登录nacos管理页面，可以看到微服务信息：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713231439607.png" alt="image-20210713231439607"></p><h2 id="5-3-服务分级存储模型"><a href="#5-3-服务分级存储模型" class="headerlink" title="5.3.服务分级存储模型"></a>5.3.服务分级存储模型</h2><p>一个<strong>服务</strong>可以有多个<strong>实例</strong>，例如我们的user-service，可以有:</p><ul><li>127.0.0.1:8081</li><li>127.0.0.1:8082</li><li>127.0.0.1:8083</li></ul><p>假如这些实例分布于全国各地的不同机房，例如：</p><ul><li>127.0.0.1:8081，在上海机房</li><li>127.0.0.1:8082，在上海机房</li><li>127.0.0.1:8083，在杭州机房</li></ul><p>Nacos就将同一机房内的实例 划分为一个<strong>集群</strong>。</p><p>也就是说，user-service是服务，一个服务可以包含多个集群，如杭州、上海，每个集群下可以有多个实例，形成分级模型，如图：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713232522531.png" alt="image-20210713232522531"></p><p>微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群。例如：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713232658928.png" alt="image-20210713232658928"></p><p>杭州机房内的order-service应该优先访问同机房的user-service。</p><h3 id="5-3-1-给user-service配置集群"><a href="#5-3-1-给user-service配置集群" class="headerlink" title="5.3.1.给user-service配置集群"></a>5.3.1.给user-service配置集群</h3><p>修改user-service的application.yml文件，添加集群配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">HZ</span> <span class="hljs-comment"># 集群名称</span><br></code></pre></td></tr></table></figure><p>重启两个user-service实例后，我们可以在nacos控制台看到下面结果：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713232916215.png" alt="image-20210713232916215"></p><p>我们再次复制一个user-service启动配置，添加属性：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">-Dserver.port=8083 -Dspring.cloud.nacos.discovery.cluster-name=SH<br></code></pre></td></tr></table></figure><p>配置如图所示：</p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713233528982.png" alt="image-20210713233528982" style="zoom:67%;" /><p>启动UserApplication3后再次查看nacos控制台：</p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713233727923.png" alt="image-20210713233727923" style="zoom:67%;" /><h3 id="5-3-2-同集群优先的负载均衡"><a href="#5-3-2-同集群优先的负载均衡" class="headerlink" title="5.3.2.同集群优先的负载均衡"></a>5.3.2.同集群优先的负载均衡</h3><p>默认的<code>ZoneAvoidanceRule</code>并不能实现根据同集群优先来实现负载均衡。</p><p>因此Nacos中提供了一个<code>NacosRule</code>的实现，可以优先从同集群中挑选实例。</p><p>1）给order-service配置集群信息</p><p>修改order-service的application.yml文件，添加集群配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">spring:<br>  cloud:<br>    nacos:<br>      server-addr: localhost:8848<br>      discovery:<br>        cluster-name: HZ <span class="hljs-comment"># 集群名称</span><br></code></pre></td></tr></table></figure><p>2）修改负载均衡规则</p><p>修改order-service的application.yml文件，修改负载均衡规则：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">userservice:</span><br>  <span class="hljs-attr">ribbon:</span><br>    <span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class="hljs-comment"># 负载均衡规则 </span><br></code></pre></td></tr></table></figure><h2 id="5-4-权重配置"><a href="#5-4-权重配置" class="headerlink" title="5.4.权重配置"></a>5.4.权重配置</h2><p>实际部署中会出现这样的场景：</p><p>服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。</p><p>但默认情况下NacosRule是同集群内随机挑选，不会考虑机器的性能问题。</p><p>因此，Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高。</p><p>在nacos控制台，找到user-service的实例列表，点击编辑，即可修改权重：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713235133225.png" alt="image-20210713235133225"></p><p>在弹出的编辑窗口，修改权重：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713235235219.png" alt="image-20210713235235219"></p><blockquote><p><strong>注意</strong>：如果权重修改为0，则该实例永远不会被访问</p></blockquote><h2 id="5-5-环境隔离"><a href="#5-5-环境隔离" class="headerlink" title="5.5.环境隔离"></a>5.5.环境隔离</h2><p>Nacos提供了namespace来实现环境隔离功能。</p><ul><li>nacos中可以有多个namespace</li><li>namespace下可以有group、service等</li><li>不同namespace之间相互隔离，例如不同namespace的服务互相不可见</li></ul><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714000101516.png" alt="image-20210714000101516" style="zoom:67%;" /><h3 id="5-5-1-创建namespace"><a href="#5-5-1-创建namespace" class="headerlink" title="5.5.1.创建namespace"></a>5.5.1.创建namespace</h3><p>默认情况下，所有service、data、group都在同一个namespace，名为public：</p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714000414781.png" alt="image-20210714000414781" style="zoom:50%;" /><p>我们可以点击页面新增按钮，添加一个namespace：</p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714000440143.png" alt="image-20210714000440143" style="zoom: 67%;" /><p>然后，填写表单：</p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714000505928.png" alt="image-20210714000505928" style="zoom:67%;" /><p>就能在页面看到一个新的namespace：</p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714000522913.png" alt="image-20210714000522913" style="zoom:67%;" /><h3 id="5-5-2-给微服务配置namespace"><a href="#5-5-2-给微服务配置namespace" class="headerlink" title="5.5.2.给微服务配置namespace"></a>5.5.2.给微服务配置namespace</h3><p>给微服务配置namespace只能通过修改配置来实现。</p><p>例如，修改order-service的application.yml文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">HZ</span><br>        <span class="hljs-attr">namespace:</span> <span class="hljs-string">492a7d5d-237b-46a1-a99a-fa8e98e4b0f9</span> <span class="hljs-comment"># 命名空间，填ID</span><br></code></pre></td></tr></table></figure><p>重启order-service后，访问控制台，可以看到下面的结果：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714000830703.png" alt="image-20210714000830703"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714000837140.png" alt="image-20210714000837140"></p><p>此时访问order-service，因为namespace不同，会导致找不到userservice，控制台会报错：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714000941256.png" alt="image-20210714000941256"></p><h2 id="5-6-Nacos与Eureka的区别"><a href="#5-6-Nacos与Eureka的区别" class="headerlink" title="5.6.Nacos与Eureka的区别"></a>5.6.Nacos与Eureka的区别</h2><p>Nacos的服务实例分为两种l类型：</p><ul><li><p>临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。</p></li><li><p>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</p></li></ul><p>配置一个服务实例为永久实例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">ephemeral:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 设置为非临时实例</span><br></code></pre></td></tr></table></figure><p>Nacos和Eureka整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714001728017.png" alt="image-20210714001728017"></p><ul><li><p>Nacos与eureka的共同点</p><ul><li>都支持服务注册和服务拉取</li><li>都支持服务提供者心跳方式做健康检测</li></ul></li><li><p>Nacos与Eureka的区别</p><ul><li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li><li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li><li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li><li>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</li></ul></li></ul><h1 id="SpringCloud实用篇02"><a href="#SpringCloud实用篇02" class="headerlink" title="SpringCloud实用篇02"></a>SpringCloud实用篇02</h1><h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><h1 id="1-Nacos配置管理"><a href="#1-Nacos配置管理" class="headerlink" title="1.Nacos配置管理"></a>1.Nacos配置管理</h1><p>Nacos除了可以做注册中心，同样可以做配置管理来使用。</p><h2 id="1-1-统一配置管理"><a href="#1-1-统一配置管理" class="headerlink" title="1.1.统一配置管理"></a>1.1.统一配置管理</h2><p>当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。我们需要一种统一配置管理方案，可以集中管理所有实例的配置。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714164426792.png" alt="image-20210714164426792"></p><p>Nacos一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新。</p><h3 id="1-1-1-在nacos中添加配置文件"><a href="#1-1-1-在nacos中添加配置文件" class="headerlink" title="1.1.1.在nacos中添加配置文件"></a>1.1.1.在nacos中添加配置文件</h3><p>如何在nacos中管理配置呢？</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714164742924.png" alt="image-20210714164742924"></p><p>然后在弹出的表单中，填写配置信息：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714164856664.png" alt="image-20210714164856664"></p><blockquote><p>注意：项目的核心配置，需要热更新的配置才有放到nacos管理的必要。基本不会变更的一些配置还是保存在微服务本地比较好。</p></blockquote><h3 id="1-1-2-从微服务拉取配置"><a href="#1-1-2-从微服务拉取配置" class="headerlink" title="1.1.2.从微服务拉取配置"></a>1.1.2.从微服务拉取配置</h3><p>微服务要拉取nacos中管理的配置，并且与本地的application.yml配置合并，才能完成项目启动。</p><p>但如果尚未读取application.yml，又如何得知nacos地址呢？</p><p>因此spring引入了一种新的配置文件：bootstrap.yaml文件，会在application.yml之前被读取，流程如下：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/L0iFYNF.png" alt="img"></p><p>1）引入nacos-config依赖</p><p>首先，在user-service服务中，引入nacos-config的客户端依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--nacos配置管理依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2）添加bootstrap.yaml</p><p>然后，在user-service中添加一个bootstrap.yaml文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">userservice</span> <span class="hljs-comment"># 服务名称</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span> <span class="hljs-comment">#开发环境，这里是dev </span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment"># Nacos地址</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment"># 文件后缀名</span><br></code></pre></td></tr></table></figure><p>这里会根据spring.cloud.nacos.server-addr获取nacos地址，再根据</p><p><code>$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</code>作为文件id，来读取配置。</p><p>本例中，就是去读取<code>userservice-dev.yaml</code>：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714170845901.png" alt="image-20210714170845901"></p><p>3）读取nacos配置</p><p>在user-service中的UserController中添加业务逻辑，读取pattern.dateformat配置：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714170337448.png" alt="image-20210714170337448"></p><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.user.web;<br><br><span class="hljs-keyword">import</span> cn.itcast.user.pojo.User;<br><span class="hljs-keyword">import</span> cn.itcast.user.service.UserService;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.*;<br><br><span class="hljs-keyword">import</span> java.time.LocalDateTime;<br><span class="hljs-keyword">import</span> java.time.format.DateTimeFormatter;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;pattern.dateformat&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String dateformat;<br>    <br>    <span class="hljs-meta">@GetMapping(&quot;now&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">now</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));<br>    &#125;<br>    <span class="hljs-comment">// ...略</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在页面访问，可以看到效果：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714170449612.png" alt="image-20210714170449612"></p><h2 id="1-2-配置热更新"><a href="#1-2-配置热更新" class="headerlink" title="1.2.配置热更新"></a>1.2.配置热更新</h2><p>我们最终的目的，是修改nacos中的配置后，微服务中无需重启即可让配置生效，也就是<strong>配置热更新</strong>。</p><p>要实现配置热更新，可以使用两种方式：</p><h3 id="1-2-1-方式一"><a href="#1-2-1-方式一" class="headerlink" title="1.2.1.方式一"></a>1.2.1.方式一</h3><p>在@Value注入的变量所在类上添加注解@RefreshScope：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714171036335.png" alt="image-20210714171036335"></p><h3 id="1-2-2-方式二"><a href="#1-2-2-方式二" class="headerlink" title="1.2.2.方式二"></a>1.2.2.方式二</h3><p>使用@ConfigurationProperties注解代替@Value注解。</p><p>在user-service服务中，添加一个类，读取patterrn.dateformat属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.user.config;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;pattern&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PatternProperties</span> &#123;<br>    <span class="hljs-keyword">private</span> String dateformat;<br>&#125;<br></code></pre></td></tr></table></figure><p>在UserController中使用这个类代替@Value：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714171316124.png" alt="image-20210714171316124"></p><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.user.web;<br><br><span class="hljs-keyword">import</span> cn.itcast.user.config.PatternProperties;<br><span class="hljs-keyword">import</span> cn.itcast.user.pojo.User;<br><span class="hljs-keyword">import</span> cn.itcast.user.service.UserService;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-keyword">import</span> java.time.LocalDateTime;<br><span class="hljs-keyword">import</span> java.time.format.DateTimeFormatter;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> PatternProperties patternProperties;<br><br>    <span class="hljs-meta">@GetMapping(&quot;now&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">now</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(patternProperties.getDateformat()));<br>    &#125;<br><br>    <span class="hljs-comment">// 略</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-3-配置共享"><a href="#1-3-配置共享" class="headerlink" title="1.3.配置共享"></a>1.3.配置共享</h2><p>其实微服务启动时，会去nacos读取多个配置文件，例如：</p><ul><li><p><code>[spring.application.name]-[spring.profiles.active].yaml</code>，例如：userservice-dev.yaml</p></li><li><p><code>[spring.application.name].yaml</code>，例如：userservice.yaml</p></li></ul><p>而<code>[spring.application.name].yaml</code>不包含环境，因此可以被多个环境共享。</p><p>下面我们通过案例来测试配置共享</p><h3 id="1）添加一个环境共享配置"><a href="#1）添加一个环境共享配置" class="headerlink" title="1）添加一个环境共享配置"></a>1）添加一个环境共享配置</h3><p>我们在nacos中添加一个userservice.yaml文件：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714173233650.png" alt="image-20210714173233650"></p><h3 id="2）在user-service中读取共享配置"><a href="#2）在user-service中读取共享配置" class="headerlink" title="2）在user-service中读取共享配置"></a>2）在user-service中读取共享配置</h3><p>在user-service服务中，修改PatternProperties类，读取新添加的属性：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714173324231.png" alt="image-20210714173324231"></p><p>在user-service服务中，修改UserController，添加一个方法：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714173721309.png" alt="image-20210714173721309"></p><h3 id="3）运行两个UserApplication，使用不同的profile"><a href="#3）运行两个UserApplication，使用不同的profile" class="headerlink" title="3）运行两个UserApplication，使用不同的profile"></a>3）运行两个UserApplication，使用不同的profile</h3><p>修改UserApplication2这个启动项，改变其profile值：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714173538538.png" alt="image-20210714173538538"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714173519963.png" alt="image-20210714173519963"></p><p>这样，UserApplication(8081)使用的profile是dev，UserApplication2(8082)使用的profile是test。</p><p>启动UserApplication和UserApplication2</p><p>访问<a href="http://localhost:8081/user/prop%EF%BC%8C%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:8081/user/prop，结果：</a></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714174313344.png" alt="image-20210714174313344"></p><p>访问<a href="http://localhost:8082/user/prop%EF%BC%8C%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:8082/user/prop，结果：</a></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714174424818.png" alt="image-20210714174424818"></p><p>可以看出来，不管是dev，还是test环境，都读取到了envSharedValue这个属性的值。</p><h3 id="4）配置共享的优先级"><a href="#4）配置共享的优先级" class="headerlink" title="4）配置共享的优先级"></a>4）配置共享的优先级</h3><p>当nacos、服务本地同时出现相同属性时，优先级有高低之分：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714174623557.png" alt="image-20210714174623557"></p><h2 id="1-4-搭建Nacos集群"><a href="#1-4-搭建Nacos集群" class="headerlink" title="1.4.搭建Nacos集群"></a>1.4.搭建Nacos集群</h2><p>Nacos生产环境下一定要部署为集群状态，部署方式参考课前资料中的文档：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714174728042.png" alt="image-20210714174728042"></p><h1 id="2-Feign远程调用"><a href="#2-Feign远程调用" class="headerlink" title="2.Feign远程调用"></a>2.Feign远程调用</h1><p>先来看我们以前利用RestTemplate发起远程调用的代码：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714174814204.png" alt="image-20210714174814204"></p><p>存在下面的问题：</p><p>•代码可读性差，编程体验不统一</p><p>•参数复杂URL难以维护</p><p>Feign是一个声明式的http客户端，官方地址：<a href="https://github.com/OpenFeign/feign">https://github.com/OpenFeign/feign</a></p><p>其作用就是帮助我们优雅的实现http请求的发送，解决上面提到的问题。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714174918088.png" alt="image-20210714174918088"></p><h2 id="2-1-Feign替代RestTemplate"><a href="#2-1-Feign替代RestTemplate" class="headerlink" title="2.1.Feign替代RestTemplate"></a>2.1.Feign替代RestTemplate</h2><p>Fegin的使用步骤如下：</p><h3 id="1）引入依赖-3"><a href="#1）引入依赖-3" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>我们在order-service服务的pom文件中引入feign的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2）添加注解"><a href="#2）添加注解" class="headerlink" title="2）添加注解"></a>2）添加注解</h3><p>在order-service的启动类添加注解开启Feign的功能：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714175102524.png" alt="image-20210714175102524"></p><h3 id="3）编写Feign的客户端"><a href="#3）编写Feign的客户端" class="headerlink" title="3）编写Feign的客户端"></a>3）编写Feign的客户端</h3><p>在order-service中新建一个接口，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.order.client;<br><br><span class="hljs-keyword">import</span> cn.itcast.order.pojo.User;<br><span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.FeignClient;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;<br><br><span class="hljs-meta">@FeignClient(&quot;userservice&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserClient</span> &#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span><br>    User <span class="hljs-title function_">findById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个客户端主要是基于SpringMVC的注解来声明远程调用的信息，比如：</p><ul><li>服务名称：userservice</li><li>请求方式：GET</li><li>请求路径：/user/{id}</li><li>请求参数：Long id</li><li>返回值类型：User</li></ul><p>这样，Feign就可以帮助我们发送http请求，无需自己使用RestTemplate来发送了。</p><h3 id="4）测试"><a href="#4）测试" class="headerlink" title="4）测试"></a>4）测试</h3><p>修改order-service中的OrderService类中的queryOrderById方法，使用Feign客户端代替RestTemplate：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714175415087.png" alt="image-20210714175415087"></p><p>是不是看起来优雅多了。</p><h3 id="5）总结"><a href="#5）总结" class="headerlink" title="5）总结"></a>5）总结</h3><p>使用Feign的步骤：</p><p>① 引入依赖</p><p>② 添加@EnableFeignClients注解</p><p>③ 编写FeignClient接口</p><p>④ 使用FeignClient中定义的方法代替RestTemplate</p><h2 id="2-2-自定义配置"><a href="#2-2-自定义配置" class="headerlink" title="2.2.自定义配置"></a>2.2.自定义配置</h2><p>Feign可以支持很多的自定义配置，如下表所示：</p><table><thead><tr><th>类型</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td><strong>feign.Logger.Level</strong></td><td>修改日志级别</td><td>包含四种不同的级别：NONE、BASIC、HEADERS、FULL</td></tr><tr><td>feign.codec.Decoder</td><td>响应结果的解析器</td><td>http远程调用的结果做解析，例如解析json字符串为java对象</td></tr><tr><td>feign.codec.Encoder</td><td>请求参数编码</td><td>将请求参数编码，便于通过http请求发送</td></tr><tr><td>feign. Contract</td><td>支持的注解格式</td><td>默认是SpringMVC的注解</td></tr><tr><td>feign. Retryer</td><td>失败重试机制</td><td>请求失败的重试机制，默认是没有，不过会使用Ribbon的重试</td></tr></tbody></table><p>一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的@Bean覆盖默认Bean即可。</p><p>下面以日志为例来演示如何自定义配置。</p><h3 id="2-2-1-配置文件方式"><a href="#2-2-1-配置文件方式" class="headerlink" title="2.2.1.配置文件方式"></a>2.2.1.配置文件方式</h3><p>基于配置文件修改feign的日志级别可以针对单个服务：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span>  <br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span> <br>      <span class="hljs-attr">userservice:</span> <span class="hljs-comment"># 针对某个微服务的配置</span><br>        <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">FULL</span> <span class="hljs-comment">#  日志级别 </span><br></code></pre></td></tr></table></figure><p>也可以针对所有服务：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span>  <br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span> <br>      <span class="hljs-attr">default:</span> <span class="hljs-comment"># 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置</span><br>        <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">FULL</span> <span class="hljs-comment">#  日志级别 </span><br></code></pre></td></tr></table></figure><p>而日志的级别分为四种：</p><ul><li>NONE：不记录任何日志信息，这是默认值。</li><li>BASIC：仅记录请求的方法，URL以及响应状态码和执行时间</li><li>HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</li><li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。</li></ul><h3 id="2-2-2-Java代码方式"><a href="#2-2-2-Java代码方式" class="headerlink" title="2.2.2.Java代码方式"></a>2.2.2.Java代码方式</h3><p>也可以基于Java代码来修改日志级别，先声明一个类，然后声明一个Logger.Level的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultFeignConfiguration</span>  &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Logger.Level <span class="hljs-title function_">feignLogLevel</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> Logger.Level.BASIC; <span class="hljs-comment">// 日志级别为BASIC</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要<strong>全局生效</strong>，将其放到启动类的@EnableFeignClients这个注解中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration .class)</span> <br></code></pre></td></tr></table></figure><p>如果是<strong>局部生效</strong>，则把它放到对应的@FeignClient这个注解中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(value = &quot;userservice&quot;, configuration = DefaultFeignConfiguration .class)</span> <br></code></pre></td></tr></table></figure><h2 id="2-3-Feign使用优化"><a href="#2-3-Feign使用优化" class="headerlink" title="2.3.Feign使用优化"></a>2.3.Feign使用优化</h2><p>Feign底层发起http请求，依赖于其它的框架。其底层客户端实现包括：</p><p>•URLConnection：默认实现，不支持连接池</p><p>•Apache HttpClient ：支持连接池</p><p>•OKHttp：支持连接池</p><p>因此提高Feign的性能主要手段就是使用<strong>连接池</strong>代替默认的URLConnection。</p><p>这里我们用Apache的HttpClient来演示。</p><p>1）引入依赖</p><p>在order-service的pom文件中引入Apache的HttpClient依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--httpClient的依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.github.openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>feign-httpclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2）配置连接池</p><p>在order-service的application.yml中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">default:</span> <span class="hljs-comment"># default全局的配置</span><br>        <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">BASIC</span> <span class="hljs-comment"># 日志级别，BASIC就是基本的请求和响应信息</span><br>  <span class="hljs-attr">httpclient:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启feign对HttpClient的支持</span><br>    <span class="hljs-attr">max-connections:</span> <span class="hljs-number">200</span> <span class="hljs-comment"># 最大的连接数</span><br>    <span class="hljs-attr">max-connections-per-route:</span> <span class="hljs-number">50</span> <span class="hljs-comment"># 每个路径的最大连接数</span><br></code></pre></td></tr></table></figure><p>接下来，在FeignClientFactoryBean中的loadBalance方法中打断点：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714185925910.png" alt="image-20210714185925910"></p><p>Debug方式启动order-service服务，可以看到这里的client，底层就是Apache HttpClient：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714190041542.png" alt="image-20210714190041542"></p><p>总结，Feign的优化：</p><p>1.日志级别尽量用basic</p><p>2.使用HttpClient或OKHttp代替URLConnection</p><p>①  引入feign-httpClient依赖</p><p>②  配置文件开启httpClient功能，设置连接池参数</p><h2 id="2-4-最佳实践"><a href="#2-4-最佳实践" class="headerlink" title="2.4.最佳实践"></a>2.4.最佳实践</h2><p>所谓最近实践，就是使用过程中总结的经验，最好的一种使用方式。</p><p>自习观察可以发现，Feign的客户端与服务提供者的controller代码非常相似：</p><p>feign客户端：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714190542730.png" alt="image-20210714190542730"></p><p>UserController：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714190528450.png" alt="image-20210714190528450"></p><p>有没有一种办法简化这种重复的代码编写呢？</p><h3 id="2-4-1-继承方式"><a href="#2-4-1-继承方式" class="headerlink" title="2.4.1.继承方式"></a>2.4.1.继承方式</h3><p>一样的代码可以通过继承来共享：</p><p>1）定义一个API接口，利用定义方法，并基于SpringMVC注解做声明。</p><p>2）Feign客户端和Controller都集成改接口</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714190640857.png" alt="image-20210714190640857"></p><p>优点：</p><ul><li>简单</li><li>实现了代码共享</li></ul><p>缺点：</p><ul><li><p>服务提供方、服务消费方紧耦合</p></li><li><p>参数列表中的注解映射并不会继承，因此Controller中必须再次声明方法、参数列表、注解</p></li></ul><h3 id="2-4-2-抽取方式"><a href="#2-4-2-抽取方式" class="headerlink" title="2.4.2.抽取方式"></a>2.4.2.抽取方式</h3><p>将Feign的Client抽取为独立模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用。</p><p>例如，将UserClient、User、Feign的默认配置都抽取到一个feign-api包中，所有微服务引用该依赖包，即可直接使用。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714214041796.png" alt="image-20210714214041796"></p><h3 id="2-4-3-实现基于抽取的最佳实践"><a href="#2-4-3-实现基于抽取的最佳实践" class="headerlink" title="2.4.3.实现基于抽取的最佳实践"></a>2.4.3.实现基于抽取的最佳实践</h3><h4 id="1）抽取"><a href="#1）抽取" class="headerlink" title="1）抽取"></a>1）抽取</h4><p>首先创建一个module，命名为feign-api：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714204557771.png" alt="image-20210714204557771"></p><p>项目结构：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714204656214.png" alt="image-20210714204656214"></p><p>在feign-api中然后引入feign的starter依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后，order-service中编写的UserClient、User、DefaultFeignConfiguration都复制到feign-api项目中</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714205221970.png" alt="image-20210714205221970"></p><h4 id="2）在order-service中使用feign-api"><a href="#2）在order-service中使用feign-api" class="headerlink" title="2）在order-service中使用feign-api"></a>2）在order-service中使用feign-api</h4><p>首先，删除order-service中的UserClient、User、DefaultFeignConfiguration等类或接口。</p><p>在order-service的pom文件中中引入feign-api的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.itcast.demo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>feign-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>修改order-service中的所有与上述三个组件有关的导包部分，改成导入feign-api中的包</p><h4 id="3）重启测试"><a href="#3）重启测试" class="headerlink" title="3）重启测试"></a>3）重启测试</h4><p>重启后，发现服务报错了：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714205623048.png" alt="image-20210714205623048"></p><p>这是因为UserClient现在在cn.itcast.feign.clients包下，</p><p>而order-service的@EnableFeignClients注解是在cn.itcast.order包下，不在同一个包，无法扫描到UserClient。</p><h4 id="4）解决扫描包问题"><a href="#4）解决扫描包问题" class="headerlink" title="4）解决扫描包问题"></a>4）解决扫描包问题</h4><p>方式一：</p><p>指定Feign应该扫描的包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableFeignClients(basePackages = &quot;cn.itcast.feign.clients&quot;)</span><br></code></pre></td></tr></table></figure><p>方式二：</p><p>指定需要加载的Client接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableFeignClients(clients = &#123;UserClient.class&#125;)</span><br></code></pre></td></tr></table></figure><h1 id="3-Gateway服务网关"><a href="#3-Gateway服务网关" class="headerlink" title="3.Gateway服务网关"></a>3.Gateway服务网关</h1><p>Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。</p><h2 id="3-1-为什么需要网关"><a href="#3-1-为什么需要网关" class="headerlink" title="3.1.为什么需要网关"></a>3.1.为什么需要网关</h2><p>Gateway网关是我们服务的守门神，所有微服务的统一入口。</p><p>网关的<strong>核心功能特性</strong>：</p><ul><li>请求路由</li><li>权限控制</li><li>限流</li></ul><p>架构图：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714210131152.png" alt="image-20210714210131152"></p><p><strong>权限控制</strong>：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</p><p><strong>路由和负载均衡</strong>：一切请求都必须先经过gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。</p><p><strong>限流</strong>：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</p><p>在SpringCloud中网关的实现包括两种：</p><ul><li>gateway</li><li>zuul</li></ul><p>Zuul是基于Servlet的实现，属于阻塞式编程。而SpringCloudGateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</p><h2 id="3-2-gateway快速入门"><a href="#3-2-gateway快速入门" class="headerlink" title="3.2.gateway快速入门"></a>3.2.gateway快速入门</h2><p>下面，我们就演示下网关的基本路由功能。基本步骤如下：</p><ol><li>创建SpringBoot工程gateway，引入网关依赖</li><li>编写启动类</li><li>编写基础配置和路由规则</li><li>启动网关服务进行测试</li></ol><h3 id="1）创建gateway服务，引入依赖"><a href="#1）创建gateway服务，引入依赖" class="headerlink" title="1）创建gateway服务，引入依赖"></a>1）创建gateway服务，引入依赖</h3><p>创建服务：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714210919458.png" alt="image-20210714210919458"></p><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--网关--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--nacos服务发现依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2）编写启动类"><a href="#2）编写启动类" class="headerlink" title="2）编写启动类"></a>2）编写启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.gateway;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GatewayApplication</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>SpringApplication.run(GatewayApplication.class, args);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3）编写基础配置和路由规则"><a href="#3）编写基础配置和路由规则" class="headerlink" title="3）编写基础配置和路由规则"></a>3）编写基础配置和路由规则</h3><p>创建application.yml文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">10010</span> <span class="hljs-comment"># 网关端口</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">gateway</span> <span class="hljs-comment"># 服务名称</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment"># nacos地址</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span> <span class="hljs-comment"># 网关路由配置</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user-service</span> <span class="hljs-comment"># 路由id，自定义，只要唯一即可</span><br>          <span class="hljs-comment"># uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://userservice</span> <span class="hljs-comment"># 路由的目标地址 lb就是负载均衡，后面跟服务名称</span><br>          <span class="hljs-attr">predicates:</span> <span class="hljs-comment"># 路由断言，也就是判断请求是否符合路由规则的条件</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**</span> <span class="hljs-comment"># 这个是按照路径匹配，只要以/user/开头就符合要求</span><br></code></pre></td></tr></table></figure><p>我们将符合<code>Path</code> 规则的一切请求，都代理到 <code>uri</code>参数指定的地址。</p><p>本例中，我们将 <code>/user/**</code>开头的请求，代理到<code>lb://userservice</code>，lb是负载均衡，根据服务名拉取服务列表，实现负载均衡。</p><h3 id="4）重启测试"><a href="#4）重启测试" class="headerlink" title="4）重启测试"></a>4）重启测试</h3><p>重启网关，访问<a href="http://localhost:10010/user/1%E6%97%B6%EF%BC%8C%E7%AC%A6%E5%90%88%60/user/**%60%E8%A7%84%E5%88%99%EF%BC%8C%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%88%B0uri%EF%BC%9Ahttp://userservice/user/1%EF%BC%8C%E5%BE%97%E5%88%B0%E4%BA%86%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:10010/user/1时，符合`/user/**`规则，请求转发到uri：http://userservice/user/1，得到了结果：</a></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714211908341.png" alt="image-20210714211908341"></p><h3 id="5）网关路由的流程图"><a href="#5）网关路由的流程图" class="headerlink" title="5）网关路由的流程图"></a>5）网关路由的流程图</h3><p>整个访问的流程如下：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714211742956.png" alt="image-20210714211742956"></p><p>总结：</p><p>网关搭建步骤：</p><ol><li><p>创建项目，引入nacos服务发现和gateway依赖</p></li><li><p>配置application.yml，包括服务基本信息、nacos地址、路由</p></li></ol><p>路由配置包括：</p><ol><li><p>路由id：路由的唯一标示</p></li><li><p>路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡</p></li><li><p>路由断言（predicates）：判断路由的规则，</p></li><li><p>路由过滤器（filters）：对请求或响应做处理</p></li></ol><p>接下来，就重点来学习路由断言和路由过滤器的详细知识</p><h2 id="3-3-断言工厂"><a href="#3-3-断言工厂" class="headerlink" title="3.3.断言工厂"></a>3.3.断言工厂</h2><p>我们在配置文件中写的断言规则只是字符串，这些字符串会被Predicate Factory读取并处理，转变为路由判断的条件</p><p>例如Path=/user/**是按照路径匹配，这个规则是由</p><p><code>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory</code>类来</p><p>处理的，像这样的断言工厂在SpringCloudGateway还有十几个:</p><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>After</td><td>是某个时间点后的请求</td><td>-  After=2037-01-20T17:42:47.789-07:00[America/Denver]</td></tr><tr><td>Before</td><td>是某个时间点之前的请求</td><td>-  Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</td></tr><tr><td>Between</td><td>是某两个时间点之前的请求</td><td>-  Between=2037-01-20T17:42:47.789-07:00[America/Denver],  2037-01-21T17:42:47.789-07:00[America/Denver]</td></tr><tr><td>Cookie</td><td>请求必须包含某些cookie</td><td>- Cookie=chocolate, ch.p</td></tr><tr><td>Header</td><td>请求必须包含某些header</td><td>- Header=X-Request-Id, \d+</td></tr><tr><td>Host</td><td>请求必须是访问某个host（域名）</td><td>-  Host=<strong>.somehost.org,</strong>.anotherhost.org</td></tr><tr><td>Method</td><td>请求方式必须是指定方式</td><td>- Method=GET,POST</td></tr><tr><td>Path</td><td>请求路径必须符合指定规则</td><td>- Path=/red/{segment},/blue/**</td></tr><tr><td>Query</td><td>请求参数必须包含指定参数</td><td>- Query=name, Jack或者-  Query=name</td></tr><tr><td>RemoteAddr</td><td>请求者的ip必须是指定范围</td><td>- RemoteAddr=192.168.1.1/24</td></tr><tr><td>Weight</td><td>权重处理</td><td></td></tr></tbody></table><p>我们只需要掌握Path这种路由工程就可以了。</p><h2 id="3-4-过滤器工厂"><a href="#3-4-过滤器工厂" class="headerlink" title="3.4.过滤器工厂"></a>3.4.过滤器工厂</h2><p>GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714212312871.png" alt="image-20210714212312871"></p><h3 id="3-4-1-路由过滤器的种类"><a href="#3-4-1-路由过滤器的种类" class="headerlink" title="3.4.1.路由过滤器的种类"></a>3.4.1.路由过滤器的种类</h3><p>Spring提供了31种不同的路由过滤器工厂。例如：</p><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>AddRequestHeader</td><td>给当前请求添加一个请求头</td></tr><tr><td>RemoveRequestHeader</td><td>移除请求中的一个请求头</td></tr><tr><td>AddResponseHeader</td><td>给响应结果中添加一个响应头</td></tr><tr><td>RemoveResponseHeader</td><td>从响应结果中移除有一个响应头</td></tr><tr><td>RequestRateLimiter</td><td>限制请求的流量</td></tr></tbody></table><h3 id="3-4-2-请求头过滤器"><a href="#3-4-2-请求头过滤器" class="headerlink" title="3.4.2.请求头过滤器"></a>3.4.2.请求头过滤器</h3><p>下面我们以AddRequestHeader 为例来讲解。</p><blockquote><p><strong>需求</strong>：给所有进入userservice的请求添加一个请求头：Truth=itcast is freaking awesome!</p></blockquote><p>只需要修改gateway服务的application.yml文件，添加路由过滤即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user-service</span> <br>        <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://userservice</span> <br>        <span class="hljs-attr">predicates:</span> <br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**</span> <br>        <span class="hljs-attr">filters:</span> <span class="hljs-comment"># 过滤器</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=Truth,</span> <span class="hljs-string">Itcast</span> <span class="hljs-string">is</span> <span class="hljs-string">freaking</span> <span class="hljs-string">awesome!</span> <span class="hljs-comment"># 添加请求头</span><br></code></pre></td></tr></table></figure><p>当前过滤器写在userservice路由下，因此仅仅对访问userservice的请求有效。</p><h3 id="3-4-3-默认过滤器"><a href="#3-4-3-默认过滤器" class="headerlink" title="3.4.3.默认过滤器"></a>3.4.3.默认过滤器</h3><p>如果要对所有的路由都生效，则可以将过滤器工厂写到default下。格式如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user-service</span> <br>        <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://userservice</span> <br>        <span class="hljs-attr">predicates:</span> <br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**</span><br>      <span class="hljs-attr">default-filters:</span> <span class="hljs-comment"># 默认过滤项</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=Truth,</span> <span class="hljs-string">Itcast</span> <span class="hljs-string">is</span> <span class="hljs-string">freaking</span> <span class="hljs-string">awesome!</span> <br></code></pre></td></tr></table></figure><h3 id="3-4-4-总结"><a href="#3-4-4-总结" class="headerlink" title="3.4.4.总结"></a>3.4.4.总结</h3><p>过滤器的作用是什么？</p><p>① 对路由的请求或响应做加工处理，比如添加请求头</p><p>② 配置在路由下的过滤器只对当前路由的请求生效</p><p>defaultFilters的作用是什么？</p><p>① 对所有路由都生效的过滤器</p><h2 id="3-5-全局过滤器"><a href="#3-5-全局过滤器" class="headerlink" title="3.5.全局过滤器"></a>3.5.全局过滤器</h2><p>上一节学习的过滤器，网关提供了31种，但每一种过滤器的作用都是固定的。如果我们希望拦截请求，做自己的业务逻辑则没办法实现。</p><h3 id="3-5-1-全局过滤器作用"><a href="#3-5-1-全局过滤器作用" class="headerlink" title="3.5.1.全局过滤器作用"></a>3.5.1.全局过滤器作用</h3><p>全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样。区别在于GatewayFilter通过配置定义，处理逻辑是固定的；而GlobalFilter的逻辑需要自己写代码实现。</p><p>定义方式是实现GlobalFilter接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">GlobalFilter</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  处理当前请求，有必要的话通过&#123;<span class="hljs-doctag">@link</span> GatewayFilterChain&#125;将请求交给下一个过滤器处理</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> exchange 请求上下文，里面可以获取Request、Response等信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> chain 用来把请求委托给下一个过滤器 </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> Mono&lt;Void&gt;&#125; 返回标示当前过滤器业务结束</span><br><span class="hljs-comment">     */</span><br>    Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在filter中编写自定义逻辑，可以实现下列功能：</p><ul><li>登录状态判断</li><li>权限校验</li><li>请求限流等</li></ul><h3 id="3-5-2-自定义全局过滤器"><a href="#3-5-2-自定义全局过滤器" class="headerlink" title="3.5.2.自定义全局过滤器"></a>3.5.2.自定义全局过滤器</h3><p>需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：</p><ul><li><p>参数中是否有authorization，</p></li><li><p>authorization参数值是否为admin</p></li></ul><p>如果同时满足则放行，否则拦截</p><p>实现：</p><p>在gateway中定义一个过滤器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.gateway.filters;<br><br><span class="hljs-keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;<br><span class="hljs-keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;<br><span class="hljs-keyword">import</span> org.springframework.core.annotation.Order;<br><span class="hljs-keyword">import</span> org.springframework.http.HttpStatus;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.springframework.web.server.ServerWebExchange;<br><span class="hljs-keyword">import</span> reactor.core.publisher.Mono;<br><br><span class="hljs-meta">@Order(-1)</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthorizeFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GlobalFilter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;<br>        <span class="hljs-comment">// 1.获取请求参数</span><br>        MultiValueMap&lt;String, String&gt; params = exchange.getRequest().getQueryParams();<br>        <span class="hljs-comment">// 2.获取authorization参数</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">auth</span> <span class="hljs-operator">=</span> params.getFirst(<span class="hljs-string">&quot;authorization&quot;</span>);<br>        <span class="hljs-comment">// 3.校验</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;admin&quot;</span>.equals(auth)) &#123;<br>            <span class="hljs-comment">// 放行</span><br>            <span class="hljs-keyword">return</span> chain.filter(exchange);<br>        &#125;<br>        <span class="hljs-comment">// 4.拦截</span><br>        <span class="hljs-comment">// 4.1.禁止访问，设置状态码</span><br>        exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);<br>        <span class="hljs-comment">// 4.2.结束处理</span><br>        <span class="hljs-keyword">return</span> exchange.getResponse().setComplete();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-3-过滤器执行顺序"><a href="#3-5-3-过滤器执行顺序" class="headerlink" title="3.5.3.过滤器执行顺序"></a>3.5.3.过滤器执行顺序</h3><p>请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter</p><p>请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714214228409.png" alt="image-20210714214228409"></p><p>排序的规则是什么呢？</p><ul><li>每一个过滤器都必须指定一个int类型的order值，<strong>order值越小，优先级越高，执行顺序越靠前</strong>。</li><li>GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定</li><li>路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增。</li><li>当过滤器的order值一样时，会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行。</li></ul><p>详细内容，可以查看源码：</p><p><code>org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator#getFilters()</code>方法是先加载defaultFilters，然后再加载某个route的filters，然后合并。</p><p><code>org.springframework.cloud.gateway.handler.FilteringWebHandler#handle()</code>方法会加载全局过滤器，与前面的过滤器合并后根据order排序，组织过滤器链</p><h2 id="3-6-跨域问题"><a href="#3-6-跨域问题" class="headerlink" title="3.6.跨域问题"></a>3.6.跨域问题</h2><h3 id="3-6-1-什么是跨域问题"><a href="#3-6-1-什么是跨域问题" class="headerlink" title="3.6.1.什么是跨域问题"></a>3.6.1.什么是跨域问题</h3><p>跨域：域名不一致就是跨域，主要包括：</p><ul><li><p>域名不同： <a href="http://www.taobao.com/">www.taobao.com</a> 和 <a href="http://www.taobao.org/">www.taobao.org</a> 和 <a href="http://www.jd.com/">www.jd.com</a> 和 miaosha.jd.com</p></li><li><p>域名相同，端口不同：localhost:8080和localhost8081</p></li></ul><p>跨域问题：浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题</p><p>解决方案：CORS，这个以前应该学习过，这里不再赘述了。不知道的小伙伴可以查看<a href="https://www.ruanyifeng.com/blog/2016/04/cors.html">https://www.ruanyifeng.com/blog/2016/04/cors.html</a></p><h3 id="3-6-2-模拟跨域问题"><a href="#3-6-2-模拟跨域问题" class="headerlink" title="3.6.2.模拟跨域问题"></a>3.6.2.模拟跨域问题</h3><p>找到课前资料的页面文件：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714215713563.png" alt="image-20210714215713563"></p><p>放入tomcat或者nginx这样的web服务器中，启动并访问。</p><p>可以在浏览器控制台看到下面的错误：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714215832675.png" alt="image-20210714215832675"></p><p>从localhost:8090访问localhost:10010，端口不同，显然是跨域的请求。</p><h3 id="3-6-3-解决跨域问题"><a href="#3-6-3-解决跨域问题" class="headerlink" title="3.6.3.解决跨域问题"></a>3.6.3.解决跨域问题</h3><p>在gateway服务的application.yml文件中，添加下面的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-comment"># 。。。</span><br>      <span class="hljs-attr">globalcors:</span> <span class="hljs-comment"># 全局的跨域处理</span><br>        <span class="hljs-attr">add-to-simple-url-handler-mapping:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 解决options请求被拦截问题</span><br>        <span class="hljs-attr">corsConfigurations:</span><br>          <span class="hljs-string">&#x27;[/**]&#x27;</span><span class="hljs-string">:</span><br>            <span class="hljs-attr">allowedOrigins:</span> <span class="hljs-comment"># 允许哪些网站的跨域请求 </span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;http://localhost:8090&quot;</span><br>            <span class="hljs-attr">allowedMethods:</span> <span class="hljs-comment"># 允许的跨域ajax的请求方式</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;GET&quot;</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;POST&quot;</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;DELETE&quot;</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;PUT&quot;</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;OPTIONS&quot;</span><br>            <span class="hljs-attr">allowedHeaders:</span> <span class="hljs-string">&quot;*&quot;</span> <span class="hljs-comment"># 允许在请求中携带的头信息</span><br>            <span class="hljs-attr">allowCredentials:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否允许携带cookie</span><br>            <span class="hljs-attr">maxAge:</span> <span class="hljs-number">360000</span> <span class="hljs-comment"># 这次跨域检测的有效期</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JAVA学习</category>
      
      <category>springCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>瑞吉外卖</title>
    <link href="/2023/03/22/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96/"/>
    <url>/2023/03/22/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96/</url>
    
    <content type="html"><![CDATA[<h1 id="瑞吉外卖"><a href="#瑞吉外卖" class="headerlink" title="瑞吉外卖"></a>瑞吉外卖</h1><h2 id="瑞吉外卖项目介绍"><a href="#瑞吉外卖项目介绍" class="headerlink" title="瑞吉外卖项目介绍"></a>瑞吉外卖项目介绍</h2><h3 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h3><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230627144309445.png" alt="image-20230627144309445"></p><p>本项目（瑞吉外卖）是专门为餐饮企业（餐厅、饭店）定制的一款软件产品，包括 系统管理后台 和 移动端应用 两部分。其中系统管理后台主要提供给餐饮企业内部员工使用，可以对餐厅的分类、菜品、套餐、订单、员工等进行管理维护。移动端应用主要提供给消费者使用，可以在线浏览菜品、添加购物车、下单等。</p><p>本项目共分为3期进行开发：</p><table><thead><tr><th>阶段</th><th>功能实现</th></tr></thead><tbody><tr><td>第一期</td><td>主要实现基本需求，其中移动端应用通过H5实现，用户可以通过手机浏览器访问</td></tr><tr><td>第二期</td><td>主要针对移动端应用进行改进，使用微信小程序实现，用户使用起来更加方便</td></tr><tr><td>第三期</td><td>主要针对系统进行优化升级，提高系统的访问性能</td></tr></tbody></table><p><strong>1). 管理端</strong></p><p>餐饮企业内部员工使用。 主要功能有: </p><table><thead><tr><th>模块</th><th>描述</th></tr></thead><tbody><tr><td>登录/退出</td><td>内部员工必须登录后,才可以访问系统管理后台</td></tr><tr><td>员工管理</td><td>管理员可以在系统后台对员工信息进行管理，包含查询、新增、编辑、禁用等功能</td></tr><tr><td>分类管理</td><td>主要对当前餐厅经营的 菜品分类 或 套餐分类 进行管理维护， 包含查询、新增、修改、删除等功能</td></tr><tr><td>菜品管理</td><td>主要维护各个分类下的菜品信息，包含查询、新增、修改、删除、启售、停售等功能</td></tr><tr><td>套餐管理</td><td>主要维护当前餐厅中的套餐信息，包含查询、新增、修改、删除、启售、停售等功能</td></tr><tr><td>订单明细</td><td>主要维护用户在移动端下的订单信息，包含查询、取消、派送、完成，以及订单报表下载等功能</td></tr></tbody></table><p><strong>2). 用户端</strong></p><p>移动端应用主要提供给消费者使用。主要功能有:</p><table><thead><tr><th>模块</th><th>描述</th></tr></thead><tbody><tr><td>登录/退出</td><td>在移动端, 用户也需要登录后使用APP进行点餐</td></tr><tr><td>点餐-菜单</td><td>在点餐界面需要展示出菜品分类/套餐分类, 并根据当前选择的分类加载其中的菜品信息, 供用户查询选择</td></tr><tr><td>点餐-购物车</td><td>用户选中的菜品就会加入用户的购物车, 主要包含 查询购物车、加入购物车、删除购物车、清空购物车等功能</td></tr><tr><td>订单支付</td><td>用户选完菜品/套餐后, 可以对购物车菜品进行结算支付, 这时就需要进行订单的支付</td></tr><tr><td>个人信息</td><td>在个人中心页面中会展示当前用户的基本信息, 用户可以管理收货地址, 也可以查询历史订单数据</td></tr></tbody></table><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p>关于本项目的技术选型, 我们将会从 用户层、网关层、应用层、数据层 这几个方面进行介绍，而对于我们服务端开发工程师来说，在项目开发过程中，我们主要关注应用层及数据层技术的应用。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210726005437857.png"> </p><p><strong>1). 用户层</strong></p><p>本项目中在构建系统管理后台的前端页面，我们会用到H5、Vue.js、ElementUI等技术。而在构建移动端应用时，我们会使用到微信小程序。</p><p><strong>2). 网关层</strong></p><p>Nginx是一个服务器，主要用来作为Http服务器，部署静态资源，访问性能高。在Nginx中还有两个比较重要的作用： 反向代理和负载均衡， 在进行项目部署时，要实现Tomcat的负载均衡，就可以通过Nginx来实现。</p><p><strong>3). 应用层</strong></p><p>SpringBoot： 快速构建Spring项目, 采用 “约定优于配置” 的思想, 简化Spring项目的配置开发。</p><p>Spring: 统一管理项目中的各种资源(bean), 在web开发的各层中都会用到。</p><p>SpringMVC：SpringMVC是spring框架的一个模块，springmvc和spring无需通过中间整合层进行整合，可以无缝集成。</p><p>SpringSession: 主要解决在集群环境下的Session共享问题。</p><p>lombok：能以简单的注解形式来简化java代码，提高开发人员的开发效率。例如开发中经常需要写的javabean，都需要花时间去添加相应的getter/setter，也许还要去写构造器、equals等方法。</p><p>Swagger： 可以自动的帮助开发人员生成接口文档，并对接口进行测试。</p><p><strong>4). 数据层</strong></p><p>MySQL： 关系型数据库, 本项目的核心业务数据都会采用MySQL进行存储。</p><p>MybatisPlus： 本项目持久层将会使用MybatisPlus来简化开发, 基本的单表增删改查直接调用框架提供的方法即可。</p><p>Redis： 基于key-value格式存储的内存数据库, 访问速度快, 经常使用它做缓存(降低数据库访问压力, 提供访问效率), 在后面的性能优化中会使用。</p><p><strong>5). 工具</strong></p><p>git: 版本控制工具, 在团队协作中, 使用该工具对项目中的代码进行管理。</p><p>maven: 项目构建工具。</p><p>junit：单元测试工具，开发人员功能实现完毕后，需要通过junit对功能进行单元测试。</p><h3 id="功能架构"><a href="#功能架构" class="headerlink" title="功能架构"></a>功能架构</h3><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230627145006690.png" alt="image-20230627145006690"></p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p>在瑞吉外卖这个项目中，存在以下三种用户，这三种用户对应三个角色： 后台系统管理员、后台系统普通员工、C端(移动端)用户。</p><table><thead><tr><th>角色</th><th>权限操作</th></tr></thead><tbody><tr><td>后台系统管理员</td><td>登录后台管理系统，拥有后台系统中的所有操作权限</td></tr><tr><td>后台系统普通员工</td><td>登录后台管理系统，对菜品、套餐、订单等进行管理 (不包含员工管理)</td></tr><tr><td>C端用户</td><td>登录移动端应用，可以浏览菜品、添加购物车、设置地址、在线下单等</td></tr></tbody></table><h2 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h2><h3 id="数据库环境搭建"><a href="#数据库环境搭建" class="headerlink" title="数据库环境搭建"></a>数据库环境搭建</h3><h4 id="数据库表介绍"><a href="#数据库表介绍" class="headerlink" title="数据库表介绍"></a>数据库表介绍</h4><p>数据库表导入之后, 接下来介绍一下本项目中所涉及到的表结构: </p><table><thead><tr><th><strong>序号</strong></th><th><strong>表名</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>1</td><td>employee</td><td>员工表</td></tr><tr><td>2</td><td>category</td><td>菜品和套餐分类表</td></tr><tr><td>3</td><td>dish</td><td>菜品表</td></tr><tr><td>4</td><td>setmeal</td><td>套餐表</td></tr><tr><td>5</td><td>setmeal_dish</td><td>套餐菜品关系表</td></tr><tr><td>6</td><td>dish_flavor</td><td>菜品口味关系表</td></tr><tr><td>7</td><td>user</td><td>用户表（C端）</td></tr><tr><td>8</td><td>address_book</td><td>地址簿表</td></tr><tr><td>9</td><td>shopping_cart</td><td>购物车表</td></tr><tr><td>10</td><td>orders</td><td>订单表</td></tr><tr><td>11</td><td>order_detail</td><td>订单明细表</td></tr></tbody></table><p>上述的表结构, 我们目前先简单的结合页面原型了解一下, 大概有那些表, 每张表结构中存储什么样的数据, 有一个印象。对于具体的表结构, 以及表结构中的字段, 在讲解具体的功能开发时, 我们再详细介绍。</p><h3 id="Maven项目搭建"><a href="#Maven项目搭建" class="headerlink" title="Maven项目搭建"></a>Maven项目搭建</h3><h4 id="创建maven项目"><a href="#创建maven项目" class="headerlink" title="创建maven项目"></a>创建maven项目</h4><p><strong>1). 在idea中创建maven project, 项目名称 reggie_take_out</strong> </p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230627150957753.png" alt="image-20230627150957753"></p><p><strong>2). 检查项目编码</strong></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230627151007080.png" alt="image-20230627151007080"></p><p><strong>3). 检查maven配置</strong></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230627151016301.png" alt="image-20230627151016301"></p><p><strong>4). 检查JDK版本</strong></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230627151025837.png" alt="image-20230627151025837"></p><p>JDK的版本选择1.8;</p><h4 id="搭建基础环境"><a href="#搭建基础环境" class="headerlink" title="搭建基础环境"></a>搭建基础环境</h4><p>1).在pom.xml中导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.20<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.76<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-lang<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-lang<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.23<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2).在工程的resources目录下创建application.yml文件,并引入配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>  <span class="hljs-comment">#应用名称 , 可选</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">reggie_take_out</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">druid:</span><br>      <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>      <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/reggie?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;allowPublicKeyRetrieval=true</span><br>      <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-comment">#在映射实体或者属性时，将数据库中表名和字段名中的下划线去掉，按照驼峰命名法映射 address_book ---&gt; AddressBook</span><br>    <span class="hljs-attr">map-underscore-to-camel-case:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment">#日志输出</span><br>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br>  <span class="hljs-attr">global-config:</span><br>    <span class="hljs-attr">db-config:</span><br>      <span class="hljs-attr">id-type:</span> <span class="hljs-string">ASSIGN_ID</span><br></code></pre></td></tr></table></figure><p>3).创建包 com.itheima.reggie , 并编写启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReggieApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(ReggieApplication.class,args);<br>        log.info(<span class="hljs-string">&quot;项目启动成功...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>@Slf4j : </p><p>​    是lombok中提供的注解, 用来通过slf4j记录日志。</p></blockquote><p>当搭建完上述的基础环境之后, 就可以通过引导类, 启动该项目。</p><h4 id="前端静态资源导入"><a href="#前端静态资源导入" class="headerlink" title="前端静态资源导入"></a>前端静态资源导入</h4><p>我们作为服务端开发工程师， 我们课程学习的重心应该放在后端的业务代码上， 前端的页面我们只需要导入课程资料中的前端资源， 前端页面的代码我们只需要能看懂即可。</p><p><strong>1). 导入静态资源</strong></p><p>前端资源存放位置为  资料/前端资源 : <img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210726225948411.png"> </p><p>将上述两个目录中的静态资源文件, 导入到项目的resources目录下: </p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230627155348928.png" alt="image-20230627155348928"></p><p>创建配置类WebMvcConfig，设置静态资源映射**</p><p>用于在Springboot项目中, 默认静态资源的存放目录为 : “classpath:/resources/“, “classpath:/static/“, “classpath:/public/“ ; 而在我们的项目中静态资源存放在 backend, front 目录中, 那么这个时候要想访问到静态资源, 就需要设置静态资源映射。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebMvcConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebMvcConfigurationSupport</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置静态资源映射</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> registry</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;开始进行静态资源映射...&quot;</span>);<br>        registry.addResourceHandler(<span class="hljs-string">&quot;/backend/**&quot;</span>).addResourceLocations(<span class="hljs-string">&quot;classpath:/backend/&quot;</span>);<br>        registry.addResourceHandler(<span class="hljs-string">&quot;/front/**&quot;</span>).addResourceLocations(<span class="hljs-string">&quot;classpath:/front/&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3). 访问测试</strong></p><p><a href="http://localhost:8080/backend/index.html">http://localhost:8080/backend/index.html</a></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230627155410492.png" alt="image-20230627155410492"></p><h2 id="后台系统登录功能"><a href="#后台系统登录功能" class="headerlink" title="后台系统登录功能"></a>后台系统登录功能</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p><strong>1). 页面原型展示</strong></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230627155545693.png" alt="image-20230627155545693"></p><p><strong>2). 登录页面成品展示</strong></p><p>登录页面存放目录 /resources/backend/page/login/login.html</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230627155607094.png" alt="image-20230627155607094"></p><p><strong>3). 查看登录请求</strong></p><p>通过浏览器调试工具（F12），可以发现，点击登录按钮时，页面会发送请求（请求地址为<a href="http://localhost:8080/employee/login%EF%BC%89%E5%B9%B6%E6%8F%90%E4%BA%A4%E5%8F%82%E6%95%B0">http://localhost:8080/employee/login）并提交参数</a> username和password, 请求参数为json格式数据 {“username”:”admin”,”password”:”123456”}。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230627155713473.png" alt="image-20230627155713473"></p><p>此时报404，是因为我们的后台系统还没有响应此请求的处理器，所以我们需要创建相关类来处理登录请求 ；</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230627155723835.png" alt="image-20230627155723835"></p><p><strong>4). 数据模型(employee表)</strong></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230627155734654.png" alt="image-20230627155734654"></p><p><strong>5). 前端页面分析</strong></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230627155743591.png" alt="image-20230627155743591"></p><p>当点击 “登录” 按钮, 会触发Vue中定义的 handleLogin 方法:</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230627155801494.png" alt="image-20230627155801494"></p><p>在上述的前端代码中, 大家可以看到, 发送登录的异步请求之后, 获取到响应结果, 在响应结果中至少包含三个属性: code、data、msg 。</p><p>由前端代码，我们也可以看到，在用户登录成功之后，服务端会返回用户信息，而前端是将这些用户信息，存储在客户端的 localStorage 中了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;userInfo&#x27;</span>,<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(res.<span class="hljs-property">data</span>))<br></code></pre></td></tr></table></figure><h3 id="代码开发"><a href="#代码开发" class="headerlink" title="代码开发"></a>代码开发</h3><h4 id="基础准备工作"><a href="#基础准备工作" class="headerlink" title="基础准备工作"></a>基础准备工作</h4><p>在进行登录功能的代码实现之前， 首先在我们的工程下创建包结构： </p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230627155958960.png" alt="image-20230627155958960"></p><p><strong>1). 创建实体类Employee</strong></p><p>该实体类主要用于和员工表 employee 进行映射。 该实体类， 也可以直接从资料( 资料/实体类 )中拷贝工程中。</p><p>所属包: com.itheima.reggie.entity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.annotation.FieldFill;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.annotation.TableField;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-keyword">import</span> java.time.LocalDateTime;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br><br>    <span class="hljs-keyword">private</span> Long id;<br><br>    <span class="hljs-keyword">private</span> String username;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">private</span> String password;<br><br>    <span class="hljs-keyword">private</span> String phone;<br><br>    <span class="hljs-keyword">private</span> String sex;<br><br>    <span class="hljs-keyword">private</span> String idNumber; <span class="hljs-comment">//驼峰命名法 ---&gt; 映射的字段名为 id_number</span><br><br>    <span class="hljs-keyword">private</span> Integer status;<br><br>    <span class="hljs-keyword">private</span> LocalDateTime createTime;<br><br>    <span class="hljs-keyword">private</span> LocalDateTime updateTime;<br><br>    <span class="hljs-meta">@TableField(fill = FieldFill.INSERT)</span><br>    <span class="hljs-keyword">private</span> Long createUser;<br><br>    <span class="hljs-meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span><br>    <span class="hljs-keyword">private</span> Long updateUser;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2). 定义Mapper接口</strong></p><p>在MybatisPlus中, 自定义的Mapper接口, 需要继承自 BaseMapper。</p><p>所属包: com.itheima.reggie.mapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmployeeMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;Employee&gt;&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3).Service接口</strong></p><p>本项目的Service接口, 在定义时需要继承自MybatisPlus提供的Service层接口 IService, 这样就可以直接调用 父接口的方法直接执行业务操作, 简化业务层代码实现。</p><p>所属包: com.itheima.reggie.service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmployeeService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IService</span>&lt;Employee&gt; &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4). Service实现类</strong></p><p>所属包: com.itheima.reggie.service.impl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;<br><span class="hljs-keyword">import</span> com.itheima.reggie.entity.Employee;<br><span class="hljs-keyword">import</span> com.itheima.reggie.mapper.EmployeeMapper;<br><span class="hljs-keyword">import</span> com.itheima.reggie.service.EmployeeService;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmployeeServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;EmployeeMapper,Employee&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EmployeeService</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>5). Controller基础代码</strong></p><p>所属包: com.itheima.reggie.controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/employee&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmployeeController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> EmployeeService employeeService;<br><br>&#125;    <br></code></pre></td></tr></table></figure><p><strong>6). 导入通用结果类R</strong></p><p>此类是一个通用结果类，服务端响应的所有结果最终都会包装成此种类型返回给前端页面。</p><p>所属包: com.itheima.reggie.common</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通用返回结果，服务端响应的数据最终都会封装成此对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;T&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">R</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> Integer code; <span class="hljs-comment">//编码：1成功，0和其它数字为失败</span><br>    <span class="hljs-keyword">private</span> String msg; <span class="hljs-comment">//错误信息</span><br>    <span class="hljs-keyword">private</span> T data; <span class="hljs-comment">//数据</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Map</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>(); <span class="hljs-comment">//动态数据</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; R&lt;T&gt; <span class="hljs-title function_">success</span><span class="hljs-params">(T object)</span> &#123;<br>        R&lt;T&gt; r = <span class="hljs-keyword">new</span> <span class="hljs-title class_">R</span>&lt;T&gt;();<br>        r.data = object;<br>        r.code = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; R&lt;T&gt; <span class="hljs-title function_">error</span><span class="hljs-params">(String msg)</span> &#123;<br>        <span class="hljs-type">R</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">R</span>();<br>        r.msg = msg;<br>        r.code = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>    <span class="hljs-keyword">public</span> R&lt;T&gt; <span class="hljs-title function_">add</span><span class="hljs-params">(String key, Object value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.map.put(key, value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>A. 如果业务执行结果为成功, 构建R对象时, 只需要调用 success 方法; 如果需要返回数据传递 object 参数, 如果无需返回, 可以直接传递null。</p><p>B. 如果业务执行结果为失败, 构建R对象时, 只需要调用error 方法, 传递错误提示信息即可。</p><h4 id="登录逻辑分析"><a href="#登录逻辑分析" class="headerlink" title="登录逻辑分析"></a>登录逻辑分析</h4><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230627160159136.png" alt="image-20230627160159136"></p><p>处理逻辑如下：</p><p>①. 将页面提交的密码password进行md5加密处理, 得到加密后的字符串</p><p>②. 根据页面提交的用户名username查询数据库中员工数据信息</p><p>③. 如果没有查询到, 则返回登录失败结果</p><p>④. 密码比对，如果不一致, 则返回登录失败结果</p><p>⑤. 查看员工状态，如果为已禁用状态，则返回员工已禁用结果</p><p>⑥. 登录成功，将员工id存入Session, 并返回登录成功结果</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p><strong>技术点说明:</strong> </p><p>A. 由于需求分析时, 我们看到前端发起的请求为post请求, 所以服务端需要使用注解 @PostMapping</p><p>B. 由于前端传递的请求参数为json格式的数据, 这里使用Employee对象接收, 但是将json格式数据封装到实体类中, 在形参前需要加注解@RequestBody</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 员工登录</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> request</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> employee</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@PostMapping(&quot;/login&quot;)</span><br><span class="hljs-keyword">public</span> R&lt;Employee&gt; <span class="hljs-title function_">login</span><span class="hljs-params">(HttpServletRequest request,<span class="hljs-meta">@RequestBody</span> Employee employee)</span>&#123;<br><br>    <span class="hljs-comment">//1、将页面提交的密码password进行md5加密处理</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> employee.getPassword();<br>    password = DigestUtils.md5DigestAsHex(password.getBytes());<br><br>    <span class="hljs-comment">//2、根据页面提交的用户名username查询数据库</span><br>    LambdaQueryWrapper&lt;Employee&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>    queryWrapper.eq(Employee::getUsername,employee.getUsername());<br>    <span class="hljs-type">Employee</span> <span class="hljs-variable">emp</span> <span class="hljs-operator">=</span> employeeService.getOne(queryWrapper);<br><br>    <span class="hljs-comment">//3、如果没有查询到则返回登录失败结果</span><br>    <span class="hljs-keyword">if</span>(emp == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> R.error(<span class="hljs-string">&quot;登录失败&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//4、密码比对，如果不一致则返回登录失败结果</span><br>    <span class="hljs-keyword">if</span>(!emp.getPassword().equals(password))&#123;<br>        <span class="hljs-keyword">return</span> R.error(<span class="hljs-string">&quot;登录失败&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//5、查看员工状态，如果为已禁用状态，则返回员工已禁用结果</span><br>    <span class="hljs-keyword">if</span>(emp.getStatus() == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> R.error(<span class="hljs-string">&quot;账号已禁用&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//6、登录成功，将员工id存入Session并返回登录成功结果</span><br>    request.getSession().setAttribute(<span class="hljs-string">&quot;employee&quot;</span>,emp.getId());<br>    <span class="hljs-keyword">return</span> R.success(emp);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h3><p>代码实现完毕后, 启动项目, 访问url: <a href="http://localhost:8080/backend/page/login/login.html">http://localhost:8080/backend/page/login/login.html</a> , 进行登录测试。</p><p>在测试过程中， 可以通过debug断点调试的方式来跟踪程序的执行过程，并且可以查看程序运行时各个对象的具体赋值情况。而且需要注意, 在测试过程中，需要将所有的情况都覆盖到。</p><p><strong>1). 问题说明</strong></p><p>当我们在进行debug端点调试时, 前端可能会出现如下问题: 前端页面的控制台报出错误-超时;</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230627160311446.png" alt="image-20230627160311446"></p><p><strong>2). 解决方案</strong></p><p>前端进行异步请求时, 默认超时10000ms , 可以将该值调大一些。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230627160324980.png" alt="image-20230627160324980"></p><p>==由于修改了JS文件，需要手动清理一下浏览器缓存，避免缓存影响，JS不能及时生效。==</p><h2 id="后台系统退出功能"><a href="#后台系统退出功能" class="headerlink" title="后台系统退出功能"></a>后台系统退出功能</h2><h3 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h3><p>在后台管理系统中，管理员或者员工，登录进入系统之后，页面跳转到后台系统首页面(backend/index.html)，此时会在系统的右上角显示当前登录用户的姓名。</p><p>如果员工需要退出系统，直接点击右侧的退出按钮即可退出系统，退出系统后页面应跳转回登录页面。</p><p><strong>退出页面展示</strong></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230627160415815.png" alt="image-20230627160415815"></p><p><strong>前端页面分析</strong></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230627160436233.png" alt="image-20230627160436233"></p><p>点击 <img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210727010150207.png" alt="image-20210727010150207"> 将会调用一个js方法logout, 在logout的方法中执行如下逻辑:</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230627160452207.png" alt="image-20230627160452207"></p><p>A. 发起post请求, 调用服务端接口 /employee/logout 执行退出操作 ;</p><p>B. 删除客户端 localStorage 中存储的用户登录信息, 跳转至登录页面 ;</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>需要在Controller中创建对应的处理方法, 接收页面发送的POST请求 /employee/logout ，具体的处理逻辑：</p><p>A. 清理Session中的用户id</p><p>B. 返回结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 员工退出</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> request</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@PostMapping(&quot;/logout&quot;)</span><br><span class="hljs-keyword">public</span> R&lt;String&gt; <span class="hljs-title function_">logout</span><span class="hljs-params">(HttpServletRequest request)</span>&#123;<br>    <span class="hljs-comment">//清理Session中保存的当前登录员工的id</span><br>    request.getSession().removeAttribute(<span class="hljs-string">&quot;employee&quot;</span>);<br>    <span class="hljs-keyword">return</span> R.success(<span class="hljs-string">&quot;退出成功&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="功能测试-1"><a href="#功能测试-1" class="headerlink" title="功能测试"></a>功能测试</h3><p>1). 代码实现完毕后, 重启服务, 访问登录界面 <a href="http://localhost:8080/backend/page/login/login.html">http://localhost:8080/backend/page/login/login.html</a> ;</p><p>2). 登录完成之后, 进入到系统首页 backend/index.html, 点击右上角 <img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210727010150207.png" alt="image-20210727010150207"> 按钮 执行退出操作, 完成后看看是否可以跳转到登录页面 , 并检查localStorage。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230627160539238.png" alt="image-20230627160539238"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230627160543912.png" alt="image-20230627160543912"></p><h2 id="完善登录功能"><a href="#完善登录功能" class="headerlink" title="完善登录功能"></a>完善登录功能</h2><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>前面我们已经完成了后台系统的员工登录功能开发，但是目前还存在一个问题，接下来我们来说明一个这个问题， 以及如何处理。</p><p><strong>1). 目前现状</strong></p><p>用户如果不登录，直接访问系统首页面，照样可以正常访问。 </p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230627180058050.png" alt="image-20230627180058050"></p><p><strong>2). 理想效果</strong></p><p>上述这种设计并不合理，我们希望看到的效果应该 是，只有登录成功后才可以访问系统中的页面，如果没有登录, 访问系统中的任何界面都直接跳转到登录页面。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230627180107806.png" alt="image-20230627180107806"></p><p><strong>那么，具体应该怎么实现呢？</strong></p><p>可以使用我们之前讲解过的 过滤器、拦截器来实现，在过滤器、拦截器中拦截前端发起的请求，判断用户是否已经完成登录，如果没有登录则返回提示信息，跳转到登录页面。</p><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230627180132931.png" alt="image-20230627180132931"></p><p><strong>过滤器具体的处理逻辑如下：</strong></p><p>A. 获取本次请求的URI</p><p>B. 判断本次请求, 是否需要登录, 才可以访问</p><p>C. 如果不需要，则直接放行</p><p>D. 判断登录状态，如果已登录，则直接放行</p><p>E. 如果未登录, 则返回未登录结果</p><p>如果未登录,我们需要给前端返回什么样的结果呢? 这个时候, 我们可以去看看前端是如何处理的 ?</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230627180153010.png" alt="image-20230627180153010"></p><h3 id="1-3-代码实现"><a href="#1-3-代码实现" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h3><p><strong>1). 定义登录校验过滤器</strong></p><p>自定义一个过滤器 LoginCheckFilter 并实现 Filter 接口, 在doFilter方法中完成校验的逻辑。 那么接下来, 我们就根据上述分析的步骤, 来完成具体的功能代码实现: </p><p>所属包: com.itheima.reggie.filter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.itheima.reggie.common.R;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.util.AntPathMatcher;<br><br><span class="hljs-keyword">import</span> javax.servlet.*;<br><span class="hljs-keyword">import</span> javax.servlet.annotation.WebFilter;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 检查用户是否已经完成登录</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@WebFilter(filterName = &quot;loginCheckFilter&quot;,urlPatterns = &quot;/*&quot;)</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginCheckFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span>&#123;<br>    <span class="hljs-comment">//路径匹配器，支持通配符</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AntPathMatcher</span> <span class="hljs-variable">PATH_MATCHER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AntPathMatcher</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> (HttpServletRequest) servletRequest;<br>        <span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> (HttpServletResponse) servletResponse;<br><br>        <span class="hljs-comment">//1、获取本次请求的URI</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">requestURI</span> <span class="hljs-operator">=</span> request.getRequestURI();<span class="hljs-comment">// /backend/index.html</span><br><br>        log.info(<span class="hljs-string">&quot;拦截到请求：&#123;&#125;&quot;</span>,requestURI);<br><br>        <span class="hljs-comment">//定义不需要处理的请求路径</span><br>        String[] urls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<br>                <span class="hljs-string">&quot;/employee/login&quot;</span>,<br>                <span class="hljs-string">&quot;/employee/logout&quot;</span>,<br>                <span class="hljs-string">&quot;/backend/**&quot;</span>,<br>                <span class="hljs-string">&quot;/front/**&quot;</span><br>        &#125;;<br><br>        <span class="hljs-comment">//2、判断本次请求是否需要处理</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">check</span> <span class="hljs-operator">=</span> check(urls, requestURI);<br><br>        <span class="hljs-comment">//3、如果不需要处理，则直接放行</span><br>        <span class="hljs-keyword">if</span>(check)&#123;<br>            log.info(<span class="hljs-string">&quot;本次请求&#123;&#125;不需要处理&quot;</span>,requestURI);<br>            filterChain.doFilter(request,response);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//4、判断登录状态，如果已登录，则直接放行</span><br>        <span class="hljs-keyword">if</span>(request.getSession().getAttribute(<span class="hljs-string">&quot;employee&quot;</span>) != <span class="hljs-literal">null</span>)&#123;<br>            log.info(<span class="hljs-string">&quot;用户已登录，用户id为：&#123;&#125;&quot;</span>,request.getSession().getAttribute(<span class="hljs-string">&quot;employee&quot;</span>));<br>            filterChain.doFilter(request,response);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        log.info(<span class="hljs-string">&quot;用户未登录&quot;</span>);<br>        <span class="hljs-comment">//5、如果未登录则返回未登录结果，通过输出流方式向客户端页面响应数据</span><br>        response.getWriter().write(JSON.toJSONString(R.error(<span class="hljs-string">&quot;NOTLOGIN&quot;</span>)));<br>        <span class="hljs-keyword">return</span>;<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 路径匹配，检查本次请求是否需要放行</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> urls</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> requestURI</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(String[] urls,String requestURI)</span>&#123;<br>        <span class="hljs-keyword">for</span> (String url : urls) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">match</span> <span class="hljs-operator">=</span> PATH_MATCHER.match(url, requestURI);<br>            <span class="hljs-keyword">if</span>(match)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><font color='red'><b>AntPathMatcher 拓展:</b></font></p><p><strong>介绍:</strong> Spring中提供的路径匹配器 ;</p><p><strong>通配符规则:</strong>         </p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>?</td><td>匹配一个字符</td></tr><tr><td>*</td><td>匹配0个或多个字符</td></tr><tr><td>**</td><td>匹配0个或多个目录/字符</td></tr></tbody></table></blockquote><p><strong>2). 开启组件扫描</strong></p><p>需要在引导类上, 加上Servlet组件扫描的注解, 来扫描过滤器配置的@WebFilter注解， 扫描上之后， 过滤器在运行时就生效了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@ServletComponentScan</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReggieApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(ReggieApplication.class,args);<br>        log.info(<span class="hljs-string">&quot;项目启动成功...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><font color='red'><b>@ServletComponentScan 的作用: </b></font></p><p>​    在SpringBoot项目中, 在引导类/配置类上加了该注解后, 会自动扫描项目中(当前包及其子包下)的@WebServlet , @WebFilter , @WebListener 注解, 自动注册Servlet的相关组件 ;</p></blockquote><h3 id="1-4-功能测试"><a href="#1-4-功能测试" class="headerlink" title="1.4 功能测试"></a>1.4 功能测试</h3><p>代码编写完毕之后，我们需要将工程重启一下，然后在浏览器地址栏直接输入系统管理后台首页，然后看看是否可以跳转到登录页面即可。我们也可以通过debug的形式来跟踪一下代码执行的过程。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230627180234121.png" alt="image-20230627180234121"></p><p>对于前端的代码, 也可以进行debug调试。</p><p>F12打开浏览器的调试工具, 找到我们前面提到的request.js, 在request.js的响应拦截器位置打上断点。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230627180244595.png" alt="image-20230627180244595"></p>]]></content>
    
    
    <categories>
      
      <category>JAVA学习</category>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法</title>
    <link href="/2023/03/22/%E7%AE%97%E6%B3%95/"/>
    <url>/2023/03/22/%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><a href="https://programmercarl.com/">来源</a></p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="1、二分查找"><a href="#1、二分查找" class="headerlink" title="1、二分查找"></a>1、二分查找</h2><h3 id="704、二分查找"><a href="#704、二分查找" class="headerlink" title="704、二分查找"></a>704、二分查找</h3><ul><li>35.搜索插入位置</li><li>34.在排序数组中查找元素的第一个和最后一个位置</li><li>367.有效的完全平方数</li></ul><p><strong>前提是数组为有序数组</strong>，同时题目还强调<strong>数组中无重复元素</strong>，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件。</p><p><a href="https://leetcode.cn/problems/binary-search/">leetcode链接</a></p><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>示例 1:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: nums = [-1,0,3,5,9,12], target = 9     <br>输出: 4       <br>解释: 9 出现在 nums 中并且下标为 4     <br></code></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: nums = [-1,0,3,5,9,12], target = 2     <br>输出: -1        <br>解释: 2 不存在 nums 中因此返回 -1        <br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>你可以假设 nums 中的所有元素是不重复的。</li><li>n 将在 [1, 10000]之间。</li><li>nums 的每个元素都将在 [-9999, 9999]之间</li></ul><p><strong>第一种写法</strong>，我们定义 target 是在一个在左闭右闭的区间里，<strong>也就是[left, right] （这个很重要非常重要）</strong>。</p><p>区间的定义这就决定了二分法的代码应该如何写，<strong>因为定义target在[left, right]区间，所以有如下两点：</strong></p><ul><li>while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;=。</li><li>if (nums[middle] &gt; target) ，right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1。</li></ul><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230322103854002.png" alt="image-20230322103854002" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-comment">// 避免当 target 小于nums[0] nums[nums.length - 1]时多次循环运算</span><br>        <span class="hljs-keyword">if</span> (target &lt; nums[<span class="hljs-number">0</span>] || target &gt; nums[nums.length - <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + ((right - left) &gt;&gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (nums[mid] == target)<br>                <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br>                right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第二种写法</strong>，如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。</p><p>有如下两点：</p><ul><li>while (left &lt; right)，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的</li><li>if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li></ul><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230322104057766.png" alt="image-20230322104057766" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + ((right - left) &gt;&gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (nums[mid] == target)<br>                <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br>                right = mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35.搜索插入位置"></a>35.搜索插入位置</h3><p><a href="https://leetcode.cn/problems/search-insert-position/">力扣题目链接</a></p><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p>示例 1:</p><ul><li>输入: [1,3,5,6], 5</li><li>输出: 2</li></ul><p>示例 2:</p><ul><li>输入: [1,3,5,6], 2</li><li>输出: 1</li></ul><p>示例 3:</p><ul><li>输入: [1,3,5,6], 7</li><li>输出: 4</li></ul><p>示例 4:</p><ul><li>输入: [1,3,5,6], 0</li><li>输出: 0</li></ul><p>思路</p><p>这道题目不难，但是为什么通过率相对来说并不高呢，我理解是大家对边界处理的判断有所失误导致的。</p><p>这道题目，要在数组中插入目标值，无非是这四种情况。</p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/20201216232148471.png" alt="35_搜索插入位置3" style="zoom:50%;" /><ul><li><p>目标值在数组所有元素之前</p></li><li><p>目标值等于数组中某一个元素</p></li><li><p>目标值插入数组中的位置</p></li><li><p>目标值在数组所有元素之后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchInsert</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br><br>        <span class="hljs-comment">// 定义target在左闭右闭的区间，[low, high]</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">high</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (low &lt;= high) &#123; <span class="hljs-comment">// 当low==high，区间[low, high]依然有效</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> low + (high - low) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 防止溢出</span><br>            <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>                high = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// target 在左区间，所以[low, mid - 1]</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                low = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// target 在右区间，所以[mid + 1, high]</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 1. 目标值等于数组中某一个元素  return mid;</span><br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 2.目标值在数组所有元素之前 3.目标值插入数组中 4.目标值在数组所有元素之后 return right + 1;</span><br>        <span class="hljs-keyword">return</span> high + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//第二种二分法：左闭右开</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchInsert</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123; <span class="hljs-comment">//左闭右开 [left, right)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> left + ((right - left) &gt;&gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (nums[middle] &gt; target) &#123;<br>            right = middle; <span class="hljs-comment">// target 在左区间，在[left, middle)中</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] &lt; target) &#123;<br>            left = middle + <span class="hljs-number">1</span>; <span class="hljs-comment">// target 在右区间，在 [middle+1, right)中</span><br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// nums[middle] == target</span><br>            <span class="hljs-keyword">return</span> middle; <span class="hljs-comment">// 数组中找到目标值的情况，直接返回下标</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 目标值在数组所有元素之前 [0,0)</span><br>    <span class="hljs-comment">// 目标值插入数组中的位置 [left, right) ，return right 即可</span><br>    <span class="hljs-comment">// 目标值在数组所有元素之后的情况 [left, right)，因为是右开区间，所以 return right</span><br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h3><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">力扣链接(opens new window)</a></p><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>进阶：你可以设计并实现时间复杂度为 $O(\log n)$ 的算法解决此问题吗？</p><p>示例 1：</p><ul><li>输入：nums = [5,7,7,8,8,10], target = 8</li><li>输出：[3,4]</li></ul><p>示例 2：</p><ul><li>输入：nums = [5,7,7,8,8,10], target = 6</li><li>输出：[-1,-1]</li></ul><p>示例 3：</p><ul><li>输入：nums = [], target = 0</li><li>输出：[-1,-1]</li></ul><p> 在排序数组中查找元素的第一个和最后一个位置.html#思路</p><p>这道题目如果基础不是很好，不建议大家看简短的代码，简短的代码隐藏了太多逻辑，结果就是稀里糊涂把题AC了，但是没有想清楚具体细节！</p><p>寻找target在数组里的左右边界，有如下三种情况：</p><ul><li>情况一：target 在数组范围的右边或者左边，例如数组{3, 4, 5}，target为2或者数组{3, 4, 5},target为6，此时应该返回{-1, -1}</li><li>情况二：target 在数组范围中，且数组中不存在target，例如数组{3,6,7},target为5，此时应该返回{-1, -1}</li><li>情况三：target 在数组范围中，且数组中存在target，例如数组{3,6,7},target为6，此时应该返回{1, 1}</li></ul><p>这三种情况都考虑到，说明就想的很清楚了。</p><p>接下来，在去寻找左边界，和右边界了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] searchRange(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>            <span class="hljs-comment">//3种情况  nums[1 2 3 3 4 5 6] target 3</span><br>            <span class="hljs-comment">//        nums[4 5 6] target 3,7</span><br>            <span class="hljs-comment">//        nums[4 5 7] target 6</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">rightBorder</span> <span class="hljs-operator">=</span> searchRight(nums, target);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">leftBorder</span> <span class="hljs-operator">=</span> searchLeft(nums, target);<br>            <span class="hljs-comment">//nums[4 5 6] target 3,7</span><br>            <span class="hljs-keyword">if</span> (rightBorder == -<span class="hljs-number">2</span> || leftBorder == -<span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>            &#125;<br>            <span class="hljs-comment">//nums[1 2 3 3 4 5 6] target 3</span><br>            <span class="hljs-keyword">if</span> (rightBorder - leftBorder &gt; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;leftBorder + <span class="hljs-number">1</span>, rightBorder - <span class="hljs-number">1</span>&#125;;<br>            &#125;<br>            <span class="hljs-comment">//nums[4 5 7] target 6</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>        &#125;<br><br>        <span class="hljs-comment">//寻找左边界</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchLeft</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">leftBoader</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (target &gt; nums[middle]) &#123;<br>                    left = middle + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//左边界时，右指针取值，最后多减了一次</span><br>                    right = middle - <span class="hljs-number">1</span>;<br>                    leftBoader = right;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> leftBoader;<br>        &#125;<br><br>        <span class="hljs-comment">//寻找右边界</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchRight</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rightBoader</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (target &gt;= nums[middle]) &#123;<br>                    <span class="hljs-comment">//右边界时，左指针取值，最后多加了一次</span><br>                    left = middle + <span class="hljs-number">1</span>;<br>                    rightBoader = left;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    right = middle - <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> rightBoader;<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="2、移除元素（双指针法）"><a href="#2、移除元素（双指针法）" class="headerlink" title="2、移除元素（双指针法）"></a>2、移除元素（双指针法）</h2><h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h3><p>相关题目推荐</p><ul><li>26.删除排序数组中的重复项</li><li>283.移动零</li><li>844.比较含退格的字符串</li><li>977.有序数组的平方</li></ul><p><a href="https://leetcode.cn/problems/remove-element/">力扣题目链接(opens new window)</a></p><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并<strong>原地</strong>修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。</p><p>示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p><p><strong>你不需要考虑数组中超出新长度后面的元素。</strong></p><p> <strong>思路</strong></p><p> 双指针法</p><p>双指针法（快慢指针法）： <strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p><p>定义快慢指针</p><ul><li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li><li>慢指针：指向更新 新数组下标的位置</li></ul><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/remove.gif" alt="remove"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-comment">// 快慢指针</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">slowIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">fastIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; fastIndex &lt; nums.length; fastIndex++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[fastIndex] != val) &#123;<br>                nums[slowIndex] = nums[fastIndex];<br>                slowIndex++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slowIndex;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、寻找两个正序数组的中位数（双指针法）"><a href="#4、寻找两个正序数组的中位数（双指针法）" class="headerlink" title="4、寻找两个正序数组的中位数（双指针法）"></a>4、寻找两个正序数组的中位数（双指针法）</h3><p><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">力扣</a></p><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1,3]</span>, nums2 = <span class="hljs-comment">[2]</span><br>输出：2.00000<br>解释：合并数组 = <span class="hljs-comment">[1,2,3]</span> ，中位数 2<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">2.50000</span><br>解释：合并数组 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>] ，中位数 <span class="hljs-comment">(2 + 3)</span> / <span class="hljs-number">2</span> = <span class="hljs-number">2.5</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>nums1.length == m</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m &lt;= 1000</code></li><li><code>0 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= m + n &lt;= 2000</code></li><li><code>-106 &lt;= nums1[i], nums2[i] &lt;= 106</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">P4_MedianOfTwoSortedArrays</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Solution</span> <span class="hljs-variable">solution</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">P4_MedianOfTwoSortedArrays</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">Solution</span>();<br>        <br>    &#125;<br><br>    <span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 用于区分总长度是单数还是双数</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> (nums1.length + nums2.length - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> (nums1.length + nums2.length) / <span class="hljs-number">2</span>;<br><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 用于记录左右值</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">p_left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">p_right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 用于数组指针计数</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= right; i++) &#123;<br>                p_left = p_right;<br>                <span class="hljs-comment">//两种情况1，2没记数完，比大小，某一个记数完，则加另一个</span><br>                <span class="hljs-keyword">if</span> (p2 == nums2.length || (p1 &lt; nums1.length &amp;&amp; nums1[p1] &lt;= nums2[p2])) &#123;<br>                    p_right = nums1[p1];<br>                    p1++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    p_right = nums2[p2];<br>                    p2++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (left == right) &#123;<span class="hljs-comment">//判断奇数、偶数</span><br>                p_left = p_right;<br>            &#125;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-type">float</span>) (p_left + p_right) / <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h2><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">力扣题目链接(opens new window)</a></p><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p><p>示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</p><p>示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121]</p><p><strong>双指针法</strong></p><p>数组其实是有序的， 只不过负数平方之后可能成为最大数了。</p><p>那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。</p><p>此时可以考虑双指针法了，i指向起始位置，j指向终止位置。</p><p>定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。</p><p>如果<code>A[i] * A[i] &lt; A[j] * A[j]</code> 那么<code>result[k--] = A[j] * A[j];</code> 。</p><p>如果<code>A[i] * A[i] &gt;= A[j] * A[j]</code> 那么<code>result[k--] = A[i] * A[i];</code> 。</p><p>如动画所示：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/square.gif" alt="square"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sortedSquares(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> result.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span> (nums[left] * nums[left] &gt; nums[right] * nums[right]) &#123;<br>                <span class="hljs-comment">// 正数的相对位置是不变的， 需要调整的是负数平方后的相对位置</span><br>                result[index--] = nums[left] * nums[left];<br>                ++left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                result[index--] = nums[right] * nums[right];<br>                --right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h2><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">力扣题目链接(opens new window)</a></p><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p><p>示例：</p><p>输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。</p><p>提示：</p><ul><li>1 &lt;= target &lt;= 10^9</li><li>1 &lt;= nums.length &lt;= 10^5</li><li>1 &lt;= nums[i] &lt;= 10^5</li></ul><p>#暴力解法</p><p>这道题目暴力解法当然是 两个for循环，然后不断的寻找符合条件的子序列，时间复杂度很明显是O(n^2)。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> s, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = INT32_MAX; <span class="hljs-comment">// 最终的结果</span><br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 子序列的数值之和</span><br>        <span class="hljs-type">int</span> subLength = <span class="hljs-number">0</span>; <span class="hljs-comment">// 子序列的长度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 设置子序列起点为i</span><br>            sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; nums.<span class="hljs-built_in">size</span>(); j++) &#123; <span class="hljs-comment">// 设置子序列终止位置为j</span><br>                sum += nums[j];<br>                <span class="hljs-keyword">if</span> (sum &gt;= s) &#123; <span class="hljs-comment">// 一旦发现子序列和超过了s，更新result</span><br>                    subLength = j - i + <span class="hljs-number">1</span>; <span class="hljs-comment">// 取子序列的长度</span><br>                    result = result &lt; subLength ? result : subLength;<br>                    <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 因为我们是找符合条件最短的子序列，所以一旦符合条件就break</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span><br>        <span class="hljs-keyword">return</span> result == INT32_MAX ? <span class="hljs-number">0</span> : result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(1)</li></ul><p>后面力扣更新了数据，暴力解法已经超时了。</p><p>滑动窗口</p><p>接下来就开始介绍数组操作中另一个重要的方法：<strong>滑动窗口</strong>。</p><p>所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p><p>在暴力解法中，是一个for循环滑动窗口的起始位置，一个for循环为滑动窗口的终止位置，用两个for循环 完成了一个不断搜索区间的过程。</p><p>那么滑动窗口如何用一个for循环来完成这个操作呢。</p><p>首先要思考 如果用一个for循环，那么应该表示 滑动窗口的起始位置，还是终止位置。</p><p>如果只用一个for循环来表示 滑动窗口的起始位置，那么如何遍历剩下的终止位置？</p><p>此时难免再次陷入 暴力解法的怪圈。</p><p>所以 只用一个for循环，那么这个循环的索引，一定是表示 滑动窗口的终止位置。</p><p>那么问题来了， 滑动窗口的起始位置如何移动呢？</p><p>这里还是以题目中的示例来举例，s=7， 数组是 2，3，1，2，4，3，来看一下查找的过程：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/209.gif" alt="209"></p><p>其实从动画中可以发现滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。</p><p>在本题中实现滑动窗口，主要确定如下三点：</p><ul><li>窗口内是什么？</li><li>如何移动窗口的起始位置？</li><li>如何移动窗口的结束位置？</li></ul><p>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</p><p>窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。</p><p>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。</p><p>解题的关键在于 窗口的起始位置如何移动，如图所示：<img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/20210312160441942.png" alt="leetcode_209"></p><p>可以发现<strong>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)。</strong></p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p>**一些录友会疑惑为什么时间复杂度是O(n)**。</p><p>不要以为for里放一个while就以为是O(n^2)啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是 2 × n 也就是O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-comment">// 滑动窗口</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; right &lt; nums.length; right++) &#123;<br>            sum += nums[right];<br>            <span class="hljs-keyword">while</span> (sum &gt;= s) &#123;<br>                result = Math.min(result, right - left + <span class="hljs-number">1</span>);<br>                sum -= nums[left++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result == Integer.MAX_VALUE ? <span class="hljs-number">0</span> : result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>相关题目推荐</strong></p><ul><li><a href="https://leetcode.cn/problems/fruit-into-baskets/">904.水果成篮(opens new window)</a></li><li><a href="https://leetcode.cn/problems/minimum-window-substring/">76.最小覆盖子串(opens new window)</a></li></ul><h2 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59.螺旋矩阵II"></a>59.螺旋矩阵II</h2><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">力扣题目链接(opens new window)</a></p><p>给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><p>示例:</p><p>输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]</p><p><strong>思路</strong></p><p>这道题目可以说在面试中出现频率较高的题目，<strong>本题并不涉及到什么算法，就是模拟过程，但却十分考察对代码的掌控能力。</strong></p><p>要如何画出这个螺旋排列的正方形矩阵呢？</p><p>相信很多同学刚开始做这种题目的时候，上来就是一波判断猛如虎。</p><p>结果运行的时候各种问题，然后开始各种修修补补，最后发现改了这里那里有问题，改了那里这里又跑不起来了。</p><p>而求解本题依然是要坚持循环不变量原则。</p><p>模拟顺时针画矩阵的过程:</p><ul><li>填充上行从左到右</li><li>填充右列从上到下</li><li>填充下行从右到左</li><li>填充左列从下到上</li></ul><p>由外向内一圈一圈这么画下去。</p><p>可以发现这里的边界条件非常多，在一个循环中，如此多的边界条件，如果不按照固定规则来遍历，那就是<strong>一进循环深似海，从此offer是路人</strong>。</p><p>这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开右闭的原则，这样这一圈才能按照统一的规则画下来。</p><p>那么我按照左闭右开的原则，来画一圈，大家看一下：而求解本题依然是要坚持循环不变量原则。</p><p>模拟顺时针画矩阵的过程:</p><ul><li>填充上行从左到右</li><li>填充右列从上到下</li><li>填充下行从右到左</li><li>填充左列从下到上</li></ul><p>由外向内一圈一圈这么画下去。</p><p>可以发现这里的边界条件非常多，在一个循环中，如此多的边界条件，如果不按照固定规则来遍历，那就是<strong>一进循环深似海，从此offer是路人</strong>。</p><p>这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开右闭的原则，这样这一圈才能按照统一的规则画下来。</p><p>那么我按照左闭右开的原则，来画一圈，大家看一下：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/20220922102236.png" alt="img"></p><p>这里每一种颜色，代表一条边，我们遍历的长度，可以看出每一个拐角处的处理规则，拐角处让给新的一条边来继续画。</p><p>这也是坚持了每条边左闭右开的原则。</p><p>一些同学做这道题目之所以一直写不好，代码越写越乱。</p><p>就是因为在画每一条边的时候，一会左开右闭，一会左闭右闭，一会又来左闭右开，岂能不乱。</p><p>代码如下，已经详细注释了每一步的目的，可以看出while循环里判断的情况是很多的，代码里处理的原则也是统一的左闭右开。</p><ul><li>时间复杂度 O(n^2): 模拟遍历二维矩阵的时间</li><li>空间复杂度 O(1)</li></ul><p><strong>类似题目</strong></p><ul><li>54.螺旋矩阵</li><li>剑指Offer 29.顺时针打印矩阵</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] generateMatrix(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">loop</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 控制循环次数</span><br>        <span class="hljs-type">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 每次循环的开始点(start, start)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// 定义填充数字</span><br>        <span class="hljs-type">int</span> i, j;<br><br>        <span class="hljs-keyword">while</span> (loop++ &lt; n / <span class="hljs-number">2</span>) &#123; <span class="hljs-comment">// 判断边界后，loop从1开始</span><br>            <span class="hljs-comment">// 模拟上侧从左到右</span><br>            <span class="hljs-keyword">for</span> (j = start; j &lt; n - loop; j++) &#123;<br>                res[start][j] = count++;<br>            &#125;<br><br>            <span class="hljs-comment">// 模拟右侧从上到下</span><br>            <span class="hljs-keyword">for</span> (i = start; i &lt; n - loop; i++) &#123;<br>                res[i][j] = count++;<br>            &#125;<br><br>            <span class="hljs-comment">// 模拟下侧从右到左</span><br>            <span class="hljs-keyword">for</span> (; j &gt;= loop; j--) &#123;<br>                res[i][j] = count++;<br>            &#125;<br><br>            <span class="hljs-comment">// 模拟左侧从下到上</span><br>            <span class="hljs-keyword">for</span> (; i &gt;= loop; i--) &#123;<br>                res[i][j] = count++;<br>            &#125;<br>            start++;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            res[start][start] = count;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/Arrays.png" alt="Arrays" style="zoom:200%;" /><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>什么是链表，链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。</p><p>链表的入口节点称为链表的头结点也就是head。</p><p>如图所示：<img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/20200806194529815.png" alt="链表1"></p><p><strong>单链表</strong></p><p>刚刚说的就是单链表。</p><p><strong>双链表</strong></p><p>单链表中的指针域只能指向节点的下一个节点。</p><p>双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。</p><p>双链表 既可以向前查询也可以向后查询。</p><p>如图所示：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/20200806194559317.png" alt="链表2"></p><p><strong>循环链表</strong></p><p>循环链表，顾名思义，就是链表首尾相连。</p><p>循环链表可以用来解决约瑟夫环问题。<img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/20200806194629603.png" alt="链表4"></p><p><strong>链表的定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-comment">// 结点的值</span><br>    <span class="hljs-type">int</span> val;<br><br>    <span class="hljs-comment">// 下一个结点</span><br>    ListNode next;<br><br>    <span class="hljs-comment">// 节点的构造函数(无参)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-comment">// 节点的构造函数(有一个参数)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>    &#125;<br><br>    <span class="hljs-comment">// 节点的构造函数(有两个参数)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> val, ListNode next)</span> &#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>        <span class="hljs-built_in">this</span>.next = next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>删除节点</strong></p><p>删除D节点，如图所示：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/20200806195114541-20230310121459257.png" alt="链表-删除节点"></p><p>只要将C节点的next指针 指向E节点就可以了。</p><p>那有同学说了，D节点不是依然存留在内存里么？只不过是没有在这个链表里而已。</p><p>是这样的，所以在C++里最好是再手动释放这个D节点，释放这块内存。</p><p>其他语言例如Java、Python，就有自己的内存回收机制，就不用自己手动释放了。</p><p><strong>添加节点</strong></p><p>如图所示：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806195134331-20230310121503147.png" alt="链表-添加节点"></p><p>可以看出链表的增添和删除都是O(1)操作，也不会影响到其他节点。</p><p>但是要注意，要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。</p><p><strong>性能分析</strong></p><p>再把链表的特性和数组的特性进行一个对比，如图所示：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/20200806195200276.png" alt="链表-链表与数据性能对比"></p><h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h2><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">力扣题目链接(opens new window)</a></p><p>题意：删除链表中等于给定值 val 的所有节点。</p><p>示例 1： 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5]</p><p>示例 2： 输入：head = [], val = 1 输出：[]</p><p>示例 3： 输入：head = [7,7,7,7], val = 7 输出：[]</p><p><strong>思路</strong></p><p>这里以链表 1 4 2 4 来举例，移除元素4。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/20210316095351161.png" alt="203_链表删除元素1"></p><p>如果使用C，C++编程语言的话，不要忘了还要从内存中删除这两个移除的节点， 清理节点内存之后如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210316095418280.png" alt="203_链表删除元素2"></p><p><strong>当然如果使用java ，python的话就不用手动管理内存了。</strong></p><p>还要说明一下，就算使用C++来做leetcode，如果移除一个节点之后，没有手动在内存中删除这个节点，leetcode依然也是可以通过的，只不过，内存使用的空间大一些而已，但建议依然要养成手动清理内存的习惯。</p><p>这种情况下的移除操作，就是让节点next指针直接指向下下一个节点就可以了，</p><p>那么因为单链表的特殊性，只能指向下一个节点，刚刚删除的是链表的中第二个，和第四个节点，那么如果删除的是头结点又该怎么办呢？</p><p>这里就涉及如下链表操作的两种方式：</p><ul><li><strong>直接使用原来的链表来进行删除操作。</strong></li><li><strong>设置一个虚拟头结点在进行删除操作。</strong></li></ul><p>来看第一种操作：直接使用原来的链表来进行移除。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/2021031609544922.png" alt="203_链表删除元素3"></p><p>移除头结点和移除其他节点的操作是不一样的，因为链表的其他节点都是通过前一个节点来移除当前节点，而头结点没有前一个节点。</p><p>所以头结点如何移除呢，其实只要将头结点向后移动一位就可以，这样就从链表中移除了一个头结点。</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210316095512470.png" alt="203_链表删除元素4"></p><p>依然别忘将原头结点从内存中删掉。 <img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/20210316095543775.png" alt="203_链表删除元素5"></p><p>这样移除了一个头结点，是不是发现，在单链表中移除头结点 和 移除其他节点的操作方式是不一样，其实在写代码的时候也会发现，需要单独写一段逻辑来处理移除头结点的情况。</p><p>那么可不可以 以一种统一的逻辑来移除 链表的节点呢。</p><p>其实<strong>可以设置一个虚拟头结点</strong>，这样原链表的所有节点就都可以按照统一的方式进行移除了。</p><p>来看看如何设置一个虚拟头。依然还是在这个链表中，移除元素1。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/20210316095619221.png" alt="203_链表删除元素6"></p><p>这里来给链表添加一个虚拟头结点为新的头结点，此时要移除这个旧头结点元素1。</p><p>这样是不是就可以使用和移除链表其他节点的方式统一了呢？</p><p>来看一下，如何移除元素1 呢，还是熟悉的方式，然后从内存中删除元素1。</p><p>最后呢在题目中，return 头结点的时候，别忘了 <code>return dummyNode-&gt;next;</code>， 这才是新的头结点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 添加虚节点方式</span><br><span class="hljs-comment"> * 时间复杂度 O(n)</span><br><span class="hljs-comment"> * 空间复杂度 O(1)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> head</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> val</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-comment">// 因为删除可能涉及到头节点，所以设置dummy节点，统一操作</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>, head);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> dummy;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (cur.val == val) &#123;<br>            pre.next = cur.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pre = cur;<br>        &#125;<br>        cur = cur.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 不添加虚拟节点方式</span><br><span class="hljs-comment"> * 时间复杂度 O(n)</span><br><span class="hljs-comment"> * 空间复杂度 O(1)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> head</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> val</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>    <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span> &amp;&amp; head.val == val) &#123;<br>        head = head.next;<br>    &#125;<br>    <span class="hljs-comment">// 已经为null，提前退出</span><br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-comment">// 已确定当前head.val != val</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head.next;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (cur.val == val) &#123;<br>            pre.next = cur.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pre = cur;<br>        &#125;<br>        cur = cur.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 不添加虚拟节点and pre Node方式</span><br><span class="hljs-comment"> * 时间复杂度 O(n)</span><br><span class="hljs-comment"> * 空间复杂度 O(1)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> head</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> val</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>    <span class="hljs-keyword">while</span>(head!=<span class="hljs-literal">null</span> &amp;&amp; head.val==val)&#123;<br>        head = head.next;<br>    &#125;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-keyword">while</span>(curr!=<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">while</span>(curr.next!=<span class="hljs-literal">null</span> &amp;&amp; curr.next.val == val)&#123;<br>            curr.next = curr.next.next;<br>        &#125;<br>        curr = curr.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707.设计链表"></a>707.设计链表</h2><p><a href="https://leetcode.cn/problems/design-linked-list/">力扣题目链接(opens new window)</a></p><p>题意：</p><p>在链表类中实现这些功能：</p><ul><li>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。</li><li>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</li><li>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</li><li>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</li><li>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</li><li><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/20200814200558953.png" alt="707示例"></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span>&#123;<br>    <span class="hljs-type">int</span> val;<br>    ListNode next;<br>    ListNode pre;<br>    ListNode()&#123;&#125;;<br>    ListNode( <span class="hljs-type">int</span> val)&#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>    &#125;;<br>&#125;<br><br><span class="hljs-comment">// 双向循环链表</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedList</span>&#123;<br>    <span class="hljs-type">int</span> size;<br>    ListNode head;<br>    MyLinkedList()&#123;<br>        <span class="hljs-built_in">this</span>.size = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        head.next = head;<br>        head.pre = head; <br>    &#125;<br><br>     <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br>        <br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= size)&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt;= index;i++)&#123;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur.val;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addAtHead</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span>&#123;<br>        <span class="hljs-comment">// head   1    2</span><br>        <span class="hljs-comment">//            tmp</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> head.next;<br>        head.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(val);<br>        head.next.next = tmp;<br>        head.next.pre = head;<br>        tmp.pre = head.next;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addAtTail</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span>&#123;<br>        <span class="hljs-comment">// head   1    2</span><br>        <span class="hljs-comment">//            tmp</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> head.pre;<br>        head.pre = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(val);<br>        head.pre.pre = tmp;<br>        head.pre.next = head;<br>        tmp.next = head.pre;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index,<span class="hljs-type">int</span> val)</span>&#123;<br>        <span class="hljs-keyword">if</span>(index &gt; size || index &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; index;i++)&#123;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> cur.next;<br>        cur.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(val);<br>        cur.next.next = tmp;<br>        cur.next.pre = cur;<br>        tmp.pre = cur.next;<br>        size++;<br>        <span class="hljs-keyword">return</span>;   <br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br>        <span class="hljs-keyword">if</span>(index &gt;= size || index &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; index;i++)&#123;<br>            cur = cur.next;<br>        &#125;<br>        cur.next =  cur.next.next ;<br>        cur.next.pre = cur;<br>        size--;<br>        <span class="hljs-keyword">return</span>;   <br><br>    &#125;<br><br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyLinkedList object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyLinkedList obj = new MyLinkedList();</span><br><span class="hljs-comment"> * int param_1 = obj.get(index);</span><br><span class="hljs-comment"> * obj.addAtHead(val);</span><br><span class="hljs-comment"> * obj.addAtTail(val);</span><br><span class="hljs-comment"> * obj.addAtIndex(index,val);</span><br><span class="hljs-comment"> * obj.deleteAtIndex(index);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h2><p><a href="https://leetcode.cn/problems/reverse-linked-list/">力扣题目链接(opens new window)</a></p><p>题意：反转一个单链表。</p><p>示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><p><strong>双指针：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pPre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pNext</span> <span class="hljs-operator">=</span>  head;<br>        ListNode tmp;<br>        <span class="hljs-keyword">while</span>(pNext!= <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//      1   2    3</span><br>            <span class="hljs-comment">// p1  p2   tmp</span><br>            tmp = pNext.next;<br>            pNext.next = pPre;<br>            pPre = pNext;<br>            pNext = tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pPre;<br>        <br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>递归：</strong></p><p>先递后归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// //  * Definition for singly-linked list.</span><br><span class="hljs-comment">//  public class ListNode &#123;</span><br><span class="hljs-comment">//     int val;</span><br><span class="hljs-comment">//     ListNode next;</span><br><span class="hljs-comment">//     ListNode() &#123;&#125;</span><br><span class="hljs-comment">//     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment">//     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment">//  &#125;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode cur, ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span>  ( cur.next == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> cur;<br>        &#125;<br>        head = reverse(cur.next,head);<br>        cur.next.next = cur;<br>        cur.next = <span class="hljs-literal">null</span>;  <br>        <span class="hljs-keyword">return</span> head;     <br>    &#125;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        head = reverse(cur, head);<br>        <br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>   <br>    <br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;          <br>        <span class="hljs-keyword">if</span>  ( head.next == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> reverseList(head.next);<br>        head.next.next = head;<br>        head.next = <span class="hljs-literal">null</span>;  <br>        <span class="hljs-keyword">return</span> last;     <br><br>       <br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h2><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">力扣题目链接(opens new window)</a></p><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230404100021432.png" alt="image-20230404100021432"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//先递后归</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">swapPairs</span><span class="hljs-params">(ListNode head)</span> &#123;<br><span class="hljs-comment">//  1 -&gt;  2 -&gt;   3  -&gt;   4</span><br><span class="hljs-comment">//  i     j      </span><br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> ||head.next == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> head.next;<br>        head.next = next.next;<br>        next.next = head;<br>        head.next = swapPairs(head.next);<br>       <br>        <span class="hljs-keyword">return</span> next;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//全部归处理</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">swapPairs</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-comment">// base case 退出提交</span><br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-comment">// 获取当前节点的下一个节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> head.next;<br>        <span class="hljs-comment">// 进行递归</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> swapPairs(next.next);<br>        <span class="hljs-comment">// 这里进行交换</span><br>        next.next = head;<br>        head.next = newNode;<br><br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//非递归</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">swapPairs</span><span class="hljs-params">(ListNode head)</span> &#123;<br><span class="hljs-comment">//  1 -&gt;  2 -&gt;   3  -&gt;   4</span><br><span class="hljs-comment">//  i    j,k      </span><br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> ||head.next == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> head.next;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> next;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">recordHead</span> <span class="hljs-operator">=</span> next;<br>        <br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">null</span> &amp;&amp; head.next != <span class="hljs-literal">null</span> )&#123;<br>            head.next = next.next;<br>            next.next = head;<br>            head = head.next;<br>            <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            next = head.next; <br>            <span class="hljs-comment">//最后剩奇数就不需要再指向后者</span><br>            <span class="hljs-keyword">if</span>(head.next != <span class="hljs-literal">null</span>)&#123;<br>                tmp.next.next = next;<br>                tmp = next;<br>            &#125;       <br>            <br>        &#125;   <br>        <span class="hljs-keyword">return</span> recordHead;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h2><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">力扣题目链接(opens new window)</a></p><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p>进阶：你能尝试使用一趟扫描实现吗？</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230404104701052.png" alt="image-20230404104701052"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//递归</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">shaoBin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>       shaoBin.next = head;<br>        find(shaoBin,n);<br>        <span class="hljs-keyword">return</span> shaoBin.next;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-keyword">if</span>(head ==<span class="hljs-literal">null</span> )&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> find(head.next, n);<br>        <span class="hljs-keyword">if</span>(n==tmp-<span class="hljs-number">1</span>)&#123;<br>            head.next = head.next.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> tmp+<span class="hljs-number">1</span>;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">//双指针</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">shaoBin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>       shaoBin.next = head;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> shaoBin;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> shaoBin;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n+<span class="hljs-number">1</span>;i++)&#123;<br>           next=next.next;<br>       &#125;<br>       <span class="hljs-keyword">while</span>(next!=<span class="hljs-literal">null</span>)&#123;<br>            pre=pre.next;<br>            next=next.next;<br>       &#125;<br>       pre.next = pre.next.next;<br>       <span class="hljs-keyword">return</span> shaoBin.next;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h2><p>同：160.链表相交</p><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">力扣题目链接(opens new window)</a></p><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p><p>图示两个链表在节点 c1 开始相交：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230404122626360.png" alt="image-20230404122626360"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pionterA</span> <span class="hljs-operator">=</span> headA, pionterB = headB;<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">flagA</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>, flagB = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">if</span>(pionterA == <span class="hljs-literal">null</span> &amp;&amp; !flagA )&#123;<br>                pionterA = headB;<br>                flagA = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(pionterB == <span class="hljs-literal">null</span> &amp;&amp; !flagB )&#123;<br>                pionterB = headA;<br>                flagB = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flagA &amp;&amp; flagB)&#123;<br>                <span class="hljs-keyword">if</span>(pionterA==pionterB)&#123;<br>                    <span class="hljs-keyword">return</span> pionterA;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pionterA==<span class="hljs-literal">null</span>||pionterB==<span class="hljs-literal">null</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>                &#125;<br>            &#125;<br>            pionterA = pionterA.next;<br>            pionterB = pionterB.next;            <br>        &#125;      <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="142-环形链表II"><a href="#142-环形链表II" class="headerlink" title="142.环形链表II"></a>142.环形链表II</h2><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">力扣题目链接(opens new window)</a></p><p>题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p><strong>说明</strong>：不允许修改给定的链表。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/20200816110112704.png" alt="循环链表"></p><p> <strong>思路</strong></p><p>《代码随想录》算法公开课：<a href="https://www.bilibili.com/video/BV1if4y1d7ob">把环形链表讲清楚！| LeetCode:142.环形链表II (opens new window)</a>，相信结合视频在看本篇题解，更有助于大家对链表的理解。</p><p>这道题目，不仅考察对链表的操作，而且还需要一些数学运算。</p><p>主要考察两知识点：</p><ul><li>判断链表是否环</li><li>如果有环，如何找到这个环的入口</li></ul><p><strong>判断链表是否有环</strong></p><p>可以使用快慢指针法，分别定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。</p><p>为什么fast 走两个节点，slow走一个节点，有环的话，一定会在环内相遇呢，而不是永远的错开呢</p><p>首先第一点：<strong>fast指针一定先进入环中，如果fast指针和slow指针相遇的话，一定是在环中相遇，这是毋庸置疑的。</strong></p><p>那么来看一下，<strong>为什么fast指针和slow指针一定会相遇呢？</strong></p><p>可以画一个环，然后让 fast指针在任意一个节点开始追赶slow指针。</p><p>会发现最终都是这种情况， 如下图：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/20210318162236720.png" alt="142环形链表1"></p><p>fast和slow各自再走一步， fast和slow就相遇了</p><p>这是因为fast是走两步，slow是走一步，<strong>其实相对于slow来说，fast是一个节点一个节点的靠近slow的</strong>，所以fast一定可以和slow重合。</p><p>动画如下：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/141huan.gif" alt="141huan"></p><p>如果有环，如何找到这个环的入口</p><p><strong>此时已经可以判断链表是否有环了，那么接下来要找这个环的入口了。</strong></p><p>假设从头结点到环形入口节点 的节点数为x。 环形入口节点到 fast指针与slow指针相遇节点 节点数为y。 从相遇节点 再到环形入口节点节点数为 z。 如图所示：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/20220925103433.png" alt="img"></p><p>那么相遇时： slow指针走过的节点数为: <code>x + y</code>， fast指针走过的节点数：<code>x + y + n (y + z)</code>，n为fast指针在环内走了n圈才遇到slow指针， （y+z）为 一圈内节点的个数A。</p><p>因为fast指针是一步走两个节点，slow指针一步走一个节点， 所以 fast指针走过的节点数 = slow指针走过的节点数 * 2：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">(<span class="hljs-name">x</span> + y) * <span class="hljs-number">2</span> = x + y + n (<span class="hljs-name">y</span> + z)<br></code></pre></td></tr></table></figure><p>两边消掉一个（x+y）: <code>x + y = n (y + z)</code></p><p>因为要找环形的入口，那么要求的是x，因为x表示 头结点到 环形入口节点的的距离。</p><p>所以要求x ，将x单独放在左面：<code>x = n (y + z) - y</code> ,</p><p>再从n(y+z)中提出一个 （y+z）来，整理公式之后为如下公式：<code>x = (n - 1) (y + z) + z</code> 注意这里n一定是大于等于1的，因为 fast指针至少要多走一圈才能相遇slow指针。</p><p>这个公式说明什么呢？</p><p>先拿n为1的情况来举例，意味着fast指针在环形里转了一圈之后，就遇到了 slow指针了。</p><p>当 n为1的时候，公式就化解为 <code>x = z</code>，</p><p>这就意味着，<strong>从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点</strong>。</p><p>也就是在相遇节点处，定义一个指针index1，在头结点处定一个指针index2。</p><p>让index1和index2同时移动，每次移动一个节点， 那么他们相遇的地方就是 环形入口的节点。</p><p>动画如下：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/142huan2.gif" alt="142huan2"></p><p>那么 n如果大于1是什么情况呢，就是fast指针在环形转n圈之后才遇到 slow指针。</p><p>其实这种情况和n为1的时候 效果是一样的，一样可以通过这个方法找到 环形的入口节点，只不过，index1 指针在环里 多转了(n-1)圈，然后再遇到index2，相遇点依然是环形的入口节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>            <span class="hljs-keyword">if</span> (slow == fast) &#123;<span class="hljs-comment">// 有环</span><br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">index1</span> <span class="hljs-operator">=</span> fast;<br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">index2</span> <span class="hljs-operator">=</span> head;<br>                <span class="hljs-comment">// 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口</span><br>                <span class="hljs-keyword">while</span> (index1 != index2) &#123;<br>                    index1 = index1.next;<br>                    index2 = index2.next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> index1;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h2><p><a href="https://leetcode.cn/problems/valid-anagram/">力扣题目链接(opens new window)</a></p><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>示例 1: 输入: s = “anagram”, t = “nagaram” 输出: true</p><p>示例 2: 输入: s = “rat”, t = “car” 输出: false</p><p><strong>说明:</strong> 你可以假设字符串只包含小写字母。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAnagram</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span>[] recorder= <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-string">&#x27;z&#x27;</span>-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++)&#123;<br>            recorder[s.charAt(i)-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; t.length(); i++)&#123;<br>            recorder[t.charAt(i)-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-string">&#x27;z&#x27;</span>-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(recorder[i]!=<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h2><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">力扣题目链接(opens new window)</a></p><p>题意：给定两个数组，编写一个函数来计算它们的交集。</p><p>（注意：类名大驼峰，变量方法小驼峰）</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230406145418354.png" alt="image-20230406145418354"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] intersection(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>        Set&lt;Integer&gt; nums1Set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        Set&lt;Integer&gt; resSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num1:nums1)&#123;<br>            nums1Set.add(num1);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num2:nums2)&#123;<br>            <span class="hljs-keyword">if</span>(nums1Set.contains(num2))&#123;<br>                resSet.add(num2);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//转为流，转为int，转为数组。</span><br>        <span class="hljs-keyword">return</span> resSet.stream().mapToInt(x-&gt;x).toArray();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第202题-快乐数"><a href="#第202题-快乐数" class="headerlink" title="第202题. 快乐数"></a>第202题. 快乐数</h2><p><a href="https://leetcode.cn/problems/happy-number/">力扣题目链接(opens new window)</a></p><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。</p><p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p><p><strong>示例：</strong></p><p>输入：19<br>输出：true<br>解释：<br>1^2 + 9^2 = 82<br>8^2 + 2^2 = 68<br>6^2 + 8^2 = 100<br>1^2 + 0^2 + 0^2 = 1</p><p>思路</p><p>这道题目看上去貌似一道数学问题，其实并不是！</p><p>题目中说了会 <strong>无限循环</strong>，那么也就是说<strong>求和的过程中，sum会重复出现，这对解题很重要！</strong></p><p><strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法了。</strong></p><p>所以这道题目使用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。</p><p>判断sum是否重复出现就可以使用unordered_set。</p><p><strong>还有一个难点就是求和的过程，如果对取数值各个位上的单数操作不熟悉的话，做这道题也会比较艰难。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        Set&lt;Integer&gt; resNs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(n!=<span class="hljs-number">1</span> &amp;&amp; !resNs.contains(n))&#123;<br>            resNs.add(n);<br>            n = getNextNum(n);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNextNum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>)&#123;    <br>            sum += (n%<span class="hljs-number">10</span>)*(n%<span class="hljs-number">10</span>);<br>            n = n/<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><p><a href="https://leetcode.cn/problems/two-sum/">力扣题目链接(opens new window)</a></p><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p><strong>示例:</strong></p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9</p><p>所以返回 [0, 1]</p><p><strong>思路</strong></p><p>很明显暴力的解法是两层for循环查找，时间复杂度是O(n^2)。</p><p>建议大家做这道题目之前，先做一下这两道</p><p>首先我在强调一下 <strong>什么时候使用哈希法</strong>，当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。</p><p>本题呢，我就需要一个集合来存放我们遍历过的元素，然后在遍历数组的时候去询问这个集合，某元素是否遍历过，也就是 是否出现在这个集合。</p><p>那么我们就应该想到使用哈希法了。</p><p>因为本地，我们不仅要知道元素有没有遍历过，还有知道这个元素对应的下标，<strong>需要使用 key value结构来存放，key来存元素，value来存下标，那么使用map正合适</strong>。</p><p>再来看一下使用数组和set来做哈希法的局限。</p><ul><li>数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</li><li>set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。</li></ul><p>此时就要选择另一种数据结构：map ，map是一种key value的存储结构，可以用key保存数值，用value在保存数值所在的下标。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/20220711202638.png" alt="过程一"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;nums.length;j++)<br>                <span class="hljs-keyword">if</span>(nums[i]+nums[j]==target)<br>                    &#123;<br>                        a[<span class="hljs-number">0</span>]=i;<br>                        a[<span class="hljs-number">1</span>]=j;<br>                        <span class="hljs-keyword">return</span> a;<br>                    &#125; <br>        &#125;<br>         <span class="hljs-keyword">return</span> a;     <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span>[] resNums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        Map&lt;Integer,Integer&gt; resMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> target - nums[i];<br>            <span class="hljs-keyword">if</span>(resMap.containsKey(tmp))&#123;<br>                resNums[<span class="hljs-number">0</span>] = i;<br>                resNums[<span class="hljs-number">1</span>] = resMap.get(tmp);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            resMap.put(nums[i],i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> resNums;<br>    &#125;<br>&#125;<br>  <br></code></pre></td></tr></table></figure><h2 id="第454题-四数相加II"><a href="#第454题-四数相加II" class="headerlink" title="第454题.四数相加II"></a>第454题.四数相加II</h2><p><a href="https://leetcode.cn/problems/4sum-ii/">力扣题目链接(opens new window)</a></p><p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。</p><p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。</p><p><strong>例如:</strong></p><p>输入:</p><ul><li>A = [ 1, 2]</li><li>B = [-2,-1]</li><li>C = [-1, 2]</li><li>D = [ 0, 2]</li></ul><p>输出:</p><p>2</p><p><strong>解释:</strong></p><p>两个元组如下:</p><ol><li>(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</li><li>(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</li></ol><p><strong>思路</strong></p><p><strong>本题是使用哈希法的经典题目，而<a href="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html">0015.三数之和 (opens new window)</a>，<a href="https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html">0018.四数之和 (opens new window)</a>并不合适使用哈希法</strong>，因为三数之和和四数之和这两道题目使用哈希法在不超时的情况下做到对结果去重是很困难的，很有多细节需要处理。</p><p><strong>而这道题目是四个独立的数组，只要找到A[i] + B[j] + C[k] + D[l] = 0就可以，不用考虑有重复的四个元素相加等于0的情况，所以相对于题目18. 四数之和，题目15.三数之和，还是简单了不少！</strong></p><p>如果本题想难度升级：就是给出一个数组（而不是四个数组），在这里找出四个元素相加等于0，答案中不可以包含重复的四元组，大家可以思考一下，后续的文章我也会讲到的。</p><p>本题解题步骤：</p><ol><li>首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。</li><li>遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。</li><li>定义int变量count，用来统计 a+b+c+d = 0 出现的次数。</li><li>在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。</li><li>最后返回统计值 count 就可以了</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fourSumCount</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span>[] nums3, <span class="hljs-type">int</span>[] nums4)</span> &#123;<br>        <span class="hljs-comment">// 拆分前两数之和，后两数之和配对</span><br>        Map&lt;Integer, Integer&gt; tmpMap =<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums1.length; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums2.length; j++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums1[i] + nums2[j];<br>                <span class="hljs-keyword">if</span>(tmpMap.containsKey(tmp))&#123;<br>                    tmpMap.put(tmp,tmpMap.get(tmp)+<span class="hljs-number">1</span>);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    tmpMap.put(tmp,<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums3.length; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums4.length; j++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums3[i] + nums4[j];<br>                <span class="hljs-keyword">if</span>(tmpMap.containsKey(<span class="hljs-number">0</span>-tmp))&#123;<br>                   res+= tmpMap.get(<span class="hljs-number">0</span>-tmp);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h2><p><a href="https://leetcode.cn/problems/ransom-note/">力扣题目链接(opens new window)</a></p><p>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。</p><p>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)</p><p><strong>注意：</strong></p><p>你可以假设两个字符串均只含有小写字母。</p><p>canConstruct(“a”, “b”) -&gt; false<br>canConstruct(“aa”, “ab”) -&gt; false<br>canConstruct(“aa”, “aab”) -&gt; true</p><p><strong>思路</strong></p><p>本题判断第一个字符串ransom能不能由第二个字符串magazines里面的字符构成，但是这里需要注意两点。</p><ul><li>第一点“为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思” 这里<em>说明杂志里面的字母不可重复使用。</em></li><li>第二点 “你可以假设两个字符串均只含有小写字母。” <em>说明只有小写字母</em>，这一点很重要</li></ul><p>这里时间复杂度是比较高的，而且里面还有一个字符串删除也就是erase的操作，也是费时的，当然这段代码也可以过这道题。</p><p><strong>哈希解法</strong></p><p>因为题目所只有小写字母，那可以采用空间换取时间的哈希策略， 用一个长度为26的数组还记录magazine里字母出现的次数。</p><p>然后再用ransomNote去验证这个数组是否包含了ransomNote所需要的所有字母。</p><p>依然是数组在哈希法中的应用。</p><p>一些同学可能想，用数组干啥，都用map完事了，<strong>其实在本题的情况下，使用map的空间消耗要比数组大一些的，因为map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的！数据量大的话就能体现出来差别了。 所以数组更加简单直接有效！</strong></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230406162250768.png" alt="image-20230406162250768"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canConstruct</span><span class="hljs-params">(String ransomNote, String magazine)</span> &#123;<br>        <span class="hljs-keyword">if</span>(ransomNote.length()&gt;magazine.length())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 定义一个哈希映射数组</span><br>        <span class="hljs-type">int</span>[] record = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br><br>        <span class="hljs-comment">// 遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : magazine.toCharArray())&#123;<br>            record[c - <span class="hljs-string">&#x27;a&#x27;</span>] += <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : ransomNote.toCharArray())&#123;<br>            record[c - <span class="hljs-string">&#x27;a&#x27;</span>] -= <span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 如果数组中存在负数，说明ransomNote字符串总存在magazine中没有的字符</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : record)&#123;<br>            <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第15题-三数之和"><a href="#第15题-三数之和" class="headerlink" title="***第15题. 三数之和"></a>***第15题. 三数之和</h2><p><a href="https://leetcode.cn/problems/3sum/">力扣题目链接(opens new window)</a></p><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p><p><strong>注意：</strong> 答案中不可以包含重复的三元组。</p><p>示例：</p><p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p><p>满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]</p><p><strong>思路</strong></p><p>针对本题，我录制了视频讲解：<a href="https://www.bilibili.com/video/BV1GW4y127qo">梦破碎的地方！| LeetCode：15.三数之和 (opens new window)</a>，结合本题解一起看，事半功倍！</p><p><strong>注意[0， 0， 0， 0] 这组数据</strong></p><p><strong>哈希解法</strong></p><p>两层for循环就可以确定 a 和b 的数值了，可以使用哈希法来确定 0-(a+b) 是否在 数组里出现过，其实这个思路是正确的，但是我们有一个非常棘手的问题，就是题目中说的不可以包含重复的三元组。</p><p>把符合条件的三元组放进vector中，然后再去重，这样是非常费时的，很容易超时，也是这道题目通过率如此之低的根源所在。</p><p>去重的过程不好处理，有很多小细节，如果在面试中很难想到位。</p><p>时间复杂度可以做到O(n^2)，但还是比较费时的，因为不好做剪枝操作。</p><p>大家可以尝试使用哈希法写一写，就知道其困难的程度了。</p><p><strong>双指针</strong></p><p><strong>其实这道题目使用哈希法并不十分合适</strong>，因为在去重的操作中有很多细节需要注意，在面试中很难直接写出没有bug的代码。</p><p>而且使用哈希法 在使用两层for循环的时候，能做的剪枝操作很有限，虽然时间复杂度是O(n^2)，也是可以在leetcode上通过，但是程序的执行时间依然比较长 。</p><p>接下来我来介绍另一个解法：双指针法，<strong>这道题目使用双指针法 要比哈希法高效一些</strong>，那么来讲解一下具体实现的思路。</p><p>动画效果如下：<img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/15.sum3num.gif" alt="15.sum3num"></p><p>拿这个nums数组来举例，首先将数组排序，然后有一层for循环，i从下标0的地方开始，同时定一个下标left 定义在i+1的位置上，定义下标right 在数组结尾的位置上。</p><p>依然还是在数组中找到 abc 使得a + b +c =0，我们这里相当于 a = nums[i]，b = nums[left]，c = nums[right]。</p><p>接下来如何移动left 和right呢， 如果nums[i] + nums[left] + nums[right] &gt; 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。</p><p>如果 nums[i] + nums[left] + nums[right] &lt; 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。</p><p>时间复杂度：O(n^2)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Arrays.sort(nums);<br>        <span class="hljs-comment">//   -3  -2  -1   0   1   3   4</span><br>        <span class="hljs-comment">//    i left                 right</span><br>       <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&gt;<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br>            <span class="hljs-comment">// i去重</span><br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i-<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length-<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[i] +nums[left] +nums[right];<br>                <span class="hljs-keyword">if</span>(sum &gt; <span class="hljs-number">0</span>)&#123;<br>                    right--;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum&lt;<span class="hljs-number">0</span>)&#123;<br>                    left++;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    res.add(Arrays.asList(nums[i], nums[left], nums[right]));<br>                    <span class="hljs-comment">// 去重right &gt; left 保证不越界！</span><br>                    <span class="hljs-keyword">while</span>(right &gt; left &amp;&amp; nums[left] == nums[left+<span class="hljs-number">1</span>])&#123;left++;&#125;<br>                    <span class="hljs-keyword">while</span>(right &gt; left &amp;&amp; nums[right] == nums[right-<span class="hljs-number">1</span>])&#123;right--;&#125;<br>                    left++;<br>                    right--;<br>                &#125;<br><br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>去重逻辑的思考</strong></p><p><strong>a的去重</strong></p><p>说道去重，其实主要考虑三个数的去重。 a, b ,c, 对应的就是 nums[i]，nums[left]，nums[right]</p><p>a 如果重复了怎么办，a是nums里遍历的元素，那么应该直接跳过去。</p><p>但这里有一个问题，是判断 nums[i] 与 nums[i + 1]是否相同，还是判断 nums[i] 与 nums[i-1] 是否相同。</p><p>有同学可能想，这不都一样吗。</p><p>其实不一样！</p><p>都是和 nums[i]进行比较，是比较它的前一个，还是比较他的后一个。</p><p>如果我们的写法是 这样：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">if (nums[i] == nums[i + 1]) &#123; // 去重操作<br>    continue;<br>&#125;<br></code></pre></td></tr></table></figure><p>那就我们就把 三元组中出现重复元素的情况直接pass掉了。 例如{-1, -1 ,2} 这组数据，当遍历到第一个-1 的时候，判断 下一个也是-1，那这组数据就pass了。</p><p><strong>我们要做的是 不能有重复的三元组，但三元组内的元素是可以重复的！</strong></p><p>所以这里是有两个重复的维度。</p><p>那么应该这么写：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;<br>    continue;<br>&#125;<br></code></pre></td></tr></table></figure><p>这么写就是当前使用 nums[i]，我们判断前一位是不是一样的元素，在看 {-1, -1 ,2} 这组数据，当遍历到 第一个 -1 的时候，只要前一位没有-1，那么 {-1, -1 ,2} 这组数据一样可以收录到 结果集里。</p><p>这是一个非常细节的思考过程。</p><p><strong>b与c的去重</strong></p><p>很多同学写本题的时候，去重的逻辑多加了 对right 和left 的去重：（代码中注释部分）</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">while (right &gt; left) &#123;<br>    if (nums[i] + nums[left] + nums[right] &gt; 0) &#123;<br>        right--;<br>        // 去重 right<br>        while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) right--;<br>    &#125; else if (nums[i] + nums[left] + nums[right] &lt; 0) &#123;<br>        left++;<br>        // 去重 left<br>        while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) left++;<br>    &#125; else &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但细想一下，这种去重其实对提升程序运行效率是没有帮助的。</p><p>拿right去重为例，即使不加这个去重逻辑，依然根据 <code>while (right &gt; left)</code> 和 <code>if (nums[i] + nums[left] + nums[right] &gt; 0)</code> 去完成right– 的操作。</p><p>多加了 <code>while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) right--;</code> 这一行代码，其实就是把 需要执行的逻辑提前执行了，但并没有减少 判断的逻辑。</p><p>最直白的思考过程，就是right还是一个数一个数的减下去的，所以在哪里减的都是一样的。</p><p>所以这种去重 是可以不加的。 仅仅是 把去重的逻辑提前了而已。</p><p><strong>思考题</strong></p><p>既然三数之和可以使用双指针法，我们之前讲过的<a href="https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html">1.两数之和 (opens new window)</a>，可不可以使用双指针法呢？</p><p>如果不能，题意如何更改就可以使用双指针法呢？ <strong>大家留言说出自己的想法吧！</strong></p><p>两数之和 就不能使用双指针法，因为<a href="https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html">1.两数之和 (opens new window)</a>要求返回的是索引下标， 而双指针法一定要排序，一旦排序之后原数组的索引就被改变了。</p><p>如果<a href="https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html">1.两数之和 (opens new window)</a>要求返回的是数值的话，就可以使用双指针法了。</p><h2 id="第18题-四数之和"><a href="#第18题-四数之和" class="headerlink" title="***第18题. 四数之和"></a>***第18题. 四数之和</h2><p><a href="https://leetcode.cn/problems/4sum/">力扣题目链接(opens new window)</a></p><p>题意：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p><p><strong>注意：</strong></p><p>答案中不可以包含重复的四元组。</p><p>示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]</p><p><strong>思路</strong></p><p>针对本题，我录制了视频讲解：<a href="https://www.bilibili.com/video/BV1DS4y147US">难在去重和剪枝！| LeetCode：18. 四数之和 (opens new window)</a>，结合本题解一起看，事半功倍！</p><p>四数之和，和<a href="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html">15.三数之和 (opens new window)</a>是一个思路，都是使用双指针法, 基本解法就是在<a href="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html">15.三数之和 (opens new window)</a>的基础上再套一层for循环。</p><p>但是有一些细节需要注意，例如： 不要判断<code>nums[k] &gt; target</code> 就返回了，三数之和 可以通过 <code>nums[i] &gt; 0</code> 就返回了，因为 0 已经是确定的数了，四数之和这道题目 target是任意值。比如：数组是<code>[-4, -3, -2, -1]</code>，<code>target</code>是<code>-10</code>，不能因为<code>-4 &gt; -10</code>而跳过。但是我们依旧可以去做剪枝，逻辑变成<code>nums[i] &gt; target &amp;&amp; (nums[i] &gt;=0 || target &gt;= 0)</code>就可以了。</p><p><a href="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html">15.三数之和 (opens new window)</a>的双指针解法是一层for循环num[i]为确定值，然后循环内有left和right下标作为双指针，找到nums[i] + nums[left] + nums[right] == 0。</p><p>四数之和的双指针解法是两层for循环nums[k] + nums[i]为确定值，依然是循环内有left和right下标作为双指针，找出nums[k] + nums[i] + nums[left] + nums[right] == target的情况，三数之和的时间复杂度是O(n^2)，四数之和的时间复杂度是O(n^3) 。</p><p>那么一样的道理，五数之和、六数之和等等都采用这种解法。</p><p>对于<a href="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html">15.三数之和 (opens new window)</a>双指针法就是将原本暴力O(n^3)的解法，降为O(n^2)的解法，四数之和的双指针解法就是将原本暴力O(n^4)的解法，降为O(n^3)的解法。</p><p>之前我们讲过哈希表的经典题目：<a href="https://programmercarl.com/0454.%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II.html">454.四数相加II (opens new window)</a>，相对于本题简单很多，因为本题是要求在一个集合中找出四个数相加等于target，同时四元组不能重复。</p><p>而<a href="https://programmercarl.com/0454.%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II.html">454.四数相加II (opens new window)</a>是四个独立的数组，只要找到A[i] + B[j] + C[k] + D[l] = 0就可以，不用考虑有重复的四个元素相加等于0的情况，所以相对于本题还是简单了不少！</p><p>我们来回顾一下，几道题目使用了双指针法。</p><p>双指针法将时间复杂度：O(n^2)的解法优化为 O(n)的解法。也就是降一个数量级，题目如下：</p><ul><li><a href="https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html">27.移除元素(opens new window)</a></li><li><a href="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html">15.三数之和(opens new window)</a></li><li><a href="https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html">18.四数之和(opens new window)</a></li></ul><p>链表相关双指针题目：</p><ul><li><a href="https://programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html">206.反转链表(opens new window)</a></li><li><a href="https://programmercarl.com/0019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html">19.删除链表的倒数第N个节点(opens new window)</a></li><li><a href="https://programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html">面试题 02.07. 链表相交(opens new window)</a></li><li><a href="https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html">142题.环形链表II(opens new window)</a></li></ul><p>双指针法在字符串题目中还有很多应用，后面还会介绍到。</p><p><strong>补充</strong></p><p>二级剪枝的部分：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">if (nums[k] + nums[i] &gt; target &amp;&amp; nums[k] + nums[i] &gt;= 0) &#123;<br>    break;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以优化为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">if (nums[k] + nums[i] &gt; target &amp;&amp; nums[i] &gt;= 0) &#123;<br>    break;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为只要 nums[k] + nums[i] &gt; target，那么 nums[i] 后面的数都是正数的话，就一定 不符合条件了。</p><p>不过这种剪枝 其实有点 小绕，大家能够理解 文章给的完整代码的剪枝 就够了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">fourSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Arrays.sort(nums);<br>       <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br><br>            <span class="hljs-comment">// nums[i] &gt; target 直接返回, 剪枝操作</span><br>            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt; target) &#123;<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i - <span class="hljs-number">1</span>] == nums[i]) &#123;    <span class="hljs-comment">// 对nums[i]去重</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; nums.length; j++) &#123;<br><br>                <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j - <span class="hljs-number">1</span>] == nums[j]) &#123;  <span class="hljs-comment">// 对nums[j]去重</span><br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> j + <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span> (right &gt; left) &#123;<br>    <span class="hljs-comment">// nums[k] + nums[i] + nums[left] + nums[right] &gt; target int会溢出</span><br>                    <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>) nums[i] + nums[j] + nums[left] + nums[right];<br>                    <span class="hljs-keyword">if</span> (sum &gt; target) &#123;<br>                        right--;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) &#123;<br>                        left++;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));<br>                        <span class="hljs-comment">// 对nums[left]和nums[right]去重</span><br>                        <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right--;<br>                        <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) left++;<br><br>                        left++;<br>                        right--;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h3><p><a href="https://leetcode.cn/problems/reverse-string/">力扣题目链接(opens new window)</a></p><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><p>示例 1：<br>输入：[“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]</p><p>示例 2：<br>输入：[“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseString</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s)</span> &#123;<br>        <span class="hljs-type">char</span> tmp;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=s.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;j)&#123;<br>            tmp = s[i];<br>            s[i++]=s[j];<br>            s[j--]=tmp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//位异或</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseString</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s)</span> &#123;<br>        <span class="hljs-type">char</span> tmp;<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=s.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            s[l] ^= s[r];  <span class="hljs-comment">//构造 a ^ b 的结果，并放在 a 中</span><br>            s[r] ^= s[l];  <span class="hljs-comment">//将 a ^ b 这一结果再 ^ b ，存入b中，此时 b = a, a = a ^ b</span><br>            s[l] ^= s[r];  <span class="hljs-comment">//a ^ b 的结果再 ^ a ，存入 a 中，此时 b = a, a = b 完成交换</span><br>            l++;<br>            r--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="541-反转字符串II"><a href="#541-反转字符串II" class="headerlink" title="541. 反转字符串II"></a>541. 反转字符串II</h3><p><a href="https://leetcode.cn/problems/reverse-string-ii/">力扣题目链接(opens new window)</a></p><p>给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。</p><p>如果剩余字符少于 k 个，则将剩余字符全部反转。</p><p>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p><p>示例:</p><p>输入: s = “abcdefg”, k = 2<br>输出: “bacdfeg”</p><p><strong>思路</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseStr</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">// a  b  c  d  e  f  g  h  i</span><br>        <span class="hljs-comment">// 0     k      2k-1 2k</span><br>        <br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i+=<span class="hljs-number">2</span>*k)&#123;<br>            <span class="hljs-comment">// reverse()是StringBuilder()的方法</span><br>            <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>            tmp.append(s.substring(i,((i+k &lt; s.length())? i+k : s.length()))).reverse();<br>            res.append(tmp) ;<br>            <span class="hljs-keyword">if</span>(i+k&lt; s.length())&#123;<br>                res.append(s.substring(i+k,((i+<span class="hljs-number">2</span>*k &lt; s.length() ) ? i+<span class="hljs-number">2</span>*k : s.length())));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.toString();<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseStr</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">char</span>[] ch = s.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ch.length; i += <span class="hljs-number">2</span> * k)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-comment">//这里是判断尾数够不够k个来取决end指针的位置</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> (ch.length - <span class="hljs-number">1</span>&gt; start + k - <span class="hljs-number">1</span>)?start + k - <span class="hljs-number">1</span>:ch.length - <span class="hljs-number">1</span> ;<br>            <span class="hljs-comment">//用异或运算反转 </span><br>            <span class="hljs-keyword">while</span>(start &lt; end)&#123;<br>                ch[start] ^= ch[end];<br>                ch[end] ^= ch[start];<br>                ch[start] ^= ch[end];<br>                start++;<br>                end--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(ch);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题目：剑指Offer-05-替换空格"><a href="#题目：剑指Offer-05-替换空格" class="headerlink" title="题目：剑指Offer 05.替换空格"></a>题目：剑指Offer 05.替换空格</h2><p><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">力扣题目链接(opens new window)</a></p><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p>示例 1： 输入：s = “We are happy.”<br>输出：”We%20are%20happy.”</p><p><strong>思路</strong></p><p>如果想把这道题目做到极致，就不要只用额外的辅助空间了！</p><p>首先扩充数组到每个空格替换成”%20”之后的大小。</p><p>然后从后向前替换空格，也就是双指针法，过程如下：</p><p>i指向新长度的末尾，j指向旧长度的末尾。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/replaceBlank.gif" alt="replaceBlank"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-comment">//使用一个新的对象，复制 str，复制的过程对其判断，是空格则替换，否则直接复制，类似于数组复制</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">replaceSpace</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//选用 StringBuilder 单线程使用，比较快，选不选都行</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-comment">//使用 sb 逐个复制 s ，碰到空格则替换，否则直接复制</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-comment">//s.charAt(i) 为 char 类型，为了比较需要将其转为和 &quot; &quot; 相同的字符串类型</span><br>            <span class="hljs-comment">//if (&quot; &quot;.equals(String.valueOf(s.charAt(i))))&#123;&#125;</span><br>            <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                sb.append(<span class="hljs-string">&quot;%20&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                sb.append(s.charAt(i));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方式二：双指针法</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceSpace</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-keyword">if</span>(s == <span class="hljs-literal">null</span> || s.length() == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>    <span class="hljs-comment">//扩充空间，空格数量2倍</span><br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>        <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>            str.append(<span class="hljs-string">&quot;  &quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//若是没有空格直接返回</span><br>    <span class="hljs-keyword">if</span>(str.length() == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>    <span class="hljs-comment">//有空格情况 定义两个指针</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> s.length() - <span class="hljs-number">1</span>;<span class="hljs-comment">//左指针：指向原始字符串最后一个位置</span><br>    s += str.toString();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> s.length()-<span class="hljs-number">1</span>;<span class="hljs-comment">//右指针：指向扩展字符串的最后一个位置</span><br>    <span class="hljs-type">char</span>[] chars = s.toCharArray();<br>    <span class="hljs-keyword">while</span>(left&gt;=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(chars[left] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>            chars[right--] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>            chars[right--] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>            chars[right] = <span class="hljs-string">&#x27;%&#x27;</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            chars[right] = chars[left];<br>        &#125;<br>        left--;<br>        right--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151.翻转字符串里的单词"></a>151.翻转字符串里的单词</h2><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">力扣题目链接(opens new window)</a></p><p>给定一个字符串，逐个翻转字符串中的每个单词。</p><p>示例 1：<br>输入: “the sky is blue”<br>输出: “blue is sky the”</p><p>示例 2：<br>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p><p>示例 3：<br>输入: “a good  example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230411095851122.png" alt="image-20230411095851122"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">trim</span> <span class="hljs-operator">=</span> s.trim();<br>        String[] Strings = trim.split( <span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Strings.length -<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(Strings[i].equals(<span class="hljs-string">&quot;&quot;</span>)) <br>                <span class="hljs-keyword">continue</span>;<br>            res =  res.append((Strings[i])).append(<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.toString().trim();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题目：剑指Offer58-II-左旋转字符串"><a href="#题目：剑指Offer58-II-左旋转字符串" class="headerlink" title="题目：剑指Offer58-II.左旋转字符串"></a>题目：剑指Offer58-II.左旋转字符串</h2><p><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">力扣题目链接(opens new window)</a></p><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p><p>示例 1：<br>输入: s = “abcdefg”, k = 2<br>输出: “cdefgab”</p><p>示例 2：<br>输入: s = “lrloseumgh”, k = 6<br>输出: “umghlrlose”</p><p>限制：<br>1 &lt;= k &lt; s.length &lt;= 10000</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230411100921675.png" alt="image-20230411100921675"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseLeftWords</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        res.append(s.substring(n));<br>        <span class="hljs-keyword">return</span> res.append(s.substring(<span class="hljs-number">0</span>,n)).toString();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459.重复的子字符串"></a>459.重复的子字符串</h2><p><a href="https://leetcode.cn/problems/repeated-substring-pattern/">力扣题目链接(opens new window)</a></p><p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p><p>示例 1:<br>输入: “abab”<br>输出: True<br>解释: 可由子字符串 “ab” 重复两次构成。</p><p>示例 2:<br>输入: “aba”<br>输出: False</p><p>示例 3:<br>输入: “abcabcabcabc”<br>输出: True<br>解释: 可由子字符串 “abc” 重复四次构成。 (或者子字符串 “abcabc” 重复两次构成。)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>     <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">repeatedSubstringPattern</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> s+s;<br>        str = str.substring(<span class="hljs-number">1</span>,str.length() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> str.contains(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">repeatedSubstringPattern</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">return</span> s.matches(<span class="hljs-string">&quot;(\\w+)\\1+&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232.用栈实现队列"></a><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232.用栈实现队列</a></h2><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p><p>实现 <code>MyQueue</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li><li><code>int pop()</code> 从队列的开头移除并返回元素</li><li><code>int peek()</code> 返回队列开头的元素</li><li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li></ul><p><strong>说明：</strong></p><ul><li>你 <strong>只能</strong> 使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade">输入：<br>[<span class="hljs-string">&quot;MyQueue&quot;</span>, <span class="hljs-string">&quot;push&quot;</span>, <span class="hljs-string">&quot;push&quot;</span>, <span class="hljs-string">&quot;peek&quot;</span>, <span class="hljs-string">&quot;pop&quot;</span>, <span class="hljs-string">&quot;empty&quot;</span>]<br>[[], [<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], [], [], []]<br>输出：<br>[<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>]<br><br>解释：<br>MyQueue myQueue = <span class="hljs-keyword">new</span> MyQueue();<br>myQueue.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// queue is: [1]</span><br>myQueue.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// queue is: [1, 2] (leftmost is front of the queue)</span><br>myQueue.peek(); <span class="hljs-comment">// return 1</span><br>myQueue.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// return 1, queue is [2]</span><br>myQueue.empty(); <span class="hljs-comment">// return false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= x &lt;= 9</code></li><li>最多调用 <code>100</code> 次 <code>push</code>、<code>pop</code>、<code>peek</code> 和 <code>empty</code></li><li>假设所有操作都是有效的 （例如，一个空的队列不会调用 <code>pop</code> 或者 <code>peek</code> 操作）</li></ul><p><strong>进阶：</strong></p><ul><li>你能否实现每个操作均摊时间复杂度为 <code>O(1)</code> 的队列？换句话说，执行 <code>n</code> 个操作的总时间复杂度为 <code>O(n)</code> ，即使其中一个操作可能花费较长时间。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//用LinkedList模拟栈</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span>&#123;<br>LinkedList&lt;Integer&gt; myQueueIn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>LinkedList&lt;Integer&gt; myQueueOut = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br>myQueueIn.addFirst(x);<br>&#125;<br><span class="hljs-comment">//如果myQueueOut为空再放</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span>&#123;<br>dumpstackIn();<br><span class="hljs-keyword">return</span> myQueueOut.removeFirst();<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span>&#123;<br>dumpstackIn();<br><span class="hljs-keyword">return</span> myQueueOut.getFirst();<br>&#125;<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> myQueueOut.isEmpty() &amp;&amp; myQueueIn.isEmpty();<br>&#125;<br><span class="hljs-comment">// 如果stackOut为空，那么将stackIn中的元素全部放到stackOut中,重点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dumpstackIn</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span>(!myQueueOut.isEmpty()) <span class="hljs-keyword">return</span>;<br>            <span class="hljs-keyword">while</span>(!myQueueIn.isEmpty())&#123;<br>                myQueueOut.addFirst(myQueueIn.removeFirst());<br>            &#125;<br>&#125;<br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyQueue obj = new MyQueue();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * int param_2 = obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.peek();</span><br><span class="hljs-comment"> * boolean param_4 = obj.empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br><br>    Stack&lt;Integer&gt; stackIn;<br>    Stack&lt;Integer&gt; stackOut;<br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyQueue</span><span class="hljs-params">()</span> &#123;<br>        stackIn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;(); <span class="hljs-comment">// 负责进栈</span><br>        stackOut = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;(); <span class="hljs-comment">// 负责出栈</span><br>    &#125;<br>    <br>    <span class="hljs-comment">/** Push element x to the back of queue. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        stackIn.push(x);<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Removes the element from in front of queue and returns that element. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;    <br>        dumpstackIn();<br>        <span class="hljs-keyword">return</span> stackOut.pop();<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Get the front element. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        dumpstackIn();<br>        <span class="hljs-keyword">return</span> stackOut.peek();<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns whether the queue is empty. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> stackIn.isEmpty() &amp;&amp; stackOut.isEmpty();<br>    &#125;<br><br>    <span class="hljs-comment">// 如果stackOut为空，那么将stackIn中的元素全部放到stackOut中</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dumpstackIn</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span> (!stackOut.isEmpty()) <span class="hljs-keyword">return</span>; <br>        <span class="hljs-keyword">while</span> (!stackIn.isEmpty())&#123;<br>                stackOut.push(stackIn.pop());<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225.用队列实现栈"></a><a href="https://leetcode.cn/problems/implement-stack-using-queues/">225.用队列实现栈</a></h2><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）。</p><p>实现 <code>MyStack</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 压入栈顶。</li><li><code>int pop()</code> 移除并返回栈顶元素。</li><li><code>int top()</code> 返回栈顶元素。</li><li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><p><strong>注意：</strong></p><ul><li>你只能使用队列的基本操作 —— 也就是 <code>push to back</code>、<code>peek/pop from front</code>、<code>size</code> 和 <code>is empty</code> 这些操作。</li><li>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li></ul><p><strong>示例：</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade">输入：<br>[<span class="hljs-string">&quot;MyStack&quot;</span>, <span class="hljs-string">&quot;push&quot;</span>, <span class="hljs-string">&quot;push&quot;</span>, <span class="hljs-string">&quot;top&quot;</span>, <span class="hljs-string">&quot;pop&quot;</span>, <span class="hljs-string">&quot;empty&quot;</span>]<br>[[], [<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], [], [], []]<br>输出：<br>[<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">false</span>]<br><br>解释：<br>MyStack myStack = <span class="hljs-keyword">new</span> MyStack();<br>myStack.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>myStack.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>myStack.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 返回 2</span><br>myStack.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 返回 2</span><br>myStack.empty(); <span class="hljs-comment">// 返回 False</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= x &lt;= 9</code></li><li>最多调用<code>100</code> 次 <code>push</code>、<code>pop</code>、<code>top</code> 和 <code>empty</code></li><li>每次调用 <code>pop</code> 和 <code>top</code> 都保证栈不为空</li></ul><p><strong>进阶：</strong>你能否仅用一个队列来实现栈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br>    <span class="hljs-comment">//只能用addLast,removeFirst,getFirst,</span><br>LinkedList&lt;Integer&gt; MyStackIn;<br>    LinkedList&lt;Integer&gt; MyStackOut;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyStack</span><span class="hljs-params">()</span> &#123;<br>MyStackIn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        MyStackOut = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>MyStackIn.addLast(x);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>moveIn2Out();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> MyStackIn.removeFirst();<br>        moveOut2In();<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>moveIn2Out();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> MyStackIn.getFirst();<br>        moveOut2In();<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> MyStackIn.isEmpty() &amp;&amp; MyStackOut.isEmpty();<br><br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveIn2Out</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//留一个元素</span><br>        <span class="hljs-keyword">while</span>(MyStackIn.size() != <span class="hljs-number">1</span> &amp;&amp; !MyStackIn.isEmpty())&#123;<br>            MyStackOut.addLast(MyStackIn.removeFirst());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveOut2In</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//将MyStackIn中剩下的一个元素移到MyStackOut</span><br>        <span class="hljs-keyword">if</span>(!MyStackIn.isEmpty())&#123;<br>            MyStackOut.addLast(MyStackIn.removeFirst());<br>        &#125;<br>         <span class="hljs-comment">//将MyStackOut中元素移到MyStackIn</span><br>        <span class="hljs-keyword">while</span>(!MyStackOut.isEmpty())&#123;<br>            MyStackIn.addLast(MyStackOut.removeFirst());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br><br>    Queue&lt;Integer&gt; queue1; <span class="hljs-comment">// 和栈中保持一样元素的队列</span><br>    Queue&lt;Integer&gt; queue2; <span class="hljs-comment">// 辅助队列</span><br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyStack</span><span class="hljs-params">()</span> &#123;<br>        queue1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Push element x onto stack. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        queue2.offer(x); <span class="hljs-comment">// 先放在辅助队列中</span><br>        <span class="hljs-keyword">while</span> (!queue1.isEmpty())&#123;<br>            queue2.offer(queue1.poll());<br>        &#125;<br>        Queue&lt;Integer&gt; queueTemp;<br>        queueTemp = queue1;<br>        queue1 = queue2;<br>        queue2 = queueTemp; <span class="hljs-comment">// 最后交换queue1和queue2，将元素都放到queue1中</span><br>    &#125;<br>    <br>    <span class="hljs-comment">/** Removes the element on top of the stack and returns that element. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queue1.poll(); <span class="hljs-comment">// 因为queue1中的元素和栈中的保持一致，所以这个和下面两个的操作只看queue1即可</span><br>    &#125;<br>    <br>    <span class="hljs-comment">/** Get the top element. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queue1.peek();<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns whether the stack is empty. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queue1.isEmpty();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a><a href="https://leetcode.cn/problems/valid-parentheses/">20.有效的括号</a></h2><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;()&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;()[]&#123;&#125;&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;(]&quot;</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>        LinkedList&lt;Character&gt; sStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Character&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-keyword">switch</span> (s.charAt(i))&#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:&#123;<br>                    sStack.push(<span class="hljs-string">&#x27;)&#x27;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#123;&#x27;</span>:&#123;<br>                    sStack.push(<span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;[&#x27;</span>:&#123;<br>                    sStack.push(<span class="hljs-string">&#x27;]&#x27;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">default</span>:&#123;<br>                    <span class="hljs-keyword">if</span>(sStack.isEmpty())&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br>                    <span class="hljs-keyword">if</span>(s.charAt(i)==sStack.pop())&#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!sStack.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150.逆波兰表达式求值"></a><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/?orderBy=oldest_to_newest&languageTags=java">150.逆波兰表达式求值</a></h2><p>相关企业</p><p>给你一个字符串数组 <code>tokens</code> ，表示一个根据 <a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437">逆波兰表示法</a> 表示的算术表达式。</p><p>请你计算该表达式。返回一个表示表达式值的整数。</p><p><strong>注意：</strong></p><ul><li>有效的算符为 <code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;*&#39;</code> 和 <code>&#39;/&#39;</code> 。</li><li>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</li><li>两个整数之间的除法总是 <strong>向零截断</strong> 。</li><li>表达式中不含除零运算。</li><li>输入是一个根据逆波兰表示法表示的算术表达式。</li><li>答案及所有中间计算结果可以用 <strong>32 位</strong> 整数表示。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">输入：<span class="hljs-built_in">tokens</span> = [<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;+&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;*&quot;</span>]<br>输出：<span class="hljs-number">9</span><br>解释：该算式转化为常见的中缀算术表达式为：((<span class="hljs-number">2</span> + <span class="hljs-number">1</span>) * <span class="hljs-number">3</span>) = <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">输入：<span class="hljs-built_in">tokens</span> = [<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;13&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;/&quot;</span>,<span class="hljs-string">&quot;+&quot;</span>]<br>输出：<span class="hljs-number">6</span><br>解释：该算式转化为常见的中缀算术表达式为：(<span class="hljs-number">4</span> + (<span class="hljs-number">13</span> / <span class="hljs-number">5</span>)) = <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：tokens = [<span class="hljs-string">&quot;10&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;+&quot;</span>,<span class="hljs-string">&quot;-11&quot;</span>,<span class="hljs-string">&quot;*&quot;</span>,<span class="hljs-string">&quot;/&quot;</span>,<span class="hljs-string">&quot;*&quot;</span>,<span class="hljs-string">&quot;17&quot;</span>,<span class="hljs-string">&quot;+&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;+&quot;</span>]<br>输出：<span class="hljs-number">22</span><br>解释：该算式转化为常见的中缀算术表达式为：<br>  ((<span class="hljs-number">10</span> * (<span class="hljs-number">6</span> / ((<span class="hljs-number">9</span> + <span class="hljs-number">3</span>) * -<span class="hljs-number">11</span>))) + <span class="hljs-number">17</span>) + <span class="hljs-number">5</span><br>= ((<span class="hljs-number">10</span> * (<span class="hljs-number">6</span> / (<span class="hljs-number">12</span> * -<span class="hljs-number">11</span>))) + <span class="hljs-number">17</span>) + <span class="hljs-number">5</span><br>= ((<span class="hljs-number">10</span> * (<span class="hljs-number">6</span> / -<span class="hljs-number">132</span>)) + <span class="hljs-number">17</span>) + <span class="hljs-number">5</span><br>= ((<span class="hljs-number">10</span> * <span class="hljs-number">0</span>) + <span class="hljs-number">17</span>) + <span class="hljs-number">5</span><br>= (<span class="hljs-number">0</span> + <span class="hljs-number">17</span>) + <span class="hljs-number">5</span><br>= <span class="hljs-number">17</span> + <span class="hljs-number">5</span><br>= <span class="hljs-number">22</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= tokens.length &lt;= 104</code></li><li><code>tokens[i]</code> 是一个算符（<code>&quot;+&quot;</code>、<code>&quot;-&quot;</code>、<code>&quot;*&quot;</code> 或 <code>&quot;/&quot;</code>），或是在范围 <code>[-200, 200]</code> 内的一个整数</li></ul><p><strong>逆波兰表达式：</strong></p><p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p><ul><li>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</li><li>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</li></ul><p>逆波兰表达式主要有以下两个优点：</p><ul><li>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + * </code>也可以依据次序计算出正确结果。</li><li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">evalRPN</span><span class="hljs-params">(String[] tokens)</span> &#123;<br>        LinkedList&lt;Integer&gt; numStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; tokens.length; i++)&#123;<br>            <span class="hljs-keyword">switch</span>(tokens[i])&#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:&#123;<br>                    numStack.push(numStack.pop()+numStack.pop());<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:&#123;<br>                    numStack.push(-numStack.pop()+numStack.pop());<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:&#123;<br>                    numStack.push(numStack.pop()*numStack.pop());<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:&#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span>numStack.pop();<br>                    numStack.push(numStack.pop()/tmp);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">default</span>:&#123;<br>                    numStack.push(Integer.parseInt(tokens[i]));<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> numStack.poll();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">evalRPN</span><span class="hljs-params">(String[] tokens)</span> &#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>        <span class="hljs-keyword">for</span> (String s : tokens) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;+&quot;</span>.equals(s)) &#123;        <span class="hljs-comment">// leetcode 内置jdk的问题，不能使用==判断字符串是否相等</span><br>                stack.push(stack.pop() + stack.pop());      <span class="hljs-comment">// 注意 - 和/ 需要特殊处理</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;-&quot;</span>.equals(s)) &#123;<br>                stack.push(-stack.pop() + stack.pop());<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;*&quot;</span>.equals(s)) &#123;<br>                stack.push(stack.pop() * stack.pop());<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;/&quot;</span>.equals(s)) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp1</span> <span class="hljs-operator">=</span> stack.pop();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp2</span> <span class="hljs-operator">=</span> stack.pop();<br>                stack.push(temp2 / temp1);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stack.push(Integer.valueOf(s));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.pop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239.滑动窗口最大值"></a>239.<a href="https://leetcode.cn/problems/sliding-window-maximum/description/">滑动窗口最大值</a></h2><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回 <em>滑动窗口中的最大值</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,3,<span class="hljs-string">-1</span>,<span class="hljs-string">-3</span>,5,3,6,7], k = 3<br>输出：[3,3,5,5,6,7]<br>解释：<br>滑动窗口的位置                最大值<br>---------------               -----<br>[1  3  <span class="hljs-string">-1</span>] <span class="hljs-string">-3</span>  5  3  6  7       3<br> 1 [3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>] 5  3  6  7       3<br> 1  3 [<span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>  5] 3  6  7       5<br> 1  3  <span class="hljs-string">-1</span> [<span class="hljs-string">-3</span>  5  3] 6  7       5<br> 1  3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span> [5  3  6] 7       6<br> 1  3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>  5 [3  6  7]      7<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1]</span>, k = 1<br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>1 &lt;= k &lt;= nums.length</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span>&#123;<br>        LinkedList&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>&#123;<br>            <span class="hljs-keyword">if</span>(!queue.isEmpty() &amp;&amp; queue.peek()==value)&#123;<br>                queue.poll();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//后面元素优先级比前面高，只要后面有比前面大的，前面小的就没用了</span><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>&#123;<br>            <span class="hljs-keyword">while</span>(!queue.isEmpty() &amp;&amp; value &gt; queue.getLast())&#123;<br>                 queue.removeLast();<br>            &#125;<br>            queue.add(value);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span>&#123;<br>            <span class="hljs-keyword">return</span> queue.peek();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length - k + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//存放结果元素的数组</span><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">MyQueue</span> <span class="hljs-variable">myQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyQueue</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            myQueue.add(nums[i]);<br>        &#125;<br>        res[num++] = myQueue.peek();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">//滑动窗口移除最前面的元素，移除是判断该元素是否放入队列</span><br>            myQueue.poll(nums[i - k]);<br>            <span class="hljs-comment">//滑动窗口加入最后面的元素</span><br>            myQueue.add(nums[i]);<br>            <span class="hljs-comment">//记录对应的最大值</span><br>            res[num++] = myQueue.peek();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>  TreeNode left;<br>  TreeNode right;<br>  TreeNode() &#123;&#125;<br>  TreeNode(<span class="hljs-type">int</span> val) &#123; <span class="hljs-built_in">this</span>.val = val; &#125;<br>  TreeNode(<span class="hljs-type">int</span> val, TreeNode left, TreeNode right) &#123;<br>    <span class="hljs-built_in">this</span>.val = val;<br>    <span class="hljs-built_in">this</span>.left = left;<br>    <span class="hljs-built_in">this</span>.right = right;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二叉树递归遍历"><a href="#二叉树递归遍历" class="headerlink" title="二叉树递归遍历"></a>二叉树递归遍历</h2><p><strong>每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！</strong></p><ol><li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li><li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li><li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li></ol><ul><li><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144.二叉树的前序遍历(opens new window)</a></li><li><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145.二叉树的后序遍历(opens new window)</a></li><li><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94.二叉树的中序遍历</a></li></ul><p><strong>前序</strong>：中左右</p><p><strong>中序：</strong>左中右</p><p><strong>后续：</strong>左右中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 前序遍历·递归·LC144_二叉树的前序遍历</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        preorder(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preorder</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; result)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        result.add(root.val);<br>        preorder(root.left, result);<br>        preorder(root.right, result);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 中序遍历·递归·LC94_二叉树的中序遍历</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        inorder(root, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">inorder</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; list)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        inorder(root.left, list);<br>        list.add(root.val);             <span class="hljs-comment">// 注意这一句</span><br>        inorder(root.right, list);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 后序遍历·递归·LC145_二叉树的后序遍历</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        postorder(root, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">postorder</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; list)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        postorder(root.left, list);<br>        postorder(root.right, list);<br>        list.add(root.val);             <span class="hljs-comment">// 注意这一句</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JAVA学习</category>
      
      <category>算法数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java基础</title>
    <link href="/2023/03/20/JAVA%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/03/20/JAVA%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><h2 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h2><h6 id="跨平台，解释型"><a href="#跨平台，解释型" class="headerlink" title="跨平台，解释型"></a><strong>跨平台，解释型</strong></h6><p>所有变量、方法、类名：见名知义<br>类成员变量：首字母小写和驼峰原则：monthSalary<br>局部变量：首字母小写和驼峰原则<br>常量：大写字母和下划线：MAX _VALUE<br>类名：首字母大写和驼峰原则：Man,GoodMan<br>方法名：首字母小写和驼峰原则：runO,runRun(0</p><p>整数默认int类型: long a = 2L;</p><p>小数默认double：float a = 1.2F;</p><p>boolean：只能赋值true，false</p><h6 id="位运算："><a href="#位运算：" class="headerlink" title="位运算："></a><strong>位运算</strong>：</h6><p>1、&amp;和&amp;&amp;：与，短路与</p><p>2、|和||：或，短路或</p><h6 id="字符串连接符："><a href="#字符串连接符：" class="headerlink" title="字符串连接符：+"></a><strong>字符串连接符</strong>：+</h6><p>通过String，+变为字符串连接符。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220414191342707.png" alt="image-20220414191342707"></p><p>特例：整形常量为int，可自动转化为byte/short/char，前提为不越界</p><h6 id="方法：函数"><a href="#方法：函数" class="headerlink" title="方法：函数"></a><strong>方法</strong>：函数</h6><h6 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a><strong>内存管理</strong></h6><p>Java的内存管理很大程度就是：堆中对象的管理，其中包括对象空间的分配和释放。<br>对象空间的分配：使用new关键字创建对象即可<br>对象空间的释放：将对象赋值null即可。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220416144955468.png" alt="image-20220416144955468"></p><h6 id="JVM调优和Full-GC"><a href="#JVM调优和Full-GC" class="headerlink" title="JVM调优和Full GC"></a><strong>JVM调优和Full GC</strong></h6><p>在对JVM调优的过程中，很大一部分工作就是对于FuLL GC的调节。有如下原因可能</p><h6 id="导致Full-GC"><a href="#导致Full-GC" class="headerlink" title="导致Full GC:"></a><strong>导致Full GC:</strong></h6><p>1.年老代(Tenured)被写满<br>2.永久代(Perm)被写满<br>3.System.gc0\()被显式调用<br>4.上一次GC之后Heap的各域分配策略动态变化</p><h6 id="this"><a href="#this" class="headerlink" title="this"></a><strong>this</strong></h6><p>1、this()调用重载的构造方法，避免相同的初始化代码。但只能在构造方法中用，并且必须位于构造方法的第一句。</p><p>xzs();{}</p><p>xzs(int a){</p><p>this();//调用xzs();{}</p><p>this.a=a;</p><p>}</p><p>2、this不能用于static方法中。<br>3、this是作为普通方法的“隐式参数”，由系统传入到方法中。</p><h6 id="包机制package、import"><a href="#包机制package、import" class="headerlink" title="包机制package、import"></a><strong>包机制package、import</strong></h6><p>包(（package)相当于文件夹对于文件的作用。用于管理类、用于解决类的重名问题。</p><h6 id="package"><a href="#package" class="headerlink" title="package"></a><strong>package</strong></h6><p>package的使用有两个要点：<br>1.通常是类的第一句非注释性语句。<br>2.包名：域名倒着写即可，再加上模块名，便于内部管理类。com.xzs.aa</p><h6 id="导入类import"><a href="#导入类import" class="headerlink" title="导入类import"></a><strong>导入类import</strong></h6><p>如果要使用其他包的类，需使用import,从而在本类中直接通过类名来调用，否则就需要书写类的完整包名和类名。</p><p>import java.util.* //导入所有类，降低编译速度，不会降低运行速度</p><h6 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h6><p>extends</p><h6 id="组合"><a href="#组合" class="headerlink" title="组合"></a><strong>组合</strong></h6><p>在子类创建父类对象，使用父类属性</p><h6 id="super"><a href="#super" class="headerlink" title="super"></a><strong>super</strong></h6><p>调用父类方法，父类被覆盖了，但依然存在。</p><h6 id="静态代码块："><a href="#静态代码块：" class="headerlink" title="静态代码块："></a><strong>静态代码块</strong>：</h6><p>static{}；属于类，优先加载。一般用于初始化静态资源。比如扑克牌类：优先定义54张牌的静态集合。</p><h6 id="静态工具类："><a href="#静态工具类：" class="headerlink" title="静态工具类："></a><strong>静态工具类</strong>：</h6><p>使用static定义一系列方法，供大家使用，建议私有化，不用其创建对象。</p><h6 id="设计模式："><a href="#设计模式：" class="headerlink" title="设计模式："></a><strong>设计模式</strong>：</h6><p>开发中经常遇到一些问题，一个问题通常有种解法的，但其中肯定有一种解法是最优的，这个最优的解法被人总结出来了，称之为设计模式。</p><h6 id="单例模式："><a href="#单例模式：" class="headerlink" title="单例模式："></a><strong>单例模式</strong>：</h6><p>可以保证系统中，应用该模式的这个类永远只有一个实例，即一个类永远只能创建一个对象。<br>例如任务管理器对象我们只需要一个就可以解决问题了，这样可以节省内存空间。<strong>设计步骤：</strong>定义一个类，把构造器私有。定义一个静态变量存储一个对象。</p><p>`饿汉单例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleInstance</span>&#123;`<br><br>​`<span class="hljs-comment">//2、提供储存地址`</span><br><br>​`<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">SingleInstance</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SIngleInstance</span>();`<br><br>​`<span class="hljs-comment">//1、构造器私有化`</span><br><br>​`<span class="hljs-keyword">private</span> <span class="hljs-title function_">SingleInstance</span><span class="hljs-params">()</span>&#123;&#125;`<br><br>`&#125;`<br></code></pre></td></tr></table></figure><h6 id="懒汉单例"><a href="#懒汉单例" class="headerlink" title="懒汉单例"></a><strong>懒汉单例</strong></h6><p>1、定义一个类，把构造器私有。<br>2、定义一个静态变量存储一个对象。<br>3、提供一个返回单例对象的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleInstance</span>&#123;`<br><br>`<span class="hljs-comment">//2、提供储存地址`</span><br><br>`<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">SingleInstance</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br><span class="hljs-comment">//3、提供一个方法`</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleInstance <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">if</span>(instance==<span class="hljs-literal">null</span>)<br>instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingleInstance</span>();<br><span class="hljs-keyword">return</span> instance;<br>&#125;<br><br>`<span class="hljs-comment">//1、构造器私有化`</span><br><br>`<span class="hljs-keyword">private</span> <span class="hljs-title function_">SingleInstance</span><span class="hljs-params">()</span>&#123;&#125;`<br><br>`&#125;`<br></code></pre></td></tr></table></figure><h6 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a><strong>继承的特点</strong></h6><p>①子类可以继承父类的属性和行为，但是子类不能继承父类的构造器。<br>②Java是单继承模式：一个类只能继承一个直接父类。<br>③Java不支持多继承、但是支持多层继承。<br>④Java中所有的类都是Object类的子类。</p><h6 id="子类继承父类后构造器的特点："><a href="#子类继承父类后构造器的特点：" class="headerlink" title="子类继承父类后构造器的特点："></a><strong>子类继承父类后构造器的特点：</strong></h6><p>子类中所有的构造器默认都会先访问父类中无参的构造器，再执行自己。</p><h6 id="finall的作用"><a href="#finall的作用" class="headerlink" title="finall的作用"></a><strong>finall的作用</strong></h6><p>final关键字是最终的意思，可以修饰(类、方法、变量)<br>修饰类：表明该类是最终类，不能被继承。<br>修饰方法：表明该方法是最终方法，不能被重写。<br>修饰变量：表示该变量第一次赋值后，不能再次被赋值（有且仅能被赋值一次）。</p><h6 id="枚举的特征："><a href="#枚举的特征：" class="headerlink" title="枚举的特征："></a><strong>枚举的特征：</strong></h6><p>枚举类都是继承了枚举类型：java.lang.Enum<br>枚举都是最终类，不可以被继承。<br>构造器的构造器都是私有的，枚举对外不能创建对象。<br>枚举类的第一行默认都是罗列枚举对象的名称的。<br>枚举类相当于是多例模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Season</span>&#123;<br> SPRING,SUMER,AUTUMN,WINTER;<br>&#125;<br>Season k;<br>SWITCh(k)&#123;<br><span class="hljs-keyword">case</span> SPRING:<br><span class="hljs-keyword">case</span> SUMER:<br><span class="hljs-keyword">case</span> AUTUMN:<br><span class="hljs-keyword">case</span> WINTER:<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="模板方法："><a href="#模板方法：" class="headerlink" title="模板方法："></a>模板方法：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br><span class="hljs-comment">//声明模板方法,建议用final修饰</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我的爸爸&quot;</span>);<br>        System.out.println(wrtiemain());<br>        System.out.println(<span class="hljs-string">&quot;他真牛逼&quot;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">writemain</span><span class="hljs-params">()</span>&#123;<br> System.out.println(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="接口"><a href="#接口" class="headerlink" title="接口:"></a>接口:</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Demo</span>&#123;<br><span class="hljs-comment">//1、常量</span><br><span class="hljs-type">String</span> <span class="hljs-variable">SCHOOL_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xzs&quot;</span><br><span class="hljs-comment">//public static final String SCHOOL_NAME</span><br><span class="hljs-comment">//2、抽象方法</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">//public abstract void run();</span><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="接口实现："><a href="#接口实现：" class="headerlink" title="接口实现："></a>接口实现：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">man</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Demo</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>JDK8开始后新增了那些方法？<br>默认方法：default修饰，实现类对象调用。<br>静态方法：static修饰，必须用当前接口名调用<br>私有方法：private修饰，jdk9开始才有的，只能在接口内部被调用。</p><h6 id="接口的注意事项"><a href="#接口的注意事项" class="headerlink" title="接口的注意事项"></a>接口的注意事项</h6><p>1、接口<strong>不能创建对象</strong>。<br>2、一个类实现多个接口，多个接口中有<strong>同样的静态方法</strong>不冲突。<br>3、一个类继承了父类，同时又实现了接口，父类中和接口中有同名方法，<strong>默认用父类的</strong>。<br>4、一个类实现了多个接口，多个接口中存在同名的默认方法，不冲突，<strong>这个类重写该方法即可</strong>。<br>5、一个接口继承多个接口，是没有问题的，如果多个接口中存在规范冲突则不能多继承。</p><h6 id="多态："><a href="#多态：" class="headerlink" title="多态："></a>多态：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Animal 父类 run();方法</span><br><span class="hljs-comment">//dog 子类 wang();方法独有</span><br><span class="hljs-comment">//cat 子类 miao();方法独有</span><br><span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">dog</span>();<br><span class="hljs-type">Animal</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">cat</span>();<br><span class="hljs-comment">//多态展示</span><br>a.run();<span class="hljs-comment">//狗跑</span><br>b.run();<span class="hljs-comment">//猫跑</span><br><span class="hljs-comment">//a.wang();出错</span><br><span class="hljs-type">dog</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span>(dog) a;<br>c.wang();<span class="hljs-comment">//正确，没有创建新对象，c不是新对象</span><br><span class="hljs-comment">//建议用法</span><br><span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> dog)&#123;<br><span class="hljs-type">dog</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span>(dog) a;<br>c.wang();<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a <span class="hljs-keyword">instanceof</span> cat)&#123;<br><span class="hljs-type">cat</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span>(cat) a;<br>c.miao();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><p>·内部类就是定义在一个类里面的类，里面的类可以理解成（寄生），外部类可以理解成（宿主）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>&#123;<br><span class="hljs-comment">//内部类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Heart</span>&#123;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>内部类的使用场景、作用</strong><br>当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么整个内部的完整结构可以选择使用内部类来设计。<br>内部类通常可以方便访问外部类的成员，包括私有的成员。<br>内部类提供了更好的封装性，内部类本身就可以用private protectecd等修饰，封装性可以做更多控制。</p><h6 id="1、静态内部类（用static修饰）"><a href="#1、静态内部类（用static修饰）" class="headerlink" title="1、静态内部类（用static修饰）"></a>1、<strong>静态内部类</strong>（用static修饰）</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">Outer.<span class="hljs-type">inner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>.inner(); <br></code></pre></td></tr></table></figure><h6 id="2、成员内部类（无static）"><a href="#2、成员内部类（无static）" class="headerlink" title="2、成员内部类（无static）"></a>2、<strong>成员内部类</strong>（无static）</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">Outer.<span class="hljs-type">inner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">inner</span>();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">150</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Heart</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">110</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">78</span>;<br>          System.out.println(c);<br>          System.out.println(<span class="hljs-built_in">this</span>.b);<br>          System.out.println(People.<span class="hljs-built_in">this</span>.a);<br>&#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="3、局部内部类"><a href="#3、局部内部类" class="headerlink" title="3、局部内部类"></a>3、<strong>局部内部类</strong></h6><h6 id="4、匿名内部类"><a href="#4、匿名内部类" class="headerlink" title="4、匿名内部类*"></a>4、<strong>匿名内部类</strong>*</h6><p>​    本质上是一个没有名字的局部内部类，定义在方法中、代码块中、等。</p><p>​    作用：方便创建子类对象，最终目的为了简化代码编写。</p><p>匿名内部类是一个没有名字的内部类。<br>匿名内部类写出来就会产生一个匿名内部类的对象。<br>匿名内部类的对象类型相当于是当前new的那个的类型的子类类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 类|抽象类名|或者接口名（）&#123;<br>重写方法；<br>&#125;;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br>main&#123;<br>    <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>()&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>            Systerm.out.println(<span class="hljs-string">&quot;老虎会跑&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal:"></a>BigDecimal:</h4><p>解决浮点数精度失真问题</p><p>使用步骤<br>创建对象BigDecimal封装浮点型数据（最好的方式是调用方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*public static BigDecimal valueOf(double val) &#123;</span><br><span class="hljs-comment">        // Reminder: a zero double returns &#x27;0.0&#x27;, so we cannot fastpath</span><br><span class="hljs-comment">        // to use the constant ZERO.  This might be important enough to</span><br><span class="hljs-comment">        // justify a factory approach, a cache, or a few private</span><br><span class="hljs-comment">        // constants, later.</span><br><span class="hljs-comment">        return new BigDecimal(Double.toString(val));</span><br><span class="hljs-comment">        &#125;*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test_BigDecimal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> BigDecimal.valueOf(<span class="hljs-number">0.1</span>);<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">a2</span> <span class="hljs-operator">=</span> BigDecimal.valueOf(<span class="hljs-number">0.2</span>);<br>        System.out.println(a1.add(a2));<br>        System.out.println(a1.subtract(a2));<br>        System.out.println(a1.multiply(a2));<br>        System.out.println(a1.divide(a2));<br>        <span class="hljs-comment">//转换为double传给别人</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> a1.doubleValue();<br>        System.out.println(rs);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="日期与时间"><a href="#日期与时间" class="headerlink" title="日期与时间"></a>日期与时间</h4><h6 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h6><p>Date类的对象在ava中代表的是当前所在系统的此刻日期时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//计算当前时间121毫秒后时间</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">date</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        System.out.println(a);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> a.getTime();<br>        System.out.println(time);<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        System.out.println(d1);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">time2</span> <span class="hljs-operator">=</span>System.currentTimeMillis();<br>        time2 += (<span class="hljs-number">60</span> * <span class="hljs-number">60</span> + <span class="hljs-number">121</span>) * <span class="hljs-number">1000</span>;<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">d2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(time2);<br>        System.out.println(d2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="simpleDateFormat类"><a href="#simpleDateFormat类" class="headerlink" title="simpleDateFormat类"></a>simpleDateFormat类</h6><p>可以对Date对象或时间毫秒值格式化成我们喜欢的时间形式。<br>也可以把字符串的时间形式解析成日期对象。</p><p>1、格式化</p><table><thead><tr><th>Sun Apr 24 15:17:16 CST 2022<br/>2022年04月24日 15:17:16 星期日 下午<br/>2022年04月24日 15:19:17 星期日 下午</th></tr></thead></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">simpleDateFormat</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//日期对象</span><br>        <span class="hljs-type">Date</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        System.out.println(d);<br>        <span class="hljs-comment">//格式</span><br>        <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy年MM月dd日 HH:mm:ss EEE a&quot;</span>);<br>        <span class="hljs-comment">//格式化</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> sdf.format(d);<br>        System.out.println(rs);<br>        <span class="hljs-comment">//毫秒</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">time1</span> <span class="hljs-operator">=</span>System.currentTimeMillis() +<span class="hljs-number">121</span>*<span class="hljs-number">1000</span>;<br>        <span class="hljs-type">String</span>  <span class="hljs-variable">rs2</span> <span class="hljs-operator">=</span> sdf.format(time1);<br>        System.out.println(rs2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、解析</p><p>请计算出2021年08月06日11点11分11秒，往后走2天14小时49分06秒后的时间是多少。</p><table><thead><tr><th>2021年08月09日 02:00:17</th></tr></thead></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">simpleDateFormat2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ParseException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">dateStr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2021年08月06日 11:11:11&quot;</span>;<br>        <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> sdf.parse(dateStr);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span>d.getTime()+(<span class="hljs-number">2L</span>*<span class="hljs-number">24</span>*<span class="hljs-number">60</span>*<span class="hljs-number">60</span> +<span class="hljs-number">14</span>*<span class="hljs-number">60</span>*<span class="hljs-number">60</span> +<span class="hljs-number">49</span>*<span class="hljs-number">60</span> +<span class="hljs-number">6</span>)*<span class="hljs-number">1000</span>;<br>        System.out.println(sdf.format(time));<br>    &#125;<br></code></pre></td></tr></table></figure><h6 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h6><p>Calendar代表了系统此刻日期对应的日历对象。<br>Calendar是一个抽象类，不能直接创建对象。</p><table><thead><tr><th>java.util.GregorianCalendar[time=1650786277579,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=”Asia/Shanghai”,offset=28800000,dstSavings=0,useDaylight=false,transitions=31,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2022,MONTH=3,WEEK_OF_YEAR=18,WEEK_OF_MONTH=5,DAY_OF_MONTH=24,DAY_OF_YEAR=114,DAY_OF_WEEK=1,DAY_OF_WEEK_IN_MONTH=4,AM_PM=1,HOUR=3,HOUR_OF_DAY=15,MINUTE=44,SECOND=37,MILLISECOND=579,ZONE_OFFSET=28800000,DST_OFFSET=0]<br/>2022<br/>4<br/>24<br/>Fri Apr 29 15:44:37 CST 2022<br/><br/></th></tr></thead></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Canlendar</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//1、拿到系统此时的日历对象</span><br>        <span class="hljs-type">Calendar</span> <span class="hljs-variable">cal</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>        System.out.println(cal);<br>        <span class="hljs-comment">//2、获取日历信息</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">year</span> <span class="hljs-operator">=</span> cal.get(Calendar.YEAR);<br>        System.out.println(year);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">month</span> <span class="hljs-operator">=</span>cal.get(Calendar.MONTH)+<span class="hljs-number">1</span>;<br>        System.out.println(month);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">day</span> <span class="hljs-operator">=</span> cal.get(Calendar.DAY_OF_MONTH);<br>        System.out.println(day);<br>        <span class="hljs-comment">//3、修改时间</span><br>        <span class="hljs-comment">//cal.set();</span><br>        cal.add(Calendar.DAY_OF_MONTH,<span class="hljs-number">5</span>);<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> cal.getTime();<br>        System.out.println(d);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="新增API"><a href="#新增API" class="headerlink" title="新增API"></a>新增API</h6><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs markdown">从Java8开始，java.time包提供了新的日期和时间APl,主要涉及的类型有：<br><br><span class="hljs-bullet">-</span> LocalDate:不包含具体时间的日期。<br><span class="hljs-bullet">-</span> LocalTime:不含日期的时间。<br><span class="hljs-bullet">-</span> LocalDateTime:包含了日期及时间。<br><span class="hljs-bullet">-</span> JDK8新增日期类<br><span class="hljs-bullet">-</span> Instant:代表的是时间戳。<br><span class="hljs-bullet">-</span> DateTimeFormatter用于做时间的格式化和解析的<br><span class="hljs-bullet">-</span> Duration:用于计算两个“时间”间隔<br><span class="hljs-bullet">-</span> Period:用于计算两个“日期”间隔<br><br>新增的AP叫严格区分了时刻、本地日期、本地时间，并且，对日期和时间进行运算更加方便。<br>其次，新API的类型几乎全部是不变类型(和String的使用类似)，可以放心使用不必担心被修改。<br></code></pre></td></tr></table></figure><p>代码：Day14。</p><h4 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h4><p>包装类<br>其实就是8种基本数据类型对应的引用类型。                </p><table><thead><tr><th>基本数据类型</th><th>引用数据类型</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><p><strong>为什么提供包装类？</strong><br>Java为了实现一切皆对象，为8种基本类型提供了对应的引用类型。<br>后面的集合和泛型其实也只能支持包装类型，不支持基本数据类型。</p><p>包装类的特有功能<br>包装类的变量的默认值可以是ul,容错率更高。<br><strong>可以把基本类型的数据转换成字符串类型（用处不大）</strong><br>①调用toString(）方法得到字符串结果。<br>②调用Integer.toString（）（基本类型的数据）。<br><strong>可以把字符串类型的数值转换成真实的数据类型（真的很有用）</strong><br>①Integer.parselnt(“字符串类型的整数”)。<br>②Double.parseDouble(“字符串类型的小数”)。</p><p><strong>Integer.valueof()  , Double.valueof()</strong></p><h4 id="正则表达式Pattern"><a href="#正则表达式Pattern" class="headerlink" title="正则表达式Pattern"></a>正则表达式Pattern</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegexDemo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//public boolean matches(String regex):判断是否与正则表达式匹配，匹配返回true</span><br>        <span class="hljs-comment">// 只能是 a  b  c</span><br>        System.out.println(<span class="hljs-string">&quot;a&quot;</span>.matches(<span class="hljs-string">&quot;[abc]&quot;</span>)); <span class="hljs-comment">// true</span><br>        System.out.println(<span class="hljs-string">&quot;z&quot;</span>.matches(<span class="hljs-string">&quot;[abc]&quot;</span>)); <span class="hljs-comment">// false</span><br><br>        <span class="hljs-comment">// 不能出现a  b  c</span><br>        System.out.println(<span class="hljs-string">&quot;a&quot;</span>.matches(<span class="hljs-string">&quot;[^abc]&quot;</span>)); <span class="hljs-comment">// false</span><br>        System.out.println(<span class="hljs-string">&quot;z&quot;</span>.matches(<span class="hljs-string">&quot;[^abc]&quot;</span>)); <span class="hljs-comment">// true</span><br><br>        System.out.println(<span class="hljs-string">&quot;a&quot;</span>.matches(<span class="hljs-string">&quot;\\d&quot;</span>)); <span class="hljs-comment">// false</span><br>        System.out.println(<span class="hljs-string">&quot;3&quot;</span>.matches(<span class="hljs-string">&quot;\\d&quot;</span>)); <span class="hljs-comment">// true</span><br>        System.out.println(<span class="hljs-string">&quot;333&quot;</span>.matches(<span class="hljs-string">&quot;\\d&quot;</span>)); <span class="hljs-comment">// false</span><br>        System.out.println(<span class="hljs-string">&quot;z&quot;</span>.matches(<span class="hljs-string">&quot;\\w&quot;</span>)); <span class="hljs-comment">// true</span><br>        System.out.println(<span class="hljs-string">&quot;2&quot;</span>.matches(<span class="hljs-string">&quot;\\w&quot;</span>)); <span class="hljs-comment">// true</span><br>        System.out.println(<span class="hljs-string">&quot;21&quot;</span>.matches(<span class="hljs-string">&quot;\\w&quot;</span>)); <span class="hljs-comment">// false</span><br>        System.out.println(<span class="hljs-string">&quot;你&quot;</span>.matches(<span class="hljs-string">&quot;\\w&quot;</span>)); <span class="hljs-comment">//false</span><br>        System.out.println(<span class="hljs-string">&quot;你&quot;</span>.matches(<span class="hljs-string">&quot;\\W&quot;</span>)); <span class="hljs-comment">// true</span><br>        System.out.println(<span class="hljs-string">&quot;---------------------------------&quot;</span>);<br>        <span class="hljs-comment">//  以上正则匹配只能校验单个字符。</span><br><br>        <span class="hljs-comment">// 校验密码</span><br>        <span class="hljs-comment">// 必须是数字 字母 下划线 至少 6位</span><br>        System.out.println(<span class="hljs-string">&quot;2442fsfsf&quot;</span>.matches(<span class="hljs-string">&quot;\\w&#123;6,&#125;&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;244f&quot;</span>.matches(<span class="hljs-string">&quot;\\w&#123;6,&#125;&quot;</span>));<br><br>        <span class="hljs-comment">// 验证码 必须是数字和字符  必须是4位</span><br>        System.out.println(<span class="hljs-string">&quot;23dF&quot;</span>.matches(<span class="hljs-string">&quot;[a-zA-Z0-9]&#123;4&#125;&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;23_F&quot;</span>.matches(<span class="hljs-string">&quot;[a-zA-Z0-9]&#123;4&#125;&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;23dF&quot;</span>.matches(<span class="hljs-string">&quot;[\\w&amp;&amp;[^_]]&#123;4&#125;&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;23_F&quot;</span>.matches(<span class="hljs-string">&quot;[\\w&amp;&amp;[^_]]&#123;4&#125;&quot;</span>));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>public boolean matches(<a href="file:///D:/course/%E5%9F%BA%E7%A1%80%E9%98%B6%E6%AE%B5/API%E6%96%87%E6%A1%A3/docs/api/java.base/java/lang/String.html">String</a> regex): 判断是否匹配正则表达式，匹配返回true，不匹配返回false。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css">字符类(默认匹配一个字符)<br><br><span class="hljs-selector-attr">[abc]</span>     只能是<span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span>, 或c<br><br><span class="hljs-selector-attr">[^abc]</span>     除了<span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span>, c之外的任何字符<br><br><span class="hljs-selector-attr">[a-zA-Z]</span>        <span class="hljs-selector-tag">a</span>到z <span class="hljs-selector-tag">A</span>到Z，包括（范围）<br><br><span class="hljs-selector-attr">[a-d[m-p]</span>]     <span class="hljs-selector-tag">a</span>到d，或m通过<span class="hljs-selector-tag">p</span>：（<span class="hljs-selector-attr">[a-dm-p]</span>联合）<br><br><span class="hljs-selector-attr">[a-z&amp;&amp;[def]</span>]     d, e, 或f(交集)<br><br><span class="hljs-selector-attr">[a-z&amp;&amp;[^bc]</span>]     <span class="hljs-selector-tag">a</span>到z，除了<span class="hljs-selector-tag">b</span>和c：（<span class="hljs-selector-attr">[ad-z]</span>减法）<br><br><span class="hljs-selector-attr">[a-z&amp;&amp;[^m-p]</span>]   <span class="hljs-selector-tag">a</span>到z，除了m到<span class="hljs-selector-tag">p</span>：（<span class="hljs-selector-attr">[a-lq-z]</span>减法）<br></code></pre></td></tr></table></figure><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livescript">预定义的字符类(默认匹配一个字符)<br>.任何字符<br><span class="hljs-string">\d</span>一个数字： [<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]<br><span class="hljs-string">\D</span>非数字： [^<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]<br><span class="hljs-string">\s</span>一个空白字符： [ <span class="hljs-string">\t\n\x0B\f\r]</span><br><span class="hljs-string">\S</span>非空白字符： [^<span class="hljs-string">\s]</span><br><span class="hljs-string">\w</span>[a-zA-Z_0-<span class="hljs-number">9</span>] 英文、数字、下划线<br><span class="hljs-string">\W</span> [^<span class="hljs-string">\w]</span> 一个非单词字符<br></code></pre></td></tr></table></figure><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tp">贪婪的量词（配合匹配多个字符）<br><span class="hljs-keyword">X</span>?<span class="hljs-keyword">X</span> , 一次或根本不<br><span class="hljs-keyword">X</span>*<span class="hljs-keyword">X</span>，零次或多次<br><span class="hljs-keyword">X</span>+<span class="hljs-keyword">X</span> , 一次或多次<br><span class="hljs-keyword">X</span> &#123;n&#125;<span class="hljs-keyword">X</span>，正好n次<br><span class="hljs-keyword">X</span> &#123;n, &#125;<span class="hljs-keyword">X</span>，至少n次<br><span class="hljs-keyword">X</span> &#123;n,m&#125;<span class="hljs-keyword">X</span>，至少n但不超过m次<br></code></pre></td></tr></table></figure><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public String replaceAll(String regex,String newStr）</td><td>按照正则表达式匹配的内容进行替换</td></tr><tr><td>public String[] split(String regex)：</td><td>按照正则表达式匹配的内容进行分割字符串，反回一个字符串数组。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.d6_regex;<br><br><span class="hljs-keyword">import</span> java.util.regex.Matcher;<br><span class="hljs-keyword">import</span> java.util.regex.Pattern;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    拓展：正则表达式爬取信息中的内容。(了解)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegexDemo05</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;来黑马程序学习Java,电话020-43422424，或者联系邮箱&quot;</span> +<br>                <span class="hljs-string">&quot;itcast@itcast.cn,电话18762832633，0203232323&quot;</span> +<br>                <span class="hljs-string">&quot;邮箱bozai@itcast.cn，400-100-3233 ，4001003232&quot;</span>;<br><br>        <span class="hljs-comment">// 需求：从上面的内容中爬取出 电话号码和邮箱。</span><br>        <span class="hljs-comment">// 1、定义爬取规则，字符串形式</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(\\w&#123;1,30&#125;@[a-zA-Z0-9]&#123;2,20&#125;(\\.[a-zA-Z0-9]&#123;2,20&#125;)&#123;1,2&#125;)|(1[3-9]\\d&#123;9&#125;)&quot;</span> +<br>                <span class="hljs-string">&quot;|(0\\d&#123;2,6&#125;-?\\d&#123;5,20&#125;)|(400-?\\d&#123;3,9&#125;-?\\d&#123;3,9&#125;)&quot;</span>;<br><br>        <span class="hljs-comment">// 2、把这个爬取规则编译成匹配对象。</span><br>        <span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern.compile(regex);<br><br>        <span class="hljs-comment">// 3、得到一个内容匹配器对象</span><br>        <span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> pattern.matcher(rs);<br><br>        <span class="hljs-comment">// 4、开始找了</span><br>        <span class="hljs-keyword">while</span> (matcher.find()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">rs1</span> <span class="hljs-operator">=</span> matcher.group();<br>            System.out.println(rs1);<br>        &#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="Arrays类概述"><a href="#Arrays类概述" class="headerlink" title="Arrays类概述"></a><strong>Arrays</strong>类概述</h4><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static <a href="mk:@MSITStore:C:\course\API文档\jdk-9_google.CHM::/java/lang/String.html">String</a> toString(类型[] a)</td><td>返回数组的内容（字符串形式）</td></tr><tr><td>public static void sort(类型[] a)</td><td>对数组进行默认升序排序</td></tr><tr><td>public static <T> void sort(类型[] a, <a href="mk:@MSITStore:C:\course\API文档\jdk-9_google.CHM::/java/util/Comparator.html">Comparator</a>&lt;? super T&gt; c)</td><td>使用比较器对象自定义排序</td></tr><tr><td>public static int binarySearch(int[] a, int key)</td><td>二分搜索数组中的数据，存在返回索引，不存在返回-1</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">如果认为左边数据 大于 右边数据 返回正整数</span><br><span class="hljs-comment">如果认为左边数据 小于 右边数据  返回负整数</span><br><span class="hljs-comment">如果认为左边数据  等于 右边数据  返回0</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArraysDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：自定义数组的排序规则：Comparator比较器对象。</span><br>        <span class="hljs-comment">// 1、Arrays的sort方法对于有值特性的数组是默认升序排序</span><br>        <span class="hljs-type">int</span>[] ages = &#123;<span class="hljs-number">34</span>, <span class="hljs-number">12</span>, <span class="hljs-number">42</span>, <span class="hljs-number">23</span>&#125;;<br>        Arrays.sort(ages);<br>        System.out.println(Arrays.toString(ages));<br><br>        <span class="hljs-comment">// 2、需求：降序排序！(自定义比较器对象，只能支持引用类型的排序！！)</span><br>        Integer[] ages1 = &#123;<span class="hljs-number">34</span>, <span class="hljs-number">12</span>, <span class="hljs-number">42</span>, <span class="hljs-number">23</span>&#125;;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">           参数一：被排序的数组 必须是引用类型的元素</span><br><span class="hljs-comment">           参数二：匿名内部类对象，代表了一个比较器对象。</span><br><span class="hljs-comment">         */</span><br>        Arrays.sort(ages1, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;<br>                <span class="hljs-comment">// 指定比较规则。</span><br><span class="hljs-comment">//                if(o1 &gt; o2)&#123;</span><br><span class="hljs-comment">//                    return 1;</span><br><span class="hljs-comment">//                &#125;else if(o1 &lt; o2)&#123;</span><br><span class="hljs-comment">//                    return -1;</span><br><span class="hljs-comment">//                &#125;</span><br><span class="hljs-comment">//                return 0;</span><br>                <span class="hljs-comment">// return o1 - o2; // 默认升序</span><br>                <span class="hljs-keyword">return</span> o2 - o1; <span class="hljs-comment">//  降序</span><br>            &#125;<br>        &#125;);<br>        System.out.println(Arrays.toString(ages1));<br><br>        System.out.println(<span class="hljs-string">&quot;-------------------------&quot;</span>);<br>        Student[] students = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>[<span class="hljs-number">3</span>];<br>        students[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;吴磊&quot;</span>,<span class="hljs-number">23</span> , <span class="hljs-number">175.5</span>);<br>        students[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;谢鑫&quot;</span>,<span class="hljs-number">18</span> , <span class="hljs-number">185.5</span>);<br>        students[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;王亮&quot;</span>,<span class="hljs-number">20</span> , <span class="hljs-number">195.5</span>);<br>        System.out.println(Arrays.toString(students));<br><br>        <span class="hljs-comment">// Arrays.sort(students);  // 直接运行奔溃</span><br>        Arrays.sort(students, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Student&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Student o1, Student o2)</span> &#123;<br>                <span class="hljs-comment">// 自己指定比较规则</span><br>                <span class="hljs-comment">// return o1.getAge() - o2.getAge(); // 按照年龄升序排序！</span><br>                <span class="hljs-comment">// return o2.getAge() - o1.getAge(); // 按照年龄降序排序！！</span><br>                <span class="hljs-comment">// return Double.compare(o1.getHeight(), o2.getHeight()); // 比较浮点型可以这样写 升序</span><br>                <span class="hljs-keyword">return</span> Double.compare(o2.getHeight(), o1.getHeight()); <span class="hljs-comment">// 比较浮点型可以这样写  降序</span><br>            &#125;<br>        &#125;);<br>        System.out.println(Arrays.toString(students));<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><p><strong>Lambda概述</strong><br>●Lambda:表达式是JDK8开始后的一种新语法形式。<br>●作用：简化匿名内部类的代码写法。<br><strong>Lambda表达式的简化格式</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean">（匿名内部类被重写方法的形参列表）-&gt;&#123;<br>被重写方法的方法体代码。<br>&#125;<br>注：-&gt;是语法形式，无实际含义<br></code></pre></td></tr></table></figure><p><strong>注意：Lambda表达式只能简化函数式接口的匿名内部类的写法形式</strong></p><p>什么是函数式接口？<br>●首先必须是接口、其次接口中有且仅有一个抽象方法的形式<br>●通常我们会在接口上加上一个@Functionallnterface注解，标记该接口必须是满足函数式接口。</p><p>1、Lambda表达式的基本作用？<br>●简化函数式接口的匿名内部类的写法。<br>2、Lambda表达式有什么使用前提？<br>●必须是接口的匿名内部类，接口中只能有一个抽象方法<br>3、Lambda的好处？<br>●Lambda是一个匿名函数，我们可以把Lambda表达式理解为<br>是一段可以传递的代码，它可以写出更简洁、更灵活的代码，<br>作为一种更紧凑的代码风格，使va语言表达能力得到了提升。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LambdaDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：学会使用Lambda的标准格式简化匿名内部类的代码形式</span><br>        <span class="hljs-comment">// 注意：Lambda只能简化接口中只有一个抽象方法的匿名内部类形式（函数式接口）</span><br><span class="hljs-comment">//        Swimming s1 = new Swimming() &#123;</span><br><span class="hljs-comment">//            @Override</span><br><span class="hljs-comment">//            public void swim() &#123;</span><br><span class="hljs-comment">//                System.out.println(&quot;老师游泳贼溜~~~~~&quot;);</span><br><span class="hljs-comment">//            &#125;</span><br><span class="hljs-comment">//        &#125;;</span><br><br><span class="hljs-comment">//        Swimming s1 = () -&gt; &#123;</span><br><span class="hljs-comment">//            System.out.println(&quot;老师游泳贼溜~~~~~&quot;);</span><br><span class="hljs-comment">//        &#125;;</span><br><br>        <span class="hljs-type">Swimming</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">&quot;老师游泳贼溜~~~~~&quot;</span>);<br>        go(s1);<br><br>        System.out.println(<span class="hljs-string">&quot;---------------------&quot;</span>);<br><span class="hljs-comment">//        go(new Swimming() &#123;</span><br><span class="hljs-comment">//            @Override</span><br><span class="hljs-comment">//            public void swim() &#123;</span><br><span class="hljs-comment">//                System.out.println(&quot;学生游泳很开心~~~&quot;);</span><br><span class="hljs-comment">//            &#125;</span><br><span class="hljs-comment">//        &#125;);</span><br><br><span class="hljs-comment">//        go(() -&gt;&#123;</span><br><span class="hljs-comment">//                System.out.println(&quot;学生游泳很开心~~~&quot;);</span><br><span class="hljs-comment">//        &#125;);</span><br><br>        go(() -&gt; System.out.println(<span class="hljs-string">&quot;学生游泳很开心~~~&quot;</span>));<br><br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">go</span><span class="hljs-params">(Swimming s)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;开始。。。&quot;</span>);<br>        s.swim();<br>        System.out.println(<span class="hljs-string">&quot;结束。。。&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@FunctionalInterface</span> <span class="hljs-comment">// 一旦加上这个注解必须是函数式接口，里面只能有一个抽象方法</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Swimming</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Lambda表达式的省略写法(进一步在Lambda表达式的基础上继续简化)<br>参数类型可以省略不写。<br>●如果只有一个参数，参数类型可以省略，同时）也可以省略。<br>●如果Lambda表达式的方法体代码只有一行代码。可以省略大括号不写，同时要省略分号！<br>●如果Lambda表达式的方法体代码只有一行代码。可以省略大括号不写。此时，如果这行代码是<span class="hljs-keyword">return</span>语句，必须省略<span class="hljs-keyword">return</span>不写，同时也必须省略<span class="hljs-string">&quot;，&quot;</span>不写<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LambdaDemo3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Integer[] ages1 = &#123;<span class="hljs-number">34</span>, <span class="hljs-number">12</span>, <span class="hljs-number">42</span>, <span class="hljs-number">23</span>&#125;;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         参数一：被排序的数组 必须是引用类型的元素</span><br><span class="hljs-comment">         参数二：匿名内部类对象，代表了一个比较器对象。</span><br><span class="hljs-comment">         */</span><br><span class="hljs-comment">//        Arrays.sort(ages1, new Comparator&lt;Integer&gt;() &#123;</span><br><span class="hljs-comment">//            @Override</span><br><span class="hljs-comment">//            public int compare(Integer o1, Integer o2) &#123;</span><br><span class="hljs-comment">//                return o2 - o1; //  降序</span><br><span class="hljs-comment">//            &#125;</span><br><span class="hljs-comment">//        &#125;);</span><br><br><span class="hljs-comment">//        Arrays.sort(ages1, (Integer o1, Integer o2) -&gt; &#123;</span><br><span class="hljs-comment">//                return o2 - o1; //  降序</span><br><span class="hljs-comment">//        &#125;);</span><br><br><br><span class="hljs-comment">//        Arrays.sort(ages1, ( o1,  o2) -&gt; &#123;</span><br><span class="hljs-comment">//            return o2 - o1; //  降序</span><br><span class="hljs-comment">//        &#125;);</span><br><br>        Arrays.sort(ages1, ( o1,  o2 ) -&gt;  o2 - o1 );<br><br>        System.out.println(Arrays.toString(ages1));<br><br>        System.out.println(<span class="hljs-string">&quot;---------------------------&quot;</span>);<br>        <span class="hljs-type">JFrame</span> <span class="hljs-variable">win</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JFrame</span>(<span class="hljs-string">&quot;登录界面&quot;</span>);<br>        <span class="hljs-type">JButton</span> <span class="hljs-variable">btn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JButton</span>(<span class="hljs-string">&quot;我是一个很大的按钮&quot;</span>);<br><span class="hljs-comment">//        btn.addActionListener(new ActionListener() &#123;</span><br><span class="hljs-comment">//            @Override</span><br><span class="hljs-comment">//            public void actionPerformed(ActionEvent e) &#123;</span><br><span class="hljs-comment">//                System.out.println(&quot;有人点我，点我，点我！！&quot;);</span><br><span class="hljs-comment">//            &#125;</span><br><span class="hljs-comment">//        &#125;);</span><br><br><span class="hljs-comment">//        btn.addActionListener((ActionEvent e) -&gt; &#123;</span><br><span class="hljs-comment">//                System.out.println(&quot;有人点我，点我，点我！！&quot;);</span><br><span class="hljs-comment">//        &#125;);</span><br><br><span class="hljs-comment">//        btn.addActionListener(( e) -&gt; &#123;</span><br><span class="hljs-comment">//            System.out.println(&quot;有人点我，点我，点我！！&quot;);</span><br><span class="hljs-comment">//        &#125;);</span><br><br><span class="hljs-comment">//        btn.addActionListener( e -&gt; &#123;</span><br><span class="hljs-comment">//            System.out.println(&quot;有人点我，点我，点我！！&quot;);</span><br><span class="hljs-comment">//        &#125;);</span><br><br>        btn.addActionListener( e -&gt; System.out.println(<span class="hljs-string">&quot;有人点我，点我，点我！！&quot;</span>) );<br>        <br>        win.add(btn);<br>        win.setSize(<span class="hljs-number">400</span>, <span class="hljs-number">300</span>);<br>        win.setVisible(<span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="集合collection"><a href="#集合collection" class="headerlink" title="集合collection"></a>集合collection</h4><p>集合是java中存储对象数据的一种容器。</p><h6 id="集合的特点"><a href="#集合的特点" class="headerlink" title="集合的特点"></a><strong>集合的特点</strong></h6><ul><li>集合的大小不固定，启动后可以动态变化，类型也可以选择不固定。集合更像气球。</li><li>集合非常适合做元素的增删操作。</li><li>注意：集合中只能存储<strong>引用类型数据</strong>，如果要存储基本类型数据可以选用包装类。</li></ul><p><strong>1、数组和集合的元素存储的个数问题。</strong><br>    ●数组定义后类型确定，长度固定<br>    ●集合类型可以不固定，大小是可变的。<br><strong>2、数组和集合存储元素的类型问题。</strong><br>    ●数组可以存储基本类型和引用类型的数据。<br>    ●集合只能存储引用数据类型的数据。<br><strong>3、数组和集合适合的场景</strong><br>    ●数组适合做数据个数和类型确定的场景。<br>    ●集合适合做数据个数不确定，且要做增删元素的场景。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220425105730336.png" alt="image-20220425105730336"></p><p><img src="JAVA%E5%9F%BA%E7%A1%80.assets/image-20220425105950636.png" alt="image-20220425105950636"></p><p><strong>Collection集合特点</strong><br>●<strong>List系列集合</strong>：添加的元素是有序、可重复、有索引。<br>    ◆ArrayList、LinekdList:有序。可重复、有奏引。<br>●<strong>Set系列集合</strong>：添加的元素是无序、不重复、无索引。<br>    ◆HashSet:无序、不重复、无索引；LinkedHashSet:<strong>有序</strong>、不重复、无索引。<br>    ◆TreeSet:<strong>按照大小默认升序排序</strong>、不重复、无索引。</p><h6 id="集合常用用法及常用API"><a href="#集合常用用法及常用API" class="headerlink" title="集合常用用法及常用API"></a>集合常用用法及常用API</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection &lt;String&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collection &lt;Integer&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collection &lt;Double&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Object[] arrs =c.toArrays()<span class="hljs-comment">//把集合转化为整数</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public  boolean add(E e)</td><td>把给定的对象添加到当前集合中</td></tr><tr><td>public  void clear()</td><td>清空集合中所有的元素</td></tr><tr><td>public  boolean remove(E e)</td><td>把给定的对象在当前集合中删除</td></tr><tr><td>public  boolean contains(Object obj)</td><td>判断当前集合中是否包含给定的对象</td></tr><tr><td>public  boolean isEmpty()</td><td>判断当前集合是否为空</td></tr><tr><td>public  int size()</td><td>返回集合中元素的个数。</td></tr><tr><td>public  Object[] toArray()</td><td>把集合中的元素，存储到数组中</td></tr></tbody></table><p><strong>遍历集合</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Iterator&lt;String&gt; it = lists.iterator();<br> <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>   <span class="hljs-type">String</span> <span class="hljs-variable">ele</span> <span class="hljs-operator">=</span> it.next();<br>   System.out.println(ele);<br> &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">for</span>(String ele : list) &#123;<span class="hljs-comment">//list.for快捷键</span><br>System.out.println(ele);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">lists.forEach(s -&gt; &#123;<br>      System.out.println(s);<br> &#125;);<br></code></pre></td></tr></table></figure><h6 id="各种数据结构的特点和作用是什么样的"><a href="#各种数据结构的特点和作用是什么样的" class="headerlink" title="各种数据结构的特点和作用是什么样的"></a>各种数据结构的特点和作用是什么样的</h6><ul><li>队列：先进先出，后进后出。</li><li>栈：后进先出，先进后出。</li><li>数组：内存连续区域，查询快，增删慢。</li><li>链表：元素是游离的，查询慢，首尾操作极快。</li><li>二叉树：永远只有一个根节点，每个结点不超过2个子节点的树。</li><li>查找二叉树：小的左边，大的右边，但是可能树很高，查询性能变差。</li><li>平衡查找二叉树：让树的高度差不大于1，增删改查都提高了。</li><li>红黑树（就是基于红黑规则实现了自平衡的排序二叉树）</li></ul><h6 id="ArrayList集合底层原理"><a href="#ArrayList集合底层原理" class="headerlink" title="ArrayList集合底层原理"></a>ArrayList集合底层原理</h6><p>ArrayList底层是基于数组实现的：根据索引定位元素快，增删需要做元素的移位操作。<br>第一次创建集合并添加第一个元素的时候，在底层创建一个默认长度为10的数组。满了后每次扩容1.5倍，迁移。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220425201738284.png" alt="image-20220425201738284"></p><h6 id="LinkedList的特点-适用于栈和队列"><a href="#LinkedList的特点-适用于栈和队列" class="headerlink" title="LinkedList的特点(适用于栈和队列)"></a>LinkedList的特点(适用于栈和队列)</h6><p>●底层数据结构是双链表，查询慢，首尾操作的速度是极快的，所以多了很多首尾操作的特有API。</p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public  void addFirst(E e)</td><td>在该列表开头插入指定的元素</td></tr><tr><td>public  void addLast(E e)</td><td>将指定的元素追加到此列表的末尾</td></tr><tr><td>public  E getFirst()</td><td>返回此列表中的第一个元素</td></tr><tr><td>public  E getLast()</td><td>返回此列表中的最后一个元素</td></tr><tr><td>public  E removeFirst()</td><td>从此列表中删除并返回第一个元素</td></tr><tr><td>public  E removeLast()</td><td>从此列表中删除并返回最后一个元素</td></tr></tbody></table><h6 id="并发增删异常"><a href="#并发增删异常" class="headerlink" title="并发增删异常"></a>并发增删异常</h6><p><strong>当我们从集合中找出某个元素并删除的时候可能出现一种并发修改异常问题。</strong><br><strong>哪些遍历存在问题？</strong><br>迭代器遍历集合且直接用集合删除元素的时候可能出现。</p><p>增强for循环遍历集合且直接用集合删除元素的时候可能出现。</p><p><strong>哪种遍历且删除元素不出问题</strong><br>迭代器遍历集合但是用迭代器自己的删除方法操作可以解决。</p><p>使用for循环遍历并别除元素不会存在这个问题。</p><h4 id="泛型概述"><a href="#泛型概述" class="headerlink" title="泛型概述"></a>泛型概述</h4><ul><li>泛型：是DK5中引入的特性，可以在编译阶段约束操作的数据类型，并进行检查。</li><li>泛型的格式：&lt;数据类型&gt;；注意：泛型只能支持引用数据类型。</li><li>集合体系的全部接口和实现类都是支持泛型的使用的。</li></ul><h6 id="泛型的好处："><a href="#泛型的好处：" class="headerlink" title="泛型的好处："></a>泛型的好处：</h6><ul><li>统一数据类型。</li><li>把运行时期的问题提前到了编译期间，避免了强制类型转换可能出现的异常，因为编译阶段类型就能确定下来。</li></ul><p><strong>模拟ArrayList集合自定义一个集合MyArrayLists集合，完成添加和删除功能的泛型设计即可。</strong></p><h6 id="1、泛型类的核心思想："><a href="#1、泛型类的核心思想：" class="headerlink" title="1、泛型类的核心思想："></a><strong>1、泛型类的核心思想：</strong></h6><p>把出现泛型变量的地方全部替换成传输的真实数据类型</p><h6 id="2、泛型类的作用"><a href="#2、泛型类的作用" class="headerlink" title="2、泛型类的作用"></a><strong>2、泛型类的作用</strong></h6><p>编译阶段约定操作的数据的类型，类似于集合的作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 需求：模拟ArrayList定义一个MyArrayList ，关注泛型设计</span><br>    MyArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyArrayList</span>&lt;&gt;();<br>    list.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;MySQL&quot;</span>);<br>    list.remove(<span class="hljs-string">&quot;MySQL&quot;</span>);<br>    System.out.println(list);<br><br>    MyArrayList&lt;Integer&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyArrayList</span>&lt;&gt;();<br>    list2.add(<span class="hljs-number">23</span>);<br>    list2.add(<span class="hljs-number">24</span>);<br>    list2.add(<span class="hljs-number">25</span>);<br>    list2.remove(<span class="hljs-number">25</span>);<br>    System.out.println(list2);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArrayList</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ArrayList</span> <span class="hljs-variable">lists</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span>&#123;<br>        lists.add(e);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(E e)</span>&#123;<br>        lists.remove(e);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> lists.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="泛型方法的概述"><a href="#泛型方法的概述" class="headerlink" title="泛型方法的概述"></a>泛型方法的概述</h6><p>定义方法时同时定义了泛型的方法就是泛型方法。<br>泛型方法的格式：修饰符&lt;泛型变量&gt;方法返回值方法名称（形参列表）川</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">范例：<span class="hljs-keyword">public</span>&lt;T&gt;<span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(T t)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        String[] names = &#123;<span class="hljs-string">&quot;小璐&quot;</span>, <span class="hljs-string">&quot;蓉容&quot;</span>, <span class="hljs-string">&quot;小何&quot;</span>&#125;;<br>        printArray(names);<br><br>        Integer[] ages = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br>        printArray(ages);<br><br>        Integer[] ages2 = getArr(ages);<br>        String[]  names2 = getArr(names);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T[] getArr(T[] arr)&#123;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">(T[] arr)</span>&#123;<br>        <span class="hljs-keyword">if</span>(arr != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;[&quot;</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>                sb.append(arr[i]).append(i == arr.length - <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;&quot;</span> : <span class="hljs-string">&quot;, &quot;</span>);<br>            &#125;<br>            sb.append(<span class="hljs-string">&quot;]&quot;</span>);<br>            System.out.println(sb);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            System.out.println(arr);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="泛型接口的概述"><a href="#泛型接口的概述" class="headerlink" title="泛型接口的概述"></a>泛型接口的概述</h6><p>使用了泛型定义的接口就是泛型接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">泛型接口的格式：修饰符interface接口名称&lt;泛型变量&gt;&#123;&#125;<br>范例：<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Data</span>&lt;E&gt;&#123;&#125;<br></code></pre></td></tr></table></figure><p>作用：泛型接口可以让实现类选择当前功能需要操作的数据类型。</p><p>教务系统，提供一个接口可约束一定要完成数据（学生，老师）的增删改查操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Data</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(E e)</span>;<br>    E <span class="hljs-title function_">queryById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TeacherData</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Data</span>&lt;Teacher&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Teacher teacher)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Teacher teacher)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Teacher <span class="hljs-title function_">queryById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：泛型通配符。?</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    需求：开发一个极品飞车的游戏，所有的汽车都能一起参与比赛。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    注意：</span><br><span class="hljs-comment">        虽然BMW和BENZ都继承了Car</span><br><span class="hljs-comment">        但是ArrayList&lt;BMW&gt;和ArrayList&lt;BENZ&gt;与ArrayList&lt;Car&gt;没有关系的！!</span><br><span class="hljs-comment">    通配符：？</span><br><span class="hljs-comment">        ？可以在“使用泛型”的时候代表一切类型。</span><br><span class="hljs-comment">        E T K V 是在定义泛型的时候使用的。</span><br><span class="hljs-comment">    泛型的上下限：</span><br><span class="hljs-comment">        ？ extends Car : ?必须是Car或者其子类  泛型上限</span><br><span class="hljs-comment">        ? super Car ：？必须是Car或者其父类   泛型下限</span><br><span class="hljs-comment">    小结：</span><br><span class="hljs-comment">        通配符：？</span><br><span class="hljs-comment">        ？可以在“使用泛型”的时候代表一切类型。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;BMW&gt; bmws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        bmws.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BMW</span>());<br>        bmws.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BMW</span>());<br>        bmws.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BMW</span>());<br>        go(bmws);<br><br>        ArrayList&lt;BENZ&gt; benzs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        benzs.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BENZ</span>());<br>        benzs.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BENZ</span>());<br>        benzs.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BENZ</span>());<br>        go(benzs);<br><br>        ArrayList&lt;Dog&gt; dogs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        dogs.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>());<br>        dogs.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>());<br>        dogs.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>());<br>        <span class="hljs-comment">// go(dogs);</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">       所有车比赛，?通配符</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">go</span><span class="hljs-params">(ArrayList&lt;? extends Car&gt; cars)</span>&#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>&#123;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BENZ</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span>&#123;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BMW</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span>&#123;<br>&#125;<br><br><span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a><strong>Set集合</strong></h4><h6 id="Set系列集合特点"><a href="#Set系列集合特点" class="headerlink" title="Set系列集合特点"></a>Set系列集合特点</h6><p><strong>无序</strong>：存取顺序不一致<br><strong>不重复</strong>：可以去除重复<br><strong>无索引</strong>：没有带索引的方法，所以不能使用普通fo循环遍历，也不能通过索引来获取元素。</p><h6 id="Set集合实现类特点"><a href="#Set集合实现类特点" class="headerlink" title="Set集合实现类特点"></a>Set集合实现类特点</h6><p><strong>HashSet</strong>:无序、不重复、无索引。<br><strong>LinkedHashSet</strong>:有序、不重复、无索引。<br><strong>TreeSet</strong>:排序、不重复、无索引。</p><h6 id="HashSet底层原理"><a href="#HashSet底层原理" class="headerlink" title="HashSet底层原理"></a>HashSet底层原理</h6><ul><li>HashSets集合底层采取哈希表存储的数据。</li><li>哈希表是一种对于增删改查数据性能都较好的结构。</li></ul><h6 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h6><ul><li>是JDK根据对象的地址，按照某种规则算出来的it类型的数值。</li><li>Object类的API:public int hashCode（）:返回对象的哈希值</li></ul><h6 id="对象的哈希值特点"><a href="#对象的哈希值特点" class="headerlink" title="对象的哈希值特点"></a>对象的哈希值特点</h6><ul><li>同一个对象多次调用nashCode(O方法返回的哈希值是相同的</li><li>默认情况下，不同对象的哈希值是不同的。</li><li><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230320143432642.png" alt="image-20230320143432642"></li></ul><ol><li><p>创建一个默认长度16的数组，数组名table</p></li><li><p>根据元素的哈希值跟数组的长度求余计算出应存入的位置（哈希算法）</p></li><li><p>判断当前位置是否为null,如果是null直接存入</p></li><li><p>如果位置不为null,表示有元素，则调用equals方法比较</p></li><li><p>如果一样，则不存，如果不一样，则存入数组，</p><ul><li><p>​    DK7新元素占老元素位置，指向老元素</p></li><li><p>​    JDK8中新元素挂在老元素下面</p></li></ul></li></ol><h6 id="JDK1-8版本开始HashSet原理解析"><a href="#JDK1-8版本开始HashSet原理解析" class="headerlink" title="JDK1.8版本开始HashSet原理解析"></a>JDK1.8版本开始HashSet原理解析</h6><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220426143547400.png" alt="image-20220426143547400"></p><p>1.底层结构：哈希表(数组、链表、红黑树的结合体)。<br>2.当挂在元素下面的数据过多时，查询性能降低，从JDK8开始后，当链表长度超过8的时候，自动转换为红黑树。</p><h6 id="2-哈希表的详细流程"><a href="#2-哈希表的详细流程" class="headerlink" title="2.哈希表的详细流程"></a>2.哈希表的详细流程</h6><p>①创建一个默认长度16，默认加载因为0.75的数组，数组名table。<br>②根据元素的哈希值跟数组的长度计算出应存入的位置。<br>③判断当前位置是否为nul,如果是nul直接存入，如果位置不为null,表示有元素则调用equals方法比较属性值，如果一样，则不存，如果不一样，则存入数组。<br>④当数组存满到16*0.75=12时，就自动扩容，每次扩容原先的两倍</p><p>结论：如果希望Set集合认为2个内容一样的对象是重复的，必须重写对象的hashCode()和equals()方法</p><h6 id="linkhashset原理："><a href="#linkhashset原理：" class="headerlink" title="linkhashset原理："></a>linkhashset原理：</h6><p>原理：底层数据结构是依然哈希表，只是每个元素又额外的多了一个双链表的机制记录存储的顺序。</p><h6 id="TreeSet集合概述和特点"><a href="#TreeSet集合概述和特点" class="headerlink" title="TreeSet集合概述和特点"></a>TreeSet集合概述和特点</h6><p>不重复、无索引、可排序<br>可排序：按照元素的大小默认升序（有小到大）排序。<br>TreeSet集合底层是基于红黑树的数据结构实现排序的，增删改查性能好。<br>注意：TreeSet集合是一定要排序的，可以将元素按照指定的规则进行序。</p><p>2.TreeSet集合自定义排序规则有几种方式<br>●2种。<br>●类实现Comparable接口，重写比较规则。<br>●集合自定义Comparator比较器对象，重写比较规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Apple&gt;&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String color;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> price;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> weight;<br>    .<br>    .<br>    .<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">      方式一：类自定义比较规则</span><br><span class="hljs-comment">      o1.compareTo(o2)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> o</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Apple o)</span> &#123;<br>        <span class="hljs-comment">// 按照重量进行比较的</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.weight - o.weight ; <span class="hljs-comment">// 去重重量重复的元素</span><br>        <span class="hljs-comment">// return this.weight - o.weight &gt;= 0 ? 1 : -1; // 保留重量重复的元素</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SetDemo5</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Set&lt;Integer&gt; sets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;(); <span class="hljs-comment">// 不重复 无索引 可排序</span><br>        sets.add(<span class="hljs-number">23</span>);<br>        sets.add(<span class="hljs-number">24</span>);<br>        sets.add(<span class="hljs-number">12</span>);<br>        sets.add(<span class="hljs-number">8</span>);<br>        System.out.println(sets);<br><br>        Set&lt;String&gt; sets1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;(); <span class="hljs-comment">// 不重复 无索引 可排序</span><br>        sets1.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        sets1.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        sets1.add(<span class="hljs-string">&quot;angela&quot;</span>);<br>        sets1.add(<span class="hljs-string">&quot;黑马&quot;</span>);<br>        sets1.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        sets1.add(<span class="hljs-string">&quot;About&quot;</span>);<br>        sets1.add(<span class="hljs-string">&quot;Python&quot;</span>);<br>        sets1.add(<span class="hljs-string">&quot;UI&quot;</span>);<br>        sets1.add(<span class="hljs-string">&quot;UI&quot;</span>);<br>        System.out.println(sets1);<br><br>        System.out.println(<span class="hljs-string">&quot;------------------------------&quot;</span>);<br>        <span class="hljs-comment">// 方式二：集合自带比较器对象进行规则定制</span><br>        <span class="hljs-comment">//</span><br><span class="hljs-comment">//        Set&lt;Apple&gt; apples = new TreeSet&lt;&gt;(new Comparator&lt;Apple&gt;() &#123;</span><br><span class="hljs-comment">//            @Override</span><br><span class="hljs-comment">//            public int compare(Apple o1, Apple o2) &#123;</span><br><span class="hljs-comment">//                // return o1.getWeight() - o2.getWeight(); // 升序</span><br><span class="hljs-comment">//                // return o2.getWeight() - o1.getWeight(); // 降序</span><br><span class="hljs-comment">//                // 注意：浮点型建议直接使用Double.compare进行比较</span><br><span class="hljs-comment">//                // return Double.compare(o1.getPrice() , o2.getPrice()); // 升序</span><br><span class="hljs-comment">//                return Double.compare(o2.getPrice() , o1.getPrice()); // 降序</span><br><span class="hljs-comment">//            &#125;</span><br><span class="hljs-comment">//        &#125;);</span><br><br>        Set&lt;Apple&gt; apples = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;(( o1,  o2) -&gt;  Double.compare(o2.getPrice() , o1.getPrice())  );<br>        apples.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>(<span class="hljs-string">&quot;红富士&quot;</span>, <span class="hljs-string">&quot;红色&quot;</span>, <span class="hljs-number">9.9</span>, <span class="hljs-number">500</span>));<br>        apples.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>(<span class="hljs-string">&quot;青苹果&quot;</span>, <span class="hljs-string">&quot;绿色&quot;</span>, <span class="hljs-number">15.9</span>, <span class="hljs-number">300</span>));<br>        apples.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>(<span class="hljs-string">&quot;绿苹果&quot;</span>, <span class="hljs-string">&quot;青色&quot;</span>, <span class="hljs-number">29.9</span>, <span class="hljs-number">400</span>));<br>        apples.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>(<span class="hljs-string">&quot;黄苹果&quot;</span>, <span class="hljs-string">&quot;黄色&quot;</span>, <span class="hljs-number">9.8</span>, <span class="hljs-number">500</span>));<br>        System.out.println(apples);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>1.如果希望元素可以重复，又有索引，索引查询要快？<br>    ●用ArrayList?集合，基于数组的。（用的最多）<br>2.如果希望元素可以重复，又有索引，增删首尾操作快？<br>    ●用LinkedList集合，基于链表的。<br>3.如果希望增删改查都快，但是元素不重复、无序、无索引。<br>    ●用HashSet集合，基于哈希表的。<br>4.如果希望增删改查都快，但是元素不重复、有序、无索引。<br>    ●用LinkedHashSet集合，基于哈希表和双链表。<br>5.如果要对对象进行排序。<br>    ●用TreeSet:集合，基于红黑树。后续也可以用List集合实现排序。</p><h6 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h6><p>●可变参数用在形参中可以接收多个数据。<br>可变参数的格式：数据类型…参数名称<br><strong>可变参数的作用</strong><br>●传输参数非常灵活，方便。可以不传输参数，可以传输1个或者多个，也可以传输一个数组</p><p>●可变参数在方法内部本质上就是一个数组。</p><p><strong>可变参数的注意事项：</strong><br>●1.一个形参列表中可变参数只能有一个<br>●2.可变参数必须放在形参列表的最后面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        sum(); <span class="hljs-comment">// 1、不传参数</span><br>        sum(<span class="hljs-number">10</span>); <span class="hljs-comment">// 2、可以传输一个参数</span><br>        sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>); <span class="hljs-comment">// 3、可以传输多个参数</span><br>        sum(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;); <span class="hljs-comment">// 4、可以传输一个数组</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">       注意：一个形参列表中只能有一个可变参数,可变参数必须放在形参列表的最后面</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nums</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(  <span class="hljs-type">int</span>...nums)</span>&#123;<br>        <span class="hljs-comment">// 注意：可变参数在方法内部其实就是一个数组。 nums</span><br>        System.out.println(<span class="hljs-string">&quot;元素个数：&quot;</span> + nums.length);<br>        System.out.println(<span class="hljs-string">&quot;元素内容：&quot;</span> + Arrays.toString(nums));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：Collections工具类的使用。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    java.utils.Collections:是集合工具类</span><br><span class="hljs-comment">    Collections并不属于集合，是用来操作集合的工具类。</span><br><span class="hljs-comment">    Collections有几个常用的API:</span><br><span class="hljs-comment">         - public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c, T... elements)</span><br><span class="hljs-comment">             给集合对象批量添加元素！</span><br><span class="hljs-comment">         - public static void shuffle(List&lt;?&gt; list) :打乱集合顺序。</span><br><span class="hljs-comment">         - public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。</span><br><span class="hljs-comment">         - public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; c):将集合中元素按照指定规则排序。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectionsDemo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">//names.add(&quot;楚留香&quot;);</span><br>        <span class="hljs-comment">//names.add(&quot;胡铁花&quot;);</span><br>        <span class="hljs-comment">//names.add(&quot;张无忌&quot;);</span><br>        <span class="hljs-comment">//names.add(&quot;陆小凤&quot;);</span><br>        Collections.addAll(names, <span class="hljs-string">&quot;楚留香&quot;</span>,<span class="hljs-string">&quot;胡铁花&quot;</span>, <span class="hljs-string">&quot;张无忌&quot;</span>,<span class="hljs-string">&quot;陆小凤&quot;</span>);<br>        System.out.println(names);<br><br>        <span class="hljs-comment">// 2、public static void shuffle(List&lt;?&gt; list) :打乱集合顺序。</span><br>        Collections.shuffle(names);<br>        System.out.println(names);<br><br>        <span class="hljs-comment">// 3、 public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。 （排值特性的元素）</span><br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Collections.addAll(list, <span class="hljs-number">12</span>, <span class="hljs-number">23</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>);<br>        System.out.println(list);<br>        Collections.sort(list);<br>        System.out.println(list);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：引用数据类型的排序。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    字符串按照首字符的编号升序排序！</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    自定义类型的比较方法API:Collections</span><br><span class="hljs-comment">         - public static &lt;T&gt; void sort(List&lt;T&gt; list):</span><br><span class="hljs-comment">               将集合中元素按照默认规则排序。</span><br><span class="hljs-comment">               对于自定义的引用类型的排序人家根本不知道怎么排，直接报错！</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">         - public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; c):</span><br><span class="hljs-comment">                将集合中元素按照指定规则排序,自带比较器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectionsDemo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Apple&gt; apples = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// 可以重复！</span><br>        apples.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>(<span class="hljs-string">&quot;红富士&quot;</span>, <span class="hljs-string">&quot;红色&quot;</span>, <span class="hljs-number">9.9</span>, <span class="hljs-number">500</span>));<br>        apples.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>(<span class="hljs-string">&quot;青苹果&quot;</span>, <span class="hljs-string">&quot;绿色&quot;</span>, <span class="hljs-number">15.9</span>, <span class="hljs-number">300</span>));<br>        apples.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>(<span class="hljs-string">&quot;绿苹果&quot;</span>, <span class="hljs-string">&quot;青色&quot;</span>, <span class="hljs-number">29.9</span>, <span class="hljs-number">400</span>));<br>        apples.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>(<span class="hljs-string">&quot;黄苹果&quot;</span>, <span class="hljs-string">&quot;黄色&quot;</span>, <span class="hljs-number">9.8</span>, <span class="hljs-number">500</span>));<br><br><span class="hljs-comment">//        Collections.sort(apples); // 方法一：可以的，Apple类已经重写了比较规则</span><br><span class="hljs-comment">//        System.out.println(apples);</span><br><br>        <span class="hljs-comment">// 方式二：sort方法自带比较器对象</span><br><span class="hljs-comment">//        Collections.sort(apples, new Comparator&lt;Apple&gt;() &#123;</span><br><span class="hljs-comment">//            @Override</span><br><span class="hljs-comment">//            public int compare(Apple o1, Apple o2) &#123;</span><br><span class="hljs-comment">//                return Double.compare(o1.getPrice() , o2.getPrice()); // 按照价格排序！！</span><br><span class="hljs-comment">//            &#125;</span><br><span class="hljs-comment">//        &#125;);</span><br><br>        Collections.sort(apples, ( o1,  o2) -&gt;  Double.compare(o1.getPrice() , o2.getPrice()) );<br>        System.out.println(apples);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="斗地主发牌案例："><a href="#斗地主发牌案例：" class="headerlink" title="斗地主发牌案例："></a>斗地主发牌案例：</h6><p>能把Collection和Collections串起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Card</span> &#123;<br>    <span class="hljs-keyword">private</span> String size;<br>    <span class="hljs-keyword">private</span> String color;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> index; <span class="hljs-comment">// 牌的真正大小</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Card</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Card</span><span class="hljs-params">(String size, String color, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-built_in">this</span>.size = size;<br>        <span class="hljs-built_in">this</span>.color = color;<br>        <span class="hljs-built_in">this</span>.index = index;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSize</span><span class="hljs-params">(String size)</span> &#123;<br>        <span class="hljs-built_in">this</span>.size = size;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getColor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> color;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setColor</span><span class="hljs-params">(String color)</span> &#123;<br>        <span class="hljs-built_in">this</span>.color = color;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getIndex</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> index;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-built_in">this</span>.index = index;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size + color;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：斗地主游戏的案例开发。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    业务需求分析:</span><br><span class="hljs-comment">        斗地主的做牌, 洗牌, 发牌, 排序（拓展知识）, 看牌。</span><br><span class="hljs-comment">        业务: 总共有54张牌。</span><br><span class="hljs-comment">        点数: &quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;J&quot;,&quot;Q&quot;,&quot;K&quot;,&quot;A&quot;,&quot;2&quot;</span><br><span class="hljs-comment">        花色: &quot;♠&quot;, &quot;♥&quot;, &quot;♣&quot;, &quot;♦&quot;</span><br><span class="hljs-comment">        大小王: &quot;👲&quot; , &quot;🃏&quot;</span><br><span class="hljs-comment">        点数分别要组合4种花色，大小王各一张。</span><br><span class="hljs-comment">        斗地主：发出51张牌，剩下3张作为底牌。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    功能：</span><br><span class="hljs-comment">        1.做牌。</span><br><span class="hljs-comment">        2.洗牌。</span><br><span class="hljs-comment">        3.定义3个玩家</span><br><span class="hljs-comment">        4.发牌。</span><br><span class="hljs-comment">        5.排序（拓展，了解，作业）</span><br><span class="hljs-comment">        6.看牌</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GameDemo</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">      1、定义一个静态的集合存储54张牌对象</span><br><span class="hljs-comment">     */</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Card&gt; allCards = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">      2、做牌：定义静态代码块初始化牌数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">// 3、定义点数：个数确定，类型确定，使用数组</span><br>        String[] sizes = &#123;<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;10&quot;</span>,<span class="hljs-string">&quot;J&quot;</span>,<span class="hljs-string">&quot;Q&quot;</span>,<span class="hljs-string">&quot;K&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>&#125;;<br>        <span class="hljs-comment">// 4、定义花色：个数确定，类型确定，使用数组</span><br>        String[] colors = &#123;<span class="hljs-string">&quot;♠&quot;</span>, <span class="hljs-string">&quot;♥&quot;</span>, <span class="hljs-string">&quot;♣&quot;</span>, <span class="hljs-string">&quot;♦&quot;</span>&#125;;<br>        <span class="hljs-comment">// 5、组合点数和花色</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录牌的大小</span><br>        <span class="hljs-keyword">for</span> (String size : sizes) &#123;<br>            index++;<br>            <span class="hljs-keyword">for</span> (String color : colors) &#123;<br>                <span class="hljs-comment">// 6、封装成一个牌对象。</span><br>                <span class="hljs-type">Card</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Card</span>(size, color, index);<br>                <span class="hljs-comment">// 7、存入到集合容器中去</span><br>                allCards.add(c);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 8 大小王存入到集合对象中去 &quot;👲&quot; , &quot;🃏&quot;</span><br>        <span class="hljs-type">Card</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Card</span>(<span class="hljs-string">&quot;&quot;</span> ,  <span class="hljs-string">&quot;🃏&quot;</span>, ++index);<br>        <span class="hljs-type">Card</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Card</span>(<span class="hljs-string">&quot;&quot;</span> ,  <span class="hljs-string">&quot;👲&quot;</span>,++index);<br>        Collections.addAll(allCards , c1 , c2);<br>        System.out.println(<span class="hljs-string">&quot;新牌：&quot;</span> + allCards);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 9、洗牌</span><br>        Collections.shuffle(allCards);<br>        System.out.println(<span class="hljs-string">&quot;洗牌后：&quot;</span> + allCards);<br><br>        <span class="hljs-comment">// 10、发牌（定义三个玩家，每个玩家的牌也是一个集合容器）</span><br>        List&lt;Card&gt; linhuchong = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Card&gt; jiumozhi = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Card&gt; renyingying = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-comment">// 11、开始发牌（从牌集合中发出51张牌给三个玩家，剩余3张作为底牌）</span><br>        <span class="hljs-comment">// allCards = [🃏, A♠, 5♥, 2♠, 2♣, Q♣, 👲, Q♠ ...</span><br>        <span class="hljs-comment">//    i        0  1   2   3   4   5    6  7      %  3</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; allCards.size() - <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-comment">// 先拿到当前牌对象</span><br>            <span class="hljs-type">Card</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> allCards.get(i);<br>            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 请阿冲接牌</span><br>                linhuchong.add(c);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i % <span class="hljs-number">3</span> == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-comment">// 请阿鸠</span><br>                jiumozhi.add(c);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i % <span class="hljs-number">3</span> == <span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-comment">// 请盈盈接牌</span><br>                renyingying.add(c);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 12、拿到最后三张底牌(把最后三张牌截取成一个子集合)</span><br>        List&lt;Card&gt; lastThreeCards = allCards.subList(allCards.size() - <span class="hljs-number">3</span> , allCards.size());<br><br>        <span class="hljs-comment">// 13、给玩家的牌排序（从大到小 可以自己先试试怎么实现）</span><br>        sortCards(linhuchong);<br>        sortCards(jiumozhi);<br>        sortCards(renyingying);<br><br>        <span class="hljs-comment">// 14、输出玩家的牌：</span><br>        System.out.println(<span class="hljs-string">&quot;啊冲：&quot;</span> + linhuchong);<br>        System.out.println(<span class="hljs-string">&quot;啊鸠：&quot;</span> + jiumozhi);<br>        System.out.println(<span class="hljs-string">&quot;盈盈：&quot;</span> + renyingying);<br>        System.out.println(<span class="hljs-string">&quot;三张底牌：&quot;</span> + lastThreeCards);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">       给牌排序</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cards</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortCards</span><span class="hljs-params">(List&lt;Card&gt; cards)</span> &#123;<br>        <span class="hljs-comment">// cards = [J♥, A♦, 3♥, 🃏, 5♦, Q♥, 2♥</span><br>        Collections.sort(cards, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Card&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Card o1, Card o2)</span> &#123;<br>                <span class="hljs-comment">// o1 = J♥</span><br>                <span class="hljs-comment">// o2 = A♦</span><br>                <span class="hljs-comment">// 知道牌的大小，才可以指定规则</span><br>                <span class="hljs-keyword">return</span> o2.getIndex() - o1.getIndex();<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h4><h6 id="Map集合概述和使用"><a href="#Map集合概述和使用" class="headerlink" title="Map集合概述和使用"></a>Map集合概述和使用</h6><ul><li>Map集合是一种双列集合，每个元素包含两个数据。</li><li>Map集合的每个元素的格式：key=value（键值对元素）。</li><li>Map集合也被称为“键值对集合”。</li></ul><h6 id="Map集合整体格式："><a href="#Map集合整体格式：" class="headerlink" title="Map集合整体格式："></a>Map集合整体格式：</h6><ul><li>Collection集合的格式：[元素1，元素2，元素3.]</li><li>Map集合的完整格式：{key1=value1,key2=value2,key3=value.3,…</li></ul><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220426154833924.png" alt="image-20220426154833924"></p><h6 id="Map集合体系特点"><a href="#Map集合体系特点" class="headerlink" title="Map集合体系特点"></a>Map集合体系特点</h6><ul><li>Map集合的特点都是由键决定的。</li><li>Map集合的键是无序，不重复的，无索引的，值不做要求（可以重复）。</li><li>Map集合后面重复的键对应的值会覆盖前面重复键的值。</li><li>Map集合的键值对都可以为nul.</li></ul><h6 id="Map集合实现类特点"><a href="#Map集合实现类特点" class="headerlink" title="Map集合实现类特点"></a>Map集合实现类特点</h6><ul><li><p>HashMap:元素按照键是无序，不重复，无索引，值不做要求。(与Map体系一致)</p></li><li><p>LinkedHashMap:元素按照键是有序，不重复，无索引，值不做要求。</p><p>原理：底层数据结构是依然哈希表，只是每个键值对元素又额外的多了一个双链表的机制记录存储的顺序。</p></li><li><p>TreeMap:元素按照建是排序，不重复，无索引的，值不做要求。</p></li></ul><h6 id="Map常用API"><a href="#Map常用API" class="headerlink" title="Map常用API"></a>Map常用API</h6><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>V  put(K key,V value)</td><td>添加元素</td></tr><tr><td>V  remove(Object key)</td><td>根据键删除键值对元素</td></tr><tr><td>void  clear()</td><td>移除所有的键值对元素</td></tr><tr><td>boolean containsKey(Object key)</td><td>判断集合是否包含指定的键</td></tr><tr><td>boolean containsValue(Object value)</td><td>判断集合是否包含指定的值</td></tr><tr><td>boolean isEmpty()</td><td>判断集合是否为空</td></tr><tr><td>int  size()</td><td>集合的长度，也就是集合中键值对的个数</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：Map集合的常用API(重点中的重点)</span><br><span class="hljs-comment">     - public V put(K key, V value):  把指定的键与指定的值添加到Map集合中。</span><br><span class="hljs-comment">     - public V remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</span><br><span class="hljs-comment">     - public V get(Object key) 根据指定的键，在Map集合中获取对应的值。</span><br><span class="hljs-comment">     - public Set&lt;K&gt; keySet(): 获取Map集合中所有的键，存储到Set集合中。</span><br><span class="hljs-comment">     - public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。</span><br><span class="hljs-comment">     - public boolean containKey(Object key):判断该集合中是否有此键。</span><br><span class="hljs-comment">     - public boolean containValue(Object value):判断该集合中是否有此值。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1.添加元素: 无序，不重复，无索引。</span><br>        Map&lt;String , Integer&gt; maps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        maps.put(<span class="hljs-string">&quot;iphoneX&quot;</span>,<span class="hljs-number">10</span>);<br>        maps.put(<span class="hljs-string">&quot;娃娃&quot;</span>,<span class="hljs-number">20</span>);<br>        maps.put(<span class="hljs-string">&quot;iphoneX&quot;</span>,<span class="hljs-number">100</span>);<span class="hljs-comment">//  Map集合后面重复的键对应的元素会覆盖前面重复的整个元素！</span><br>        maps.put(<span class="hljs-string">&quot;huawei&quot;</span>,<span class="hljs-number">100</span>);<br>        maps.put(<span class="hljs-string">&quot;生活用品&quot;</span>,<span class="hljs-number">10</span>);<br>        maps.put(<span class="hljs-string">&quot;手表&quot;</span>,<span class="hljs-number">10</span>);<br>        <span class="hljs-comment">// &#123;huawei=100, 手表=10, 生活用品=10, iphoneX=100, 娃娃=20&#125;</span><br>        System.out.println(maps);<br><br>        <span class="hljs-comment">// 2.清空集合</span><br><span class="hljs-comment">//        maps.clear();</span><br><span class="hljs-comment">//        System.out.println(maps);</span><br><br>        <span class="hljs-comment">// 3.判断集合是否为空，为空返回true ,反之！</span><br>        System.out.println(maps.isEmpty());<br><br>        <span class="hljs-comment">// 4.根据键获取对应值:public V get(Object key)</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> maps.get(<span class="hljs-string">&quot;huawei&quot;</span>);<br>        System.out.println(key);<br>        System.out.println(maps.get(<span class="hljs-string">&quot;生活用品&quot;</span>)); <span class="hljs-comment">// 10</span><br>        System.out.println(maps.get(<span class="hljs-string">&quot;生活用品2&quot;</span>)); <span class="hljs-comment">// null</span><br><br>        <span class="hljs-comment">// 5.根据键删除整个元素。(删除键会返回键的值)</span><br>        System.out.println(maps.remove(<span class="hljs-string">&quot;iphoneX&quot;</span>));<br>        System.out.println(maps);<br><br>        <span class="hljs-comment">// 6.判断是否包含某个键 ，包含返回true ,反之</span><br>        System.out.println(maps.containsKey(<span class="hljs-string">&quot;娃娃&quot;</span>));  <span class="hljs-comment">// true</span><br>        System.out.println(maps.containsKey(<span class="hljs-string">&quot;娃娃2&quot;</span>));  <span class="hljs-comment">// false</span><br>        System.out.println(maps.containsKey(<span class="hljs-string">&quot;iphoneX&quot;</span>)); <span class="hljs-comment">// false</span><br><br>        <span class="hljs-comment">// 7.判断是否包含某个值。</span><br>        System.out.println(maps.containsValue(<span class="hljs-number">100</span>));  <span class="hljs-comment">//</span><br>        System.out.println(maps.containsValue(<span class="hljs-number">10</span>));  <span class="hljs-comment">//</span><br>        System.out.println(maps.containsValue(<span class="hljs-number">22</span>)); <span class="hljs-comment">//</span><br><br>        <span class="hljs-comment">// &#123;huawei=100, 手表=10, 生活用品=10, 娃娃=20&#125;</span><br>        <span class="hljs-comment">// 8.获取全部键的集合：public Set&lt;K&gt; keySet()</span><br>        Set&lt;String&gt; keys = maps.keySet();<br>        System.out.println(keys);<br><br>        System.out.println(<span class="hljs-string">&quot;------------------------------&quot;</span>);<br>        <span class="hljs-comment">// 9.获取全部值的集合：Collection&lt;V&gt; values();</span><br>        Collection&lt;Integer&gt; values = maps.values();<br>        System.out.println(values);<br><br>        <span class="hljs-comment">// 10.集合的大小</span><br>        System.out.println(maps.size()); <span class="hljs-comment">// 4</span><br><br>        <span class="hljs-comment">// 11.合并其他Map集合。(拓展)</span><br>        Map&lt;String , Integer&gt; map1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map1.put(<span class="hljs-string">&quot;java1&quot;</span>, <span class="hljs-number">1</span>);<br>        map1.put(<span class="hljs-string">&quot;java2&quot;</span>, <span class="hljs-number">100</span>);<br>        Map&lt;String , Integer&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map2.put(<span class="hljs-string">&quot;java2&quot;</span>, <span class="hljs-number">1</span>);<br>        map2.put(<span class="hljs-string">&quot;java3&quot;</span>, <span class="hljs-number">100</span>);<br>        map1.putAll(map2); <span class="hljs-comment">// 把集合map2的元素拷贝一份到map1中去</span><br>        System.out.println(map1);<br>        System.out.println(map2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="Map三种遍历方式"><a href="#Map三种遍历方式" class="headerlink" title="Map三种遍历方式"></a>Map三种遍历方式</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：Map集合的遍历方式一：键找值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Map集合的遍历方式有：3种。</span><br><span class="hljs-comment">        （1）“键找值”的方式遍历：先获取Map集合全部的键，再根据遍历键找值。</span><br><span class="hljs-comment">        （2）“键值对”的方式遍历：难度较大。</span><br><span class="hljs-comment">        （3）JDK 1.8开始之后的新技术：Lambda表达式。（暂时了解）</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    a.“键找值”的方式遍历Map集合。</span><br><span class="hljs-comment">        1.先获取Map集合的全部键的Set集合。</span><br><span class="hljs-comment">        2.遍历键的Set集合，然后通过键找值。</span><br><span class="hljs-comment">    小结：</span><br><span class="hljs-comment">        代码简单，需要记住!</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapDemo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Map&lt;String , Integer&gt; maps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">// 1.添加元素: 无序，不重复，无索引。</span><br>        maps.put(<span class="hljs-string">&quot;娃娃&quot;</span>,<span class="hljs-number">30</span>);<br>        maps.put(<span class="hljs-string">&quot;iphoneX&quot;</span>,<span class="hljs-number">100</span>);<br>        maps.put(<span class="hljs-string">&quot;huawei&quot;</span>,<span class="hljs-number">1000</span>);<br>        maps.put(<span class="hljs-string">&quot;生活用品&quot;</span>,<span class="hljs-number">10</span>);<br>        maps.put(<span class="hljs-string">&quot;手表&quot;</span>,<span class="hljs-number">10</span>);<br>        System.out.println(maps);<br>        <span class="hljs-comment">// maps = &#123;huawei=1000, 手表=10, 生活用品=10, iphoneX=100, 娃娃=30&#125;</span><br><br>        <span class="hljs-comment">// 1、键找值：第一步：先拿到集合的全部键。</span><br>        Set&lt;String&gt; keys = maps.keySet();<br>        <span class="hljs-comment">// 2、第二步：遍历每个键，根据键提取值</span><br>        <span class="hljs-keyword">for</span> (String key : keys) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> maps.get(key);<br>            System.out.println(key + <span class="hljs-string">&quot;===&gt;&quot;</span> + value);<br>        &#125;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：Map集合的遍历方式。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Map集合的遍历方式有：3种。</span><br><span class="hljs-comment">        （1）“键找值”的方式遍历：先获取Map集合全部的键，再根据键找值。</span><br><span class="hljs-comment">        （2）“键值对”的方式遍历：难度较大。</span><br><span class="hljs-comment">        （3）JDK 1.8开始之后的新技术：Lambda表达式。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    b.“键值对”的方式遍历：</span><br><span class="hljs-comment">        1.把Map集合转换成一个Set集合:Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</span><br><span class="hljs-comment">        2.此时键值对元素的类型就确定了，类型是键值对实体类型：Map.Entry&lt;K, V&gt;</span><br><span class="hljs-comment">        3.接下来就可以用foreach遍历这个Set集合，类型用Map.Entry&lt;K, V&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapDemo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Map&lt;String , Integer&gt; maps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">// 1.添加元素: 无序，不重复，无索引。</span><br>        maps.put(<span class="hljs-string">&quot;娃娃&quot;</span>,<span class="hljs-number">30</span>);<br>        maps.put(<span class="hljs-string">&quot;iphoneX&quot;</span>,<span class="hljs-number">100</span>);<br>        maps.put(<span class="hljs-string">&quot;huawei&quot;</span>,<span class="hljs-number">1000</span>);<br>        maps.put(<span class="hljs-string">&quot;生活用品&quot;</span>,<span class="hljs-number">10</span>);<br>        maps.put(<span class="hljs-string">&quot;手表&quot;</span>,<span class="hljs-number">10</span>);<br>        System.out.println(maps);<br>        <span class="hljs-comment">// maps = &#123;huawei=1000, 手表=10, 生活用品=10, iphoneX=100, 娃娃=30&#125;</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">            maps = &#123;huawei=1000, 手表=10, 生活用品=10, iphoneX=100, 娃娃=30&#125;</span><br><span class="hljs-comment">                👇</span><br><span class="hljs-comment">            使用foreach遍历map集合.发现Map集合的键值对元素直接是没有类型的。所以不可以直接foreach遍历集合。</span><br><span class="hljs-comment">                👇</span><br><span class="hljs-comment">            可以通过调用Map的方法 entrySet把Map集合转换成Set集合形式  maps.entrySet();</span><br><span class="hljs-comment">                👇</span><br><span class="hljs-comment">            Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entries =  maps.entrySet();</span><br><span class="hljs-comment">             [(huawei=1000), (手表=10), (生活用品=10), (iphoneX=100), (娃娃=30)]</span><br><span class="hljs-comment">                              entry</span><br><span class="hljs-comment">                👇</span><br><span class="hljs-comment">            此时可以使用foreach遍历</span><br><span class="hljs-comment">       */</span><br>       <span class="hljs-comment">// 1、把Map集合转换成Set集合</span><br>        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = maps.entrySet();<br>        <span class="hljs-comment">// 2、开始遍历</span><br>        <span class="hljs-keyword">for</span>(Map.Entry&lt;String, Integer&gt; entry : entries)&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> entry.getKey();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> entry.getValue();<br>            System.out.println(key + <span class="hljs-string">&quot;====&gt;&quot;</span> + value);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：Map集合的遍历方式。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Map集合的遍历方式有：3种。</span><br><span class="hljs-comment">        （1）“键找值”的方式遍历：先获取Map集合全部的键，再根据键找值。</span><br><span class="hljs-comment">        （2）“键值对”的方式遍历：难度较大。</span><br><span class="hljs-comment">        （3）JDK 1.8开始之后的新技术：Lambda表达式。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    c.JDK 1.8开始之后的新技术：Lambda表达式。（暂时了解）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapDemo03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Map&lt;String , Integer&gt; maps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">// 1.添加元素: 无序，不重复，无索引。</span><br>        maps.put(<span class="hljs-string">&quot;娃娃&quot;</span>,<span class="hljs-number">30</span>);<br>        maps.put(<span class="hljs-string">&quot;iphoneX&quot;</span>,<span class="hljs-number">100</span>);<span class="hljs-comment">//  Map集合后面重复的键对应的元素会覆盖前面重复的整个元素！</span><br>        maps.put(<span class="hljs-string">&quot;huawei&quot;</span>,<span class="hljs-number">1000</span>);<br>        maps.put(<span class="hljs-string">&quot;生活用品&quot;</span>,<span class="hljs-number">10</span>);<br>        maps.put(<span class="hljs-string">&quot;手表&quot;</span>,<span class="hljs-number">10</span>);<br>        System.out.println(maps);<br><br>        <span class="hljs-comment">//  maps = &#123;huawei=1000, 手表=10, 生活用品=10, iphoneX=100, 娃娃=30&#125;</span><br><br><span class="hljs-comment">//        maps.forEach(new BiConsumer&lt;String, Integer&gt;() &#123;</span><br><span class="hljs-comment">//            @Override</span><br><span class="hljs-comment">//            public void accept(String key, Integer value) &#123;</span><br><span class="hljs-comment">//                System.out.println(key + &quot;---&gt;&quot; + value);</span><br><span class="hljs-comment">//            &#125;</span><br><span class="hljs-comment">//        &#125;);</span><br><br>        maps.forEach((k, v) -&gt; &#123;<br>                System.out.println(k + <span class="hljs-string">&quot;---&gt;&quot;</span> + v);<br>        &#125;);<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>需求</strong><br>某个班级80名学生，现在需要组成秋游活动，班长提供了四个景点依次是(A、B、C、D),每个学生只能选择一个景点，请统计出最终哪个景点想去的人数最多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapTest1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>         <span class="hljs-comment">// 1、把80个学生选择的数据拿进来。</span><br>        String[] selects = &#123;<span class="hljs-string">&quot;A&quot;</span> , <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>&#125;;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">80</span>; i++) &#123;<br>            sb.append(selects[r.nextInt(selects.length)]);<br>        &#125;<br>        System.out.println(sb);<br><br>        <span class="hljs-comment">// 2、定义一个Map集合记录最终统计的结果： A=30 B=20 C=20 D=10  键是景点 值是选择的数量</span><br>        Map&lt;Character, Integer&gt; infos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(); <span class="hljs-comment">//</span><br><br>        <span class="hljs-comment">// 3、遍历80个学生选择的数据</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; sb.length(); i++) &#123;<br>            <span class="hljs-comment">// 4、提取当前选择景点字符</span><br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> sb.charAt(i);<br>            <span class="hljs-comment">// 5、判断Map集合中是否存在这个键</span><br>            <span class="hljs-keyword">if</span>(infos.containsKey(ch))&#123;<br>                 <span class="hljs-comment">// 让其值 + 1</span><br>                infos.put(ch , infos.get(ch) + <span class="hljs-number">1</span>);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 说明此景点是第一次被选</span><br>                infos.put(ch , <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 4、输出集合</span><br>        System.out.println(infos);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="集合嵌套"><a href="#集合嵌套" class="headerlink" title="集合嵌套"></a>集合嵌套</h6><p>某个班级多名学生，现在需要组成秋游活动，班长提供了四个景点依次是(A、B、C、D),每个学生可以选择多个景点，请统计出最终哪个景点想去的人数最多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapTest4</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1、要求程序记录每个学生选择的情况。</span><br>        <span class="hljs-comment">// 使用一个Map集合存储。</span><br>        Map&lt;String, List&lt;String&gt;&gt; data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>        <span class="hljs-comment">// 2、把学生选择的数据存入进去。</span><br>        List&lt;String&gt; selects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Collections.addAll(selects, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>);<br>        data.put(<span class="hljs-string">&quot;罗勇&quot;</span>, selects);<br><br>        List&lt;String&gt; selects1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Collections.addAll(selects1, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span> , <span class="hljs-string">&quot;D&quot;</span>);<br>        data.put(<span class="hljs-string">&quot;胡涛&quot;</span>, selects1);<br><br>        List&lt;String&gt; selects2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Collections.addAll(selects2 , <span class="hljs-string">&quot;A&quot;</span>,  <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span> , <span class="hljs-string">&quot;D&quot;</span>);<br>        data.put(<span class="hljs-string">&quot;刘军&quot;</span>, selects2);<br><br>        System.out.println(data);<br><br>        <span class="hljs-comment">// 3、统计每个景点选择的人数。</span><br>        Map&lt;String, Integer&gt; infos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(); <span class="hljs-comment">// &#123;&#125;</span><br><br>        <span class="hljs-comment">// 4、提取所有人选择的景点的信息。</span><br>        Collection&lt;List&lt;String&gt;&gt; values = data.values();<br>        System.out.println(values);<br>        <span class="hljs-comment">// values = [[A, B, C, D], [B, C, D], [A, C]]</span><br>        <span class="hljs-comment">//             value</span><br><br>        <span class="hljs-keyword">for</span> (List&lt;String&gt; value : values) &#123;<br>            <span class="hljs-keyword">for</span> (String s : value) &#123;<br>                <span class="hljs-comment">// 有没有包含这个景点</span><br>                <span class="hljs-keyword">if</span>(infos.containsKey(s))&#123;<br>                    infos.put(s, infos.get(s) + <span class="hljs-number">1</span>);<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    infos.put(s , <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        System.out.println(infos);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Stream、异常体系、日志框架"><a href="#Stream、异常体系、日志框架" class="headerlink" title="Stream、异常体系、日志框架"></a>Stream、异常体系、日志框架</h4><h6 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h6><p>定义</p><p>不可变集合，就是不可被修改的集合。<br>集合的数据项在创建的时候提供，并且在整个生命周期中都不可改变。否则报错。</p><p>如果某个数据不能被修改，把它防御性地拷贝到不可变集合中是个很好的实践。<br>或者当集合对象被不可信的库调用时，不可变形式是安全的。</p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>static  <E> List<E> of(E…elements)</td><td>创建一个具有指定元素的List集合对象</td></tr><tr><td>static  <E> Set<E> of(E…elements)</td><td>创建一个具有指定元素的Set集合对象</td></tr><tr><td>static &lt;K  , V&gt;  Map&lt;K，V&gt; of(E…elements)</td><td>创建一个具有指定元素的Map集合对象</td></tr></tbody></table><h6 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h6><p>在Java8中，得益于Lambda所带来的函数式编程，引入了一个全新Stream流概念。<br>目的：用于简化集合和数组操作的API。</p><p>初体验-&gt;对比</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Collections.addAll(names, <span class="hljs-string">&quot;张三丰&quot;</span>,<span class="hljs-string">&quot;张无忌&quot;</span>,<span class="hljs-string">&quot;周芷若&quot;</span>,<span class="hljs-string">&quot;赵敏&quot;</span>,<span class="hljs-string">&quot;张强&quot;</span>);<br>        System.out.println(names);<br><span class="hljs-comment">//</span><br><span class="hljs-comment">//        // 1、从集合中找出姓张的放到新集合</span><br><span class="hljs-comment">//        List&lt;String&gt; zhangList = new ArrayList&lt;&gt;();</span><br><span class="hljs-comment">//        for (String name : names) &#123;</span><br><span class="hljs-comment">//            if(name.startsWith(&quot;张&quot;))&#123;</span><br><span class="hljs-comment">//                zhangList.add(name);</span><br><span class="hljs-comment">//            &#125;</span><br><span class="hljs-comment">//        &#125;</span><br><span class="hljs-comment">//        System.out.println(zhangList);</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//        // 2、找名称长度是3的姓名</span><br><span class="hljs-comment">//        List&lt;String&gt; zhangThreeList = new ArrayList&lt;&gt;();</span><br><span class="hljs-comment">//        for (String name : zhangList) &#123;</span><br><span class="hljs-comment">//            if(name.length() == 3)&#123;</span><br><span class="hljs-comment">//                zhangThreeList.add(name);</span><br><span class="hljs-comment">//            &#125;</span><br><span class="hljs-comment">//        &#125;</span><br><span class="hljs-comment">//        System.out.println(zhangThreeList);</span><br><br>        <span class="hljs-comment">// 3、使用Stream实现的</span><br>        names.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>)).filter(s -&gt; s.length() == <span class="hljs-number">3</span>).forEach(s -&gt; System.out.println(s));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>1、Stream流的作用是什么，结合了什么技术？<br>    简化集合、数组操作的API。结合了Lambda表达式。<br>2、说说Stream流的思想和使用步骤。<br>    先得到集合或者数组的Stream流（就是一根传送带）。<br>    把元素放上去。<br>    然后就用这个Stream流简化的API来方便的操作元素。</p><h6 id="Stream流的三类方法"><a href="#Stream流的三类方法" class="headerlink" title="Stream流的三类方法"></a>Stream流的三类方法</h6><ul><li><p>获取Stream流</p><p>创建一条流水线，并把数据放到流水线上准备进行操作</p></li><li><p>中间方法</p><p>流水线上的操作。一次操作完毕之后，还可以继续进行其他操作。</p></li><li><p>终结方法</p><p>一个Stream流只能有一个终结方法，是流水线上的最后一个操作</p></li></ul><h6 id="集合获取Stream流的方式"><a href="#集合获取Stream流的方式" class="headerlink" title="集合获取Stream流的方式"></a>集合获取Stream流的方式</h6><p>可以使用Collection接口中的默认方法stream()生成流</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>default  Stream<E> stream()</td><td>获取当前集合对象的Stream流</td></tr></tbody></table><h6 id="数组获取Stream流的方式"><a href="#数组获取Stream流的方式" class="headerlink" title="数组获取Stream流的方式"></a>数组获取Stream流的方式</h6><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>public  static <T>  Stream<T>  stream(T[]  array)</td><td>获取当前数组的Stream流</td></tr><tr><td>public  static<T>  Stream<T>  of(T…  values)</td><td>获取当前数组/可变数据的Stream流</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     目标：Stream流的获取</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     Stream流式思想的核心：</span><br><span class="hljs-comment">                 是先得到集合或者数组的Stream流（就是一根传送带）</span><br><span class="hljs-comment">                 然后就用这个Stream流操作集合或者数组的元素。</span><br><span class="hljs-comment">                 然后用Stream流简化替代集合操作的API.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     集合获取流的API:</span><br><span class="hljs-comment">         (1) default Stream&lt;E&gt; stream();</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     小结：</span><br><span class="hljs-comment">         集合获取Stream流用: stream();</span><br><span class="hljs-comment">         数组：Arrays.stream(数组)   /  Stream.of(数组);</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamDemo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/** --------------------Collection集合获取流-------------------------------   */</span><br>        Collection&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Stream&lt;String&gt; s =  list.stream();<br><br>        <span class="hljs-comment">/** --------------------Map集合获取流-------------------------------   */</span><br>        Map&lt;String, Integer&gt; maps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">// 键流</span><br>        Stream&lt;String&gt; keyStream = maps.keySet().stream();<br>        <span class="hljs-comment">// 值流</span><br>        Stream&lt;Integer&gt; valueStream = maps.values().stream();<br>        <span class="hljs-comment">// 键值对流（拿整体）</span><br>        Stream&lt;Map.Entry&lt;String,Integer&gt;&gt; keyAndValueStream =  maps.entrySet().stream();<br><br>        <span class="hljs-comment">/** ---------------------数组获取流------------------------------   */</span><br>        String[] names = &#123;<span class="hljs-string">&quot;赵敏&quot;</span>,<span class="hljs-string">&quot;小昭&quot;</span>,<span class="hljs-string">&quot;灭绝&quot;</span>,<span class="hljs-string">&quot;周芷若&quot;</span>&#125;;<br>        Stream&lt;String&gt; nameStream = Arrays.stream(names);<br>        Stream&lt;String&gt; nameStream2 = Stream.of(names);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="311Stream常用API"><a href="#311Stream常用API" class="headerlink" title="311Stream常用API"></a>311Stream常用API</h1><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>Stream<T>  filter(Predicate&lt;?  super  T&gt;  predicate)</td><td>用于对流中的数据进行<strong>过滤。</strong></td></tr><tr><td>Stream<T>  limit(long maxSize)</td><td>获取前几个元素</td></tr><tr><td>Stream<T>  skip(long n)</td><td>跳过前几个元素</td></tr><tr><td>Stream<T>  distinct()</td><td>去除流中重复的元素。依赖(hashCode和equals方法)</td></tr><tr><td>static  <T> Stream<T> concat(Stream  a, Stream b)</td><td><strong>合并</strong>a和b两个流为一个流</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     目标：Stream流的常用API</span><br><span class="hljs-comment">         forEach : 逐一处理(遍历)</span><br><span class="hljs-comment">         count：统计个数</span><br><span class="hljs-comment">            -- long count();</span><br><span class="hljs-comment">         filter : 过滤元素</span><br><span class="hljs-comment">            -- Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</span><br><span class="hljs-comment">         limit : 取前几个元素</span><br><span class="hljs-comment">         skip : 跳过前几个</span><br><span class="hljs-comment">         map : 加工方法</span><br><span class="hljs-comment">         concat : 合并流。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamDemo03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;张无忌&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;周芷若&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;赵敏&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;张强&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;张三丰&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;张三丰&quot;</span>);<br><br>        <span class="hljs-comment">// Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</span><br>        list.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>)).forEach(s -&gt; System.out.println(s));<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> list.stream().filter(s -&gt; s.length() == <span class="hljs-number">3</span>).count();<br>        System.out.println(size);<br><br>       <span class="hljs-comment">// list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;)).limit(2).forEach(s -&gt; System.out.println(s));</span><br>        list.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>)).limit(<span class="hljs-number">2</span>).forEach(System.out::println);<br><br>        list.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>)).skip(<span class="hljs-number">2</span>).forEach(System.out::println);<br><br>        <span class="hljs-comment">// map加工方法: 第一个参数原材料  -&gt; 第二个参数是加工后的结果。</span><br>        <span class="hljs-comment">// 给集合元素的前面都加上一个：黑马的：</span><br>        list.stream().map(s -&gt; <span class="hljs-string">&quot;黑马的：&quot;</span> + s).forEach(a -&gt; System.out.println(a));<br><br>        <span class="hljs-comment">// 需求：把所有的名称 都加工成一个学生对象。</span><br>         list.stream().map(s -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(s)).forEach(s -&gt; System.out.println(s));<br><span class="hljs-comment">//        list.stream().map(Student::new).forEach(System.out::println); // 构造器引用  方法引用</span><br><br>        <span class="hljs-comment">// 合并流。</span><br>        Stream&lt;String&gt; s1 = list.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>));<br>        Stream&lt;String&gt; s2 = Stream.of(<span class="hljs-string">&quot;java1&quot;</span>, <span class="hljs-string">&quot;java2&quot;</span>);<br>        <span class="hljs-comment">// public static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span><br>        Stream&lt;String&gt; s3 = Stream.concat(s1 , s2);<br>        s3.distinct().forEach(s -&gt; System.out.println(s));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamDemo04</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> allMoney ;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> allMoney2 ; <span class="hljs-comment">// 2个部门去掉最高工资，最低工资的总和</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Employee&gt; one = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        one.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;猪八戒&quot;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-number">30000</span> , <span class="hljs-number">25000</span>, <span class="hljs-literal">null</span>));<br>        one.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;孙悟空&quot;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-number">25000</span> , <span class="hljs-number">1000</span>, <span class="hljs-string">&quot;顶撞上司&quot;</span>));<br>        one.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;沙僧&quot;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-number">20000</span> , <span class="hljs-number">20000</span>, <span class="hljs-literal">null</span>));<br>        one.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;小白龙&quot;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-number">20000</span> , <span class="hljs-number">25000</span>, <span class="hljs-literal">null</span>));<br><br>        List&lt;Employee&gt; two = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        two.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;武松&quot;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-number">15000</span> , <span class="hljs-number">9000</span>, <span class="hljs-literal">null</span>));<br>        two.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;李逵&quot;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-number">20000</span> , <span class="hljs-number">10000</span>, <span class="hljs-literal">null</span>));<br>        two.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;西门庆&quot;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-number">50000</span> , <span class="hljs-number">100000</span>, <span class="hljs-string">&quot;被打&quot;</span>));<br>        two.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;潘金莲&quot;</span>,<span class="hljs-string">&#x27;女&#x27;</span>,<span class="hljs-number">3500</span> , <span class="hljs-number">1000</span>, <span class="hljs-string">&quot;被打&quot;</span>));<br>        two.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;武大郎&quot;</span>,<span class="hljs-string">&#x27;女&#x27;</span>,<span class="hljs-number">20000</span> , <span class="hljs-number">0</span>, <span class="hljs-string">&quot;下毒&quot;</span>));<br><br>        <span class="hljs-comment">// 1、开发一部的最高工资的员工。（API）</span><br>        <span class="hljs-comment">// 指定大小规则了</span><br><span class="hljs-comment">//        Employee e = one.stream().max((e1, e2) -&gt; Double.compare(e1.getSalary() + e1.getBonus(),  e2.getSalary() + e2.getBonus()))</span><br><span class="hljs-comment">//                .get();</span><br><span class="hljs-comment">//       System.out.println(e);</span><br>        <span class="hljs-type">Topperformer</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> one.stream().max((e1, e2) -&gt; Double.compare(e1.getSalary() + e1.getBonus(),  e2.getSalary() + e2.getBonus()))<br>                .map(e -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Topperformer</span>(e.getName(),  e.getSalary() + e.getBonus())).get();<br>        System.out.println(t);<br><br>        <span class="hljs-comment">// 2、统计平均工资，去掉最高工资和最低工资</span><br>        one.stream().sorted((e1, e2) -&gt; Double.compare(e1.getSalary() + e1.getBonus(),  e2.getSalary() + e2.getBonus()))<br>                .skip(<span class="hljs-number">1</span>).limit(one.size() - <span class="hljs-number">2</span>).forEach(e -&gt; &#123;<br>                    <span class="hljs-comment">// 求出总和：剩余员工的工资总和</span><br>            allMoney += (e.getSalary() + e.getBonus());<br>        &#125;);<br>        System.out.println(<span class="hljs-string">&quot;开发一部的平均工资是：&quot;</span> + allMoney / (one.size() - <span class="hljs-number">2</span>));<br><br>        <span class="hljs-comment">// 3、合并2个集合流，再统计</span><br>        Stream&lt;Employee&gt; s1 = one.stream();<br>        Stream&lt;Employee&gt; s2 = two.stream();<br>        Stream&lt;Employee&gt; s3 = Stream.concat(s1 , s2);<br>        s3.sorted((e1, e2) -&gt; Double.compare(e1.getSalary() + e1.getBonus(),  e2.getSalary() + e2.getBonus()))<br>                .skip(<span class="hljs-number">1</span>).limit(one.size() + two.size() - <span class="hljs-number">2</span>).forEach(e -&gt; &#123;<br>            <span class="hljs-comment">// 求出总和：剩余员工的工资总和</span><br>            allMoney2 += (e.getSalary() + e.getBonus());<br>        &#125;);<br><br>        <span class="hljs-comment">// BigDecimal</span><br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> BigDecimal.valueOf(allMoney2);<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> BigDecimal.valueOf(one.size()  + two.size() - <span class="hljs-number">2</span>);<br>        System.out.println(<span class="hljs-string">&quot;开发部的平均工资是：&quot;</span> + a.divide(b,<span class="hljs-number">2</span>, RoundingMode.HALF_UP));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="收集Stream流"><a href="#收集Stream流" class="headerlink" title="收集Stream流"></a>收集Stream流</h6><p><strong>收集Stream流的含义</strong>：就是把Stream流操作后的结果数据转回到集合或者数组中去。</p><p>Stream流：方便操作集合/数组的<strong>手段。</strong></p><p>集合/数组：才是开发中的<strong>目的</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamDemo05</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;张无忌&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;周芷若&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;赵敏&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;张强&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;张三丰&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;张三丰&quot;</span>);<br><br>        Stream&lt;String&gt; s1 = list.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>));<br>        List&lt;String&gt; zhangList = s1.collect(Collectors.toList()); <span class="hljs-comment">// 可变集合</span><br>        zhangList.add(<span class="hljs-string">&quot;java1&quot;</span>);<br>        System.out.println(zhangList);<br><br><span class="hljs-comment">//       List&lt;String&gt; list1 = s1.toList(); // 得到不可变集合</span><br><span class="hljs-comment">//       list1.add(&quot;java&quot;);</span><br><span class="hljs-comment">//       System.out.println(list1);</span><br><br>        <span class="hljs-comment">// 注意注意注意：“流只能使用一次”</span><br>        Stream&lt;String&gt; s2 = list.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>));<br>        Set&lt;String&gt; zhangSet = s2.collect(Collectors.toSet());<br>        System.out.println(zhangSet);<br><br>        Stream&lt;String&gt; s3 = list.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>));<br><span class="hljs-comment">//         Object[] arrs = s3.toArray();</span><br>        String[] arrs = s3.toArray(String[]::<span class="hljs-keyword">new</span>); <span class="hljs-comment">// 可以不管，拓展一下思维！！</span><br>        System.out.println(<span class="hljs-string">&quot;Arrays数组内容：&quot;</span> + Arrays.toString(arrs));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><h6 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h6><ul><li>异常是程序在“编译”或者“执行”的过程中可能出现的问题，注意：语法错误不算在异常体系中。</li><li>比如：数组索引越界、空指针异常、</li><li>日期格式化异常，等…</li></ul><h6 id="为什么要学习异常？"><a href="#为什么要学习异常？" class="headerlink" title="为什么要学习异常？"></a>为什么要学习异常？</h6><ul><li>异常一旦出现了，如果没有提前处理，程序就会退出JM虚拟机而终止</li><li>研究异常并且避免异常，然后提前处理异常，体现的是程序的安全，健壮性。</li></ul><h6 id="异常分为几类？"><a href="#异常分为几类？" class="headerlink" title="异常分为几类？"></a>异常分为几类？</h6><ul><li>编译时异常、运行时异常。</li><li>编译时异常：没有继承RuntimeExcpetion的异常，编译阶段就会错。</li><li>运行时异常：继承自RuntimeException的异常或其子类，编译阶段不报错，运行可能报错。</li></ul><h6 id="运行时异常示例"><a href="#运行时异常示例" class="headerlink" title="运行时异常示例"></a>运行时异常示例</h6><ul><li>数组索引越界异常：ArraylndexOutOfBoundsException</li><li>空指针异常：NullPointerException,直接输出没有问题，但是调用空指针的变量的功能就会报错。</li><li>数学操作异常：ArithmeticException</li><li>类型转换异常：ClassCastException</li><li>数字转换异常：NumberFormatException</li></ul><h6 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a><strong>编译时异常</strong></h6><ul><li>不是RuntimeException或者其子类的异常，编译阶就报错，必须处理，否则代码不通过。</li><li>是担心程序员的技术不行，在编译阶段就爆出一个错误，目的在于提醒不要出错！</li><li>编译时异常是可遇不可求，遇到了就遇到了呗。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2015-01-12 10:23:21&quot;</span>;<br><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br><span class="hljs-type">Date</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> sdf.parse(date);<span class="hljs-comment">//</span><br>System.out.println(d);<br></code></pre></td></tr></table></figure><h6 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h6><p><strong>异常处理方式1—— throws</strong></p><ul><li><p>throws：用在方法上，可以将方法内部出现的异常抛出去给本方法的调用者处理。</p></li><li><p>这种方式并不好，发生异常的方法自己不处理异常，如果异常最终抛出去给虚拟机将引起程序死亡。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">方法 <span class="hljs-keyword">throws</span> Exception&#123;<br>&#125;<br><span class="hljs-comment">//代表抛一切异常</span><br></code></pre></td></tr></table></figure><p><strong>异常处理方式2—— try…catch…</strong></p><ul><li><p>监视捕获异常，用在方法内部，可以将方法内部出现的异常直接捕获处理。</p></li><li><p>这种方式还可以，发生异常的方法自己独立完成异常的处理，程序可以继续往下执行。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">// 可能出现异常的代码！</span><br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>    e.printStackTrace(); <br>    <span class="hljs-comment">// 直接打印异常栈信息</span><br>&#125;<br><span class="hljs-comment">//Exception可以捕获处理一切异常类型！</span><br></code></pre></td></tr></table></figure><p><strong>异常处理方式——前两者结合</strong></p><ul><li><p>方法直接将异通过throws抛出去给调用者</p></li><li><p>调用者收到异常后直接捕获处理。</p></li></ul><h6 id="自定义异常的必要？"><a href="#自定义异常的必要？" class="headerlink" title="自定义异常的必要？"></a><strong>自定义异常的必要</strong>？</h6><ul><li><p>Java无法为这个世界上全部的问题提供异常类。</p></li><li><p>如果企业想通过异常的方式来管理自己的某个业务问题，就需要自定义异常类了。</p></li></ul><h6 id="自定义异常的好处："><a href="#自定义异常的好处：" class="headerlink" title="自定义异常的好处："></a><strong>自定义异常的好处：</strong></h6><ul><li><p>可以使用异常的机制管理业务问题，如提醒程序员注意。</p></li><li><p>同时一旦出现bug，可以用异常的形式清晰的指出出错的地方。</p></li></ul><h6 id="自定义异常分类"><a href="#自定义异常分类" class="headerlink" title="自定义异常分类"></a>自定义异常分类</h6><p><strong>1、自定义编译时异常</strong></p><ul><li><p>定义一个异常类继承Exception.</p></li><li><p>重写构造器。</p></li><li><p>在出现异常的地方用throw new 自定义对象抛出，</p></li></ul><p>作用：编译时异常是编译阶段就报错，提醒更加强烈，一定需要处理！！</p><p><strong>2、自定义运行时异常</strong></p><ul><li><p>定义一个异常类继承RuntimeException.</p></li><li><p>重写构造器。</p></li><li><p>在出现异常的地方用throw new 自定义对象抛出!</p></li></ul><p>作用：提醒不强烈，编译阶段不报错！！运行时才可能出现！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    自定义的编译时异常</span><br><span class="hljs-comment">      1、继承Exception</span><br><span class="hljs-comment">      2、重写构造器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ItheimaAgeIlleagalException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ItheimaAgeIlleagalException</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ItheimaAgeIlleagalException</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    自定义的运行时异常</span><br><span class="hljs-comment">      1、继承RuntimeException</span><br><span class="hljs-comment">      2、重写构造器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ItheimaAgeIlleagalRuntimeException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ItheimaAgeIlleagalRuntimeException</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ItheimaAgeIlleagalRuntimeException</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标:自定义异常(了解)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    引入:Java已经为开发中可能出现的异常都设计了一个类来代表.</span><br><span class="hljs-comment">        但是实际开发中,异常可能有无数种情况,Java无法为</span><br><span class="hljs-comment">        这个世界上所有的异常都定义一个代表类。</span><br><span class="hljs-comment">        假如一个企业如果想为自己认为的某种业务问题定义成一个异常</span><br><span class="hljs-comment">        就需要自己来自定义异常类.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    需求：认为年龄小于0岁，大于200岁就是一个异常。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    自定义异常:</span><br><span class="hljs-comment">        自定义编译时异常.</span><br><span class="hljs-comment">            a.定义一个异常类继承Exception.</span><br><span class="hljs-comment">            b.重写构造器。</span><br><span class="hljs-comment">            c.在出现异常的地方用throw new 自定义对象抛出!</span><br><span class="hljs-comment">            编译时异常是编译阶段就报错，提醒更加强烈，一定需要处理！！</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        自定义运行时异常.</span><br><span class="hljs-comment">            a.定义一个异常类继承RuntimeException.</span><br><span class="hljs-comment">            b.重写构造器。</span><br><span class="hljs-comment">            c.在出现异常的地方用throw new 自定义对象抛出!</span><br><span class="hljs-comment">            提醒不强烈，编译阶段不报错！！运行时才可能出现！！</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//        try &#123;</span><br><span class="hljs-comment">//            checkAge(-34);</span><br><span class="hljs-comment">//        &#125; catch (ItheimaAgeIlleagalException e) &#123;</span><br><span class="hljs-comment">//            e.printStackTrace();</span><br><span class="hljs-comment">//        &#125;</span><br><br>        <span class="hljs-keyword">try</span> &#123;<br>            checkAge2(-<span class="hljs-number">23</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkAge2</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span>  &#123;<br>        <span class="hljs-keyword">if</span>(age &lt; <span class="hljs-number">0</span> || age &gt; <span class="hljs-number">200</span>)&#123;<br>            <span class="hljs-comment">// 抛出去一个异常对象给调用者</span><br>            <span class="hljs-comment">// throw ：在方法内部直接创建一个异常对象，并从此点抛出</span><br>            <span class="hljs-comment">// throws : 用在方法申明上的，抛出方法内部的异常</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ItheimaAgeIlleagalRuntimeException</span>(age + <span class="hljs-string">&quot; is illeagal!&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;年龄合法：推荐商品给其购买~~&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> <span class="hljs-keyword">throws</span> ItheimaAgeIlleagalException &#123;<br>        <span class="hljs-keyword">if</span>(age &lt; <span class="hljs-number">0</span> || age &gt; <span class="hljs-number">200</span>)&#123;<br>            <span class="hljs-comment">// 抛出去一个异常对象给调用者</span><br>            <span class="hljs-comment">// throw ：在方法内部直接创建一个异常对象，并从此点抛出</span><br>            <span class="hljs-comment">// throws : 用在方法申明上的，抛出方法内部的异常</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ItheimaAgeIlleagalException</span>(age + <span class="hljs-string">&quot; is illeagal!&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;年龄合法：推荐商品给其购买~~&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="日志技术"><a href="#日志技术" class="headerlink" title="日志技术"></a>日志技术</h4><h6 id="日志技术具备的优势"><a href="#日志技术具备的优势" class="headerlink" title="日志技术具备的优势"></a>日志技术具备的优势</h6><ul><li>可以将系统执行的信息选择性的记录到指定的位置(控制台、文件中、数据库中)。</li><li>可以随时以开关的形式控制是否记录日志，无需修改源代码。</li></ul><table><thead><tr><th></th><th><strong>输出语句</strong></th><th><strong>日志技术</strong></th></tr></thead><tbody><tr><td>输出位置</td><td>只能是控制台</td><td>可以将日志信息写入到文件或者数据库中</td></tr><tr><td>取消日志</td><td>需要修改代码，灵活性比较差</td><td>不需要修改代码，灵活性比较好</td></tr><tr><td>多线程</td><td>性能较差</td><td>性能较好</td></tr></tbody></table><h6 id="1-日志的规范是什么，常见的有几种形式。"><a href="#1-日志的规范是什么，常见的有几种形式。" class="headerlink" title="1.日志的规范是什么，常见的有几种形式。"></a><strong>1.日志的规范是什么，常见的有几种形式。</strong></h6><ul><li>日志规范大多是一些接口，提供给实现框架去设计的。</li><li>常见的规范是：</li><li>Commons Logging</li><li>Simple Logging Facade for Java</li></ul><h6 id="2-日志的实现框架有哪些常见的？"><a href="#2-日志的实现框架有哪些常见的？" class="headerlink" title="2.日志的实现框架有哪些常见的？"></a><strong>2.日志的实现框架有哪些常见的？</strong></h6><ul><li>Log4</li><li>Logback(我们重点学习的，其他的都大同小异)</li></ul><h6 id="3-使用Logback需要使用哪几个模块，各自的作用是什么。"><a href="#3-使用Logback需要使用哪几个模块，各自的作用是什么。" class="headerlink" title="3.使用Logback需要使用哪几个模块，各自的作用是什么。"></a>3.使用Logback需要使用哪几个模块，各自的作用是什么。</h6><ul><li>slf4j-api:日志规范</li><li>logback-core:基础模块。</li><li>logback-classic:它是log4j的一个改良版本，同时它完整实现了slf4码API。</li></ul><h6 id="需求：导入Logback日志技术到项目中，用于纪录系统的日志信息"><a href="#需求：导入Logback日志技术到项目中，用于纪录系统的日志信息" class="headerlink" title="需求：导入Logback日志技术到项目中，用于纪录系统的日志信息"></a>需求：导入Logback日志技术到项目中，用于纪录系统的日志信息</h6><p>分析：</p><p>①：在项目下新建文件夹lib，导入Logback的相关jar包到该文件夹下，并添加到项目依赖库中去。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230320143356284.png" alt="image-20230320143356284"></p><p>②：将Logback的核心配置文件logback.xml直接拷贝到src目录下（必须是src下）。</p><p>③：在代码中获取日志的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">LOGGER</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(<span class="hljs-string">&quot;类对象&quot;</span>);<br></code></pre></td></tr></table></figure><p>④：使用日志对象LOGGER调用其方法输出不能的日志信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> 快速搭建logback框架</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">logback</span> &#123;<br>    <span class="hljs-comment">//创建logback对象</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">LOGGER</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(<span class="hljs-string">&quot;logback.class&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            LOGGER.debug(<span class="hljs-string">&quot;main方法开始执行&quot;</span>);<br>            LOGGER.info(<span class="hljs-string">&quot;第二行代码&quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            LOGGER.trace(<span class="hljs-string">&quot;a=&quot;</span>+a);<br>            LOGGER.trace(<span class="hljs-string">&quot;b=&quot;</span>+b);<br>            System.out.println(a / b);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            LOGGER.error(<span class="hljs-string">&quot;功能出现异常&quot;</span>+e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h6><ul><li><p>级别程度依次是：TRACE&lt; DEBUG&lt; INFO&lt;WARN&lt;ERROR ; 默认级别是debug（忽略大小写），对应其方法。</p></li><li><p>作用：用于控制系统中哪些日志级别是可以输出的，只输出级别不低于设定级别的日志信息。</p></li><li><p>ALL  和 OFF分别是打开全部日志信息，及关闭全部日志信息。</p></li></ul><p>具体在<code>&lt;root level=&quot;INFO&quot;&gt;</code>标签的level属性中设置日志级别。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">“INFO</span>&quot;&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><h6 id="File类概述"><a href="#File类概述" class="headerlink" title="File类概述"></a>File类概述</h6><p>File类在包java.io.File下、代表操作系统的文件对象(文件、文件夹)。<br>File类提供了诸如：定位文件，获取文件本身的信息、删除文件、创建文件（文件夹）等功能。</p><h6 id="创建File对象"><a href="#创建File对象" class="headerlink" title="创建File对象"></a>创建File对象</h6><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td><strong>public</strong> File(String  pathname)</td><td>根据文件路径创建文件对象</td></tr><tr><td><strong>public</strong> File(String  parent, String child)</td><td>从父路径名字符串和子路径名字符串创建文件对象</td></tr><tr><td><strong>public</strong> File(File parent, String child)</td><td>根据父路径对应文件对象和子路径名字符串创建文件对象</td></tr></tbody></table><p>绝对路径：从盘符开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">file1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(“D:\\itheima\\a.txt”); <br></code></pre></td></tr></table></figure><p>相对路径：不带盘符，默认直接到当前工程下的目录寻找文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">file3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(“模块名\\a.txt”); <br></code></pre></td></tr></table></figure><h6 id="File类的判断文件类型、获取文件信息功能"><a href="#File类的判断文件类型、获取文件信息功能" class="headerlink" title="File类的判断文件类型、获取文件信息功能"></a>File类的判断文件类型、获取文件信息功能</h6><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public  boolean isDirectory()</td><td>测试此抽象路径名表示的File是否为文件夹</td></tr><tr><td>public  boolean isFile()</td><td>测试此抽象路径名表示的File是否为文件</td></tr><tr><td>public  boolean  exists()</td><td>测试此抽象路径名表示的File是否存在</td></tr><tr><td>public  String getAbsolutePath()</td><td>返回此抽象路径名的绝对路径名字符串</td></tr><tr><td>public  String getPath()</td><td>将此抽象路径名转换为路径名字符串</td></tr><tr><td>public  String getName()</td><td>返回由此抽象路径名表示的文件或文件夹的名称</td></tr><tr><td>public  long lastModified()</td><td>返回文件最后修改的时间毫秒值</td></tr></tbody></table><h6 id="File类创建文件的功能"><a href="#File类创建文件的功能" class="headerlink" title="File类创建文件的功能"></a>File类创建文件的功能</h6><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public boolean createNewFile()</td><td>创建一个新的空的文件</td></tr><tr><td>public boolean mkdir()</td><td>只能创建一级文件夹</td></tr><tr><td>public boolean mkdirs()</td><td>可以创建多级文件夹</td></tr></tbody></table><h6 id="File类删除文件的功能"><a href="#File类删除文件的功能" class="headerlink" title="File类删除文件的功能"></a>File类删除文件的功能</h6><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public  boolean delete()</td><td>删除由此抽象路径名表示的文件或空文件夹</td></tr></tbody></table><ul><li><p>delete方法默认只能删除文件和空文件夹。</p></li><li><p>delete方法直接删除不走回收站</p></li></ul><h6 id="File类的遍历功能"><a href="#File类的遍历功能" class="headerlink" title="File类的遍历功能"></a><strong>File</strong>类的遍历功能</h6><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public String[] list()</td><td>获取当前目录下所有的”一级文件名称”到一个字符串数组中去返回。</td></tr><tr><td>public File[] listFiles()(常用)</td><td>获取当前目录下所有的”一级文件对象”到一个文件对象数组中去返回（重点）</td></tr></tbody></table><p><strong>listFiles方法注意事项：</strong></p><ul><li>当调用者不存在时，返回null</li><li>当调用者是一个文件时，返回null</li><li>当调用者是一个空文件夹时，返回一个长度为0的数组</li><li>当调用者是一个有内容的文件夹时，将里面所有文件和文件夹的路径放在File数组中返回</li><li>当调用者是一个有隐藏文件的文件夹时，将里面所有文件和文件夹的路径放在File数组中返回，包含隐藏内容</li><li>当调用者是一个需要权限才能进入的文件夹时，返回null</li></ul><h6 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h6><p><strong>递归算法三要素大体可以总结为</strong>：</p><ul><li>递归的公式：f（）=f(n-1)*n;</li><li>递归的终结点：f(1)</li><li>递归的方向必须走向终结点：</li></ul><p><strong>需求：计算1-n的阶乘的结果，使用递归思想解决，我们先从数学思维上理解递归的流程和核心点。</strong></p><p>分析</p><p>①假如我们认为存在一个公式是 f(n) = 1*<em>2</em>…(n-1)*n;</p><p>②那么公式等价形式就是： f(n) = f(n-1) *n</p><p>③如果求的是 1-5的阶乘 的结果，我们手工应该应该如何应用上述公式计算。</p><ul><li>f(5) = f(4) * 5</li><li>f(4) = f(3) * 4</li><li>f(3) = f(2) * 3</li><li>f(2) = f(1) * 2</li><li>f(1) = 1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecursionDemo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(f(<span class="hljs-number">5</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> f(n - <span class="hljs-number">1</span>) * n;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>案例</strong></p><p>猴子第一天摘下若干桃子，当即吃了一半，觉得好不过瘾，于是又多吃了一个</p><p>第二天又吃了前天剩余桃子数量的一半，觉得好不过瘾，于是又多吃了一个</p><p>以后每天都是吃前天剩余桃子数量的一半，觉得好不过瘾，又多吃了一个</p><p>等到第10天的时候发现桃子只有1个了。</p><p>需求：请问猴子第一天摘了多少个桃子？</p><p>分析：</p><p>①整体来看，每一天都是做同一个事件，典型的规律化问题，考虑递归三要素：</p><p>②递归公式： </p><p>③递归终结点：</p><p>④递归方向：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">      目标 猴子吃桃。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     公式（合理的）： f(x) - f(x)/2 - 1 = f(x+1)</span><br><span class="hljs-comment">                   2f(x) - f(x) - 2 = 2f(x + 1)</span><br><span class="hljs-comment">                   f(x) = 2f(x + 1) + 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    求f(1) = ?</span><br><span class="hljs-comment">    终结点： f（10） = 1</span><br><span class="hljs-comment">    递归的方向：合理的</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecursionDemo04</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(f(<span class="hljs-number">1</span>));<br>        System.out.println(f(<span class="hljs-number">2</span>));<br>        System.out.println(f(<span class="hljs-number">3</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">10</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * f(n + <span class="hljs-number">1</span>) + <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="111文件查找"><a href="#111文件查找" class="headerlink" title="111文件查找"></a>111文件查找</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：去D判断搜索 eDiary.exe文件</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecursionDemo05</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 2、传入目录 和  文件名称</span><br>        searchFile(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:/&quot;</span>) , <span class="hljs-string">&quot;eDiary.exe&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1、搜索某个目录下的全部文件，找到我们想要的文件。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dir  被搜索的源目录</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileName 被搜索的文件名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">searchFile</span><span class="hljs-params">(File dir,String fileName)</span>&#123;<br>        <span class="hljs-comment">// 3、判断dir是否是目录</span><br>        <span class="hljs-keyword">if</span>(dir != <span class="hljs-literal">null</span> &amp;&amp; dir.isDirectory())&#123;<br>            <span class="hljs-comment">// 可以找了</span><br>            <span class="hljs-comment">// 4、提取当前目录下的一级文件对象</span><br>            File[] files = dir.listFiles(); <span class="hljs-comment">// null  []</span><br>            <span class="hljs-comment">// 5、判断是否存在一级文件对象，存在才可以遍历</span><br>            <span class="hljs-keyword">if</span>(files != <span class="hljs-literal">null</span> &amp;&amp; files.length &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">for</span> (File file : files) &#123;<br>                    <span class="hljs-comment">// 6、判断当前遍历的一级文件对象是文件 还是 目录</span><br>                    <span class="hljs-keyword">if</span>(file.isFile())&#123;<br>                        <span class="hljs-comment">// 7、是不是咱们要找的，是把其路径输出即可</span><br>                        <span class="hljs-keyword">if</span>(file.getName().contains(fileName))&#123;<br>                            System.out.println(<span class="hljs-string">&quot;找到了：&quot;</span> + file.getAbsolutePath());<br>                            <span class="hljs-comment">// 启动它。</span><br>                            <span class="hljs-keyword">try</span> &#123;<br>                                <span class="hljs-type">Runtime</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<br>                                r.exec(file.getAbsolutePath());<br>                            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                                e.printStackTrace();<br>                            &#125;<br>                        &#125;<br>                    &#125;<span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// 8、是文件夹，需要继续递归寻找</span><br>                        searchFile(file, fileName);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;对不起，当前搜索的位置不是文件夹！&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h4><h6 id="1-字符串常见的字符底层组成是什么样的？"><a href="#1-字符串常见的字符底层组成是什么样的？" class="headerlink" title="1.字符串常见的字符底层组成是什么样的？"></a>1.字符串常见的字符底层组成是什么样的？</h6><ul><li>英文和数字等在任何国家的字符集中都占1个字节</li><li>GBK字符中一个中文字符占2个字节</li><li>UTF-8编码中一个中文1般占3个字节</li></ul><h6 id="2-编码前的字符集和编码好的字符集有什么要求？"><a href="#2-编码前的字符集和编码好的字符集有什么要求？" class="headerlink" title="2.编码前的字符集和编码好的字符集有什么要求？"></a>2.编码前的字符集和编码好的字符集有什么要求？</h6><ul><li>必须一致，否则会出现中文字符乱码</li></ul><p>String编码</p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>byte[] getBytes()</td><td>使用平台的默认字符集将该  String编码为一系列字节，将结果存储到新的字节数组中</td></tr><tr><td>byte[] getBytes(String charsetName)</td><td>使用指定的字符集将该 String编码为一系列字节，将结果存储到新的字节数组中</td></tr></tbody></table><p>String解码</p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>String(byte[] bytes)</td><td>通过使用平台的默认字符集解码指定的字节数组来构造新的  String</td></tr><tr><td>String(byte[] bytes, String charsetName)</td><td>通过指定的字符集解码指定的字节数组来构造新的 String</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     目标：学会自己进行文字的编码和解码，为以后可能用到的场景做准备。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1、编码：把文字转换成字节（使用指定的编码）</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc我爱你中国&quot;</span>;<br>        <span class="hljs-comment">// byte[] bytes = name.getBytes(); // 以当前代码默认字符集进行编码 （UTF-8）</span><br>        <span class="hljs-type">byte</span>[] bytes = name.getBytes(<span class="hljs-string">&quot;GBK&quot;</span>); <span class="hljs-comment">// 指定编码</span><br>        System.out.println(bytes.length);<br>        System.out.println(Arrays.toString(bytes));<br><br>        <span class="hljs-comment">// 2、解码：把字节转换成对应的中文形式（编码前 和 编码后的字符集必须一致，否则乱码 ）</span><br>        <span class="hljs-comment">// String rs = new String(bytes); // 默认的UTF-8</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes, <span class="hljs-string">&quot;GBK&quot;</span>); <span class="hljs-comment">// 指定GBK解码</span><br>        System.out.println(rs);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h4><h6 id="IO流概述"><a href="#IO流概述" class="headerlink" title="IO流概述"></a><strong>IO</strong>流概述</h6><ul><li><p>I表示intput，是数据从硬盘文件读入到内存的过程，称之输入，负责读。</p></li><li><p>O表示output，是内存程序的数据从内存到写出到硬盘文件的过程，称之输出，负责写。</p></li></ul><h6 id="总结流的四大类"><a href="#总结流的四大类" class="headerlink" title="总结流的四大类:"></a><strong>总结</strong>流的四大类:</h6><ul><li><p>字节输入流：以内存为基准，来自磁盘文件/网络中的数据以字节的形式读入到内存中去的流称为字节输入流。</p></li><li><p>字节输出流：以内存为基准，把内存中的数据以字节写出到磁盘文件或者网络中去的流称为字节输出流。</p></li><li><p>字符输入流：以内存为基准，来自磁盘文件/网络中的数据以字符的形式读入到内存中去的流称为字符输入流。</p></li><li><p>字符输出流：以内存为基准，把内存中的数据以字符写出到磁盘文件或者网络介质中去的流称为字符输出流。</p></li></ul><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220428190902198.png" alt="image-20220428190902198"></p><h6 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h6><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public int  read()</td><td>每次读取一个字节返回，如果字节已经没有可读的返回-1</td></tr><tr><td>public int  read(byte[] buffer)</td><td>每次读取一个字节数组返回读取字节数，如果字节已经没有可读的返回-1</td></tr></tbody></table><p>1.如何使用字节输入流读取中文内容输出不乱码呢？<br>    一次性读取完全部字节。<br>    可以定义与文件一样大的字节数组读取，也可以使用官方API。<br>2.直接把文件数据全部读取到一个字节数组可以避免乱码，是否存在问题？<br>    如果文件过大，定义的字节数组可能引起内存溢出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   目标：使用文件字节输入流每次读取一个字节数组的数据。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileInputStreamDemo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1、创建一个文件字节输入流管道与源文件接通</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;file-io-app/src/data02.txt&quot;</span>);<br><br>        <span class="hljs-comment">// 2、定义一个字节数组，用于读取字节数组</span><br><span class="hljs-comment">//        byte[] buffer = new byte[3]; // 3B</span><br><span class="hljs-comment">//        int len = is.read(buffer);</span><br><span class="hljs-comment">//        System.out.println(&quot;读取了几个字节：&quot; + len);</span><br><span class="hljs-comment">//        String rs = new String(buffer);</span><br><span class="hljs-comment">//        System.out.println(rs);</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//        int len1 = is.read(buffer);</span><br><span class="hljs-comment">//        System.out.println(&quot;读取了几个字节：&quot; + len1);</span><br><span class="hljs-comment">//        String rs1 = new String(buffer);</span><br><span class="hljs-comment">//        System.out.println(rs1);</span><br><span class="hljs-comment">//        // buffer = [a b c]</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//        // buffer = [a b c]  ==&gt;  [c d c]</span><br><span class="hljs-comment">//        int len2 = is.read(buffer);</span><br><span class="hljs-comment">//        System.out.println(&quot;读取了几个字节：&quot; + len2);</span><br><span class="hljs-comment">//        // 读取多少倒出多少</span><br><span class="hljs-comment">//        String rs2 = new String(buffer,0 ,len2);</span><br><span class="hljs-comment">//        System.out.println(rs2);</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//        int len3 = is.read(buffer);</span><br><span class="hljs-comment">//        System.out.println(len3); // 读取完毕返回-1</span><br><br>        <span class="hljs-comment">// 3、改进使用循环，每次读取一个字节数组</span><br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">3</span>];<br>        <span class="hljs-type">int</span> len; <span class="hljs-comment">// 记录每次读取的字节数。</span><br>        <span class="hljs-keyword">while</span> ((len = is.read(buffer)) != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 读取多少倒出多少</span><br>            System.out.print(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer, <span class="hljs-number">0</span> , len));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="文件字节输出流：FileOutputStream"><a href="#文件字节输出流：FileOutputStream" class="headerlink" title="文件字节输出流：FileOutputStream"></a><strong>文件字节输出流：FileOutputStream</strong></h6><p>作用：以内存为基准，把内存中的数据以字节的形式写出到磁盘文件中去的流。</p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public FileOutputStream(File file)</td><td>创建字节输出流管道与源文件对象接通</td></tr><tr><td>public FileOutputStream(File file，boolean append)</td><td>创建字节输出流管道与源文件对象接通，可追加数据</td></tr><tr><td>public FileOutputStream(String filepath)</td><td>创建字节输出流管道与源文件路径接通</td></tr><tr><td>public FileOutputStream(String filepath，boolean append)</td><td>创建字节输出流管道与源文件路径接通，可追加数据</td></tr></tbody></table><h6 id="文件字节输出流（FileOutputStream）写数据出去的API"><a href="#文件字节输出流（FileOutputStream）写数据出去的API" class="headerlink" title="文件字节输出流（FileOutputStream）写数据出去的API"></a>文件字节输出流（FileOutputStream）写数据出去的API</h6><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public void write(int a)</td><td>写一个字节出去</td></tr><tr><td>public void write(byte[] buffer)</td><td>写一个字节数组出去</td></tr><tr><td>public void write(byte[] buffer , int pos , int len)</td><td>写一个字节数组的一部分出去。</td></tr></tbody></table><h6 id="流的关闭与刷新"><a href="#流的关闭与刷新" class="headerlink" title="流的关闭与刷新"></a><strong>流的关闭与刷新</strong></h6><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>flush()</td><td>刷新流，还可以继续写数据</td></tr><tr><td>close()</td><td>关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据</td></tr></tbody></table><p>字节输出流如何实现写出去的数据能换行?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">os.write“\r\n”.getBytes())<br></code></pre></td></tr></table></figure><p>如何让写出去的数据能成功生效？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">flush()刷新数据<br><br>close()方法是关闭流，关闭包含刷新，关闭后流不可以继续使用了。<br></code></pre></td></tr></table></figure><h6 id="案例：文件复制"><a href="#案例：文件复制" class="headerlink" title="案例：文件复制"></a>案例：文件复制</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *   目标：学会使用finally释放资源。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TryCatchFinallyDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br><br>            <span class="hljs-comment">// System.out.println(10/ 0);</span><br><br>            <span class="hljs-comment">// 1、创建一个字节输入流管道与原视频接通</span><br>             is = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;file-io-app/src/out04.txt&quot;</span>);<br><br>            <span class="hljs-comment">// 2、创建一个字节输出流管道与目标文件接通</span><br>             os = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;file-io-app/src/out05.txt&quot;</span>);<br><br>            <span class="hljs-comment">// 3、定义一个字节数组转移数据</span><br>            <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-type">int</span> len; <span class="hljs-comment">// 记录每次读取的字节数。</span><br>            <span class="hljs-keyword">while</span> ((len = is.read(buffer)) != -<span class="hljs-number">1</span>)&#123;<br>                os.write(buffer, <span class="hljs-number">0</span> , len);<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;复制完成了！&quot;</span>);<br><br>         <span class="hljs-comment">//   System.out.println( 10 / 0);</span><br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 无论代码是正常结束，还是出现异常都要最后执行这里</span><br>            System.out.println(<span class="hljs-string">&quot;========finally=========&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 4、关闭流。</span><br>                <span class="hljs-keyword">if</span>(os!=<span class="hljs-literal">null</span>)os.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span>(is != <span class="hljs-literal">null</span>) is.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        System.out.println(test(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a , <span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a / b;<br>            <span class="hljs-keyword">return</span> c;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">111111</span>; <span class="hljs-comment">// 计算出现bug.</span><br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;--finally--&quot;</span>);<br>            <span class="hljs-comment">// 哪怕上面有return语句执行，也必须先执行完这里才可以！</span><br>            <span class="hljs-comment">// 开发中不建议在这里加return ，如果加了，返回的永远是这里的数据了，这样会出问题！</span><br>            <span class="hljs-comment">//return 100;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *   目标：学会使用JDK 7的新方式释放资源</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TryCatchResouceDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-keyword">try</span> (<br>                <span class="hljs-comment">// 这里面只能放置资源对象，用完会自动关闭：自动调用资源对象的close方法关闭资源（即使出现异常也会做关闭操作）</span><br>                <span class="hljs-comment">// 1、创建一个字节输入流管道与原视频接通</span><br>               <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;file-io-app/src/out04.txt&quot;</span>);<br>                <span class="hljs-comment">// 2、创建一个字节输出流管道与目标文件接通</span><br>               <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;file-io-app/src/out05.txt&quot;</span>);<br><br>               <span class="hljs-comment">// int age = 23; // 这里只能放资源</span><br>                <span class="hljs-type">MyConnection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyConnection</span>(); <span class="hljs-comment">// 最终会自动调用资源的close方法</span><br>                ) &#123;<br><br>            <span class="hljs-comment">// 3、定义一个字节数组转移数据</span><br>            <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-type">int</span> len; <span class="hljs-comment">// 记录每次读取的字节数。</span><br>            <span class="hljs-keyword">while</span> ((len = is.read(buffer)) != -<span class="hljs-number">1</span>)&#123;<br>                os.write(buffer, <span class="hljs-number">0</span> , len);<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;复制完成了！&quot;</span>);<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConnection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AutoCloseable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;连接资源被成功释放了！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="1-字节流适合做一切文件数据的拷贝吗？"><a href="#1-字节流适合做一切文件数据的拷贝吗？" class="headerlink" title="1.字节流适合做一切文件数据的拷贝吗？"></a>1.字节流适合做一切文件数据的拷贝吗？</h6><ul><li>任何文件的底层都是字节，拷贝是一字不漏的转移字节，只要前后文件格式、编码一致没有任何问题。</li></ul><h6 id="文件字符输入流"><a href="#文件字符输入流" class="headerlink" title="文件字符输入流"></a>文件字符输入流</h6><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public FileReader(File file)</td><td>创建字符输入流管道与源文件对象接通</td></tr><tr><td>public FileReader(String  pathname)</td><td>创建字符输入流管道与源文件路径接通</td></tr></tbody></table><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public int read()</td><td>每次读取一个字符返回，如果字符已经没有可读的返回-1</td></tr><tr><td>public int  read(char[] buffer)</td><td>每次读取一个字符数组，返回读取的字符个数，如果字符已经没有可读的返回-1</td></tr></tbody></table><p>字符流的好处，每次读取一个字符存在什么问题？<br>    读取中文字符不会出现乱码（如果代码和文件编码一致）<br>    性能较慢</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     目标：字符输入流的使用。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     IO流的体系：</span><br><span class="hljs-comment">            字节流                                   字符流</span><br><span class="hljs-comment">     字节输入流           字节输出流               字符输入流       字符输出流</span><br><span class="hljs-comment">     InputStream         OutputStream            Reader         Writer     (抽象类)</span><br><span class="hljs-comment">     FileInputStream     FileOutputStream        FileReader     FileWriter (实现类)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     c.FileReader:文件字符输入流。</span><br><span class="hljs-comment">         -- 作用：以内存为基准，把磁盘文件的数据以字符的形式读入到内存。</span><br><span class="hljs-comment">            简单来说，读取文本文件内容到内存中去。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">         -- 构造器：</span><br><span class="hljs-comment">            public FileReader(File file):创建一个字符输入流与源文件对象接通。</span><br><span class="hljs-comment">            public FileReader(String filePath):创建一个字符输入流与源文件路径接通。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">         -- 方法：</span><br><span class="hljs-comment">            public int read(): 读取一个字符的编号返回！ 读取完毕返回-1</span><br><span class="hljs-comment">            public int read(char[] buffer):读取一个字符数组，读取多少个字符就返回多少个数量，读取完毕返回-1</span><br><span class="hljs-comment">     小结：</span><br><span class="hljs-comment">        字符流一个一个字符的读取文本内容输出，可以解决中文读取输出乱码的问题。</span><br><span class="hljs-comment">        字符流很适合操作文本文件内容。</span><br><span class="hljs-comment">        但是：一个一个字符的读取文本内容性能较差！！</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileReaderDemo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 目标：每次读取一个字符。</span><br>        <span class="hljs-comment">// 1、创建一个字符输入流管道与源文件接通</span><br>        <span class="hljs-type">Reader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;file-io-app\\src\\data06.txt&quot;</span>);<br><br>        <span class="hljs-comment">// 2、读取一个字符返回，没有可读的字符了返回-1</span><br><span class="hljs-comment">//        int code = fr.read();</span><br><span class="hljs-comment">//        System.out.print((char)code);</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//        int code1 = fr.read();</span><br><span class="hljs-comment">//        System.out.print((char)code1);</span><br><br>        <span class="hljs-comment">// 3、使用循环读取字符</span><br>        <span class="hljs-type">int</span> code;<br>        <span class="hljs-keyword">while</span> ((code = fr.read()) != -<span class="hljs-number">1</span>)&#123;<br>            System.out.print((<span class="hljs-type">char</span>) code);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileReaderDemo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1、创建一个文件字符输入流与源文件接通</span><br>        <span class="hljs-type">Reader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;file-io-app/src/data07.txt&quot;</span>);<br><br>        <span class="hljs-comment">// 2、用循环，每次读取一个字符数组的数据。  1024 + 1024 + 8</span><br>        <span class="hljs-type">char</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">1024</span>]; <span class="hljs-comment">// 1K字符</span><br>        <span class="hljs-type">int</span> len;<br>        <span class="hljs-keyword">while</span> ((len = fr.read(buffer)) != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer, <span class="hljs-number">0</span>, len);<br>            System.out.print(rs);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     目标：字符输出流的使用。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     IO流的体系：</span><br><span class="hljs-comment">            字节流                                   字符流</span><br><span class="hljs-comment">     字节输入流           字节输出流               字符输入流       字符输出流</span><br><span class="hljs-comment">     InputStream         OutputStream           Reader         Writer     (抽象类)</span><br><span class="hljs-comment">     FileInputStream     FileOutputStream       FileReader     FileWriter (实现类)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     d.FileWriter文件字符输出流的使用。</span><br><span class="hljs-comment">        -- 作用：以内存为基准，把内存中的数据按照字符的形式写出到磁盘文件中去。</span><br><span class="hljs-comment">            简单来说，就是把内存的数据以字符写出到文件中去。</span><br><span class="hljs-comment">        -- 构造器：</span><br><span class="hljs-comment">           public FileWriter(File file):创建一个字符输出流管道通向目标文件对象。</span><br><span class="hljs-comment">           public FileWriter(String filePath):创建一个字符输出流管道通向目标文件路径。</span><br><span class="hljs-comment">           public FileWriter(File file,boolean append):创建一个追加数据的字符输出流管道通向目标文件对象。</span><br><span class="hljs-comment">           public FileWriter(String filePath,boolean append):创建一个追加数据的字符输出流管道通向目标文件路径。</span><br><span class="hljs-comment">        -- 方法：</span><br><span class="hljs-comment">             a.public void write(int c):写一个字符出去</span><br><span class="hljs-comment">             b.public void write(String c)写一个字符串出去：</span><br><span class="hljs-comment">             c.public void write(char[] buffer):写一个字符数组出去</span><br><span class="hljs-comment">             d.public void write(String c ,int pos ,int len):写字符串的一部分出去</span><br><span class="hljs-comment">             e.public void write(char[] buffer ,int pos ,int len):写字符数组的一部分出去</span><br><span class="hljs-comment">     小结：</span><br><span class="hljs-comment">        字符输出流可以写字符数据出去，总共有5个方法写字符。</span><br><span class="hljs-comment">        覆盖管道：</span><br><span class="hljs-comment">             Writer fw = new FileWriter(&quot;Day10Demo/src/dlei03.txt&quot;); // 覆盖数据管道</span><br><span class="hljs-comment">        追加数据管道：</span><br><span class="hljs-comment">             Writer fw = new FileWriter(&quot;Day10Demo/src/dlei03.txt&quot;,true); // 追加数据管道</span><br><span class="hljs-comment">        换行：</span><br><span class="hljs-comment">             fw.write(&quot;\r\n&quot;); // 换行</span><br><span class="hljs-comment">        结论：读写字符文件数据建议使用字符流。复制文件建议使用字节流。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileWriterDemo03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1、创建一个字符输出流管道与目标文件接通</span><br>        <span class="hljs-comment">// Writer fw = new FileWriter(&quot;file-io-app/src/out08.txt&quot;); // 覆盖管道，每次启动都会清空文件之前的数据</span><br>        <span class="hljs-type">Writer</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;file-io-app/src/out08.txt&quot;</span>, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 覆盖管道，每次启动都会清空文件之前的数据</span><br><br><span class="hljs-comment">//      a.public void write(int c):写一个字符出去</span><br>        fw.write(<span class="hljs-number">98</span>);<br>        fw.write(<span class="hljs-string">&#x27;a&#x27;</span>);<br>        fw.write(<span class="hljs-string">&#x27;徐&#x27;</span>); <span class="hljs-comment">// 不会出问题了</span><br>        fw.write(<span class="hljs-string">&quot;\r\n&quot;</span>); <span class="hljs-comment">// 换行</span><br><br><span class="hljs-comment">//       b.public void write(String c)写一个字符串出去</span><br>        fw.write(<span class="hljs-string">&quot;abc我是中国人&quot;</span>);<br>        fw.write(<span class="hljs-string">&quot;\r\n&quot;</span>); <span class="hljs-comment">// 换行</span><br><br><br><span class="hljs-comment">//       c.public void write(char[] buffer):写一个字符数组出去</span><br>        <span class="hljs-type">char</span>[] chars = <span class="hljs-string">&quot;abc我是中国人&quot;</span>.toCharArray();<br>        fw.write(chars);<br>        fw.write(<span class="hljs-string">&quot;\r\n&quot;</span>); <span class="hljs-comment">// 换行</span><br><br><br><span class="hljs-comment">//       d.public void write(String c ,int pos ,int len):写字符串的一部分出去</span><br>        fw.write(<span class="hljs-string">&quot;abc我是中国人&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>);<br>        fw.write(<span class="hljs-string">&quot;\r\n&quot;</span>); <span class="hljs-comment">// 换行</span><br><br><br><span class="hljs-comment">//       e.public void write(char[] buffer ,int pos ,int len):写字符数组的一部分出去</span><br>        fw.write(chars, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>);<br>        fw.write(<span class="hljs-string">&quot;\r\n&quot;</span>); <span class="hljs-comment">// 换行</span><br><br><br>        <span class="hljs-comment">// fw.flush();// 刷新后流可以继续使用</span><br>        fw.close(); <span class="hljs-comment">// 关闭包含刷新，关闭后流不能使用</span><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h4><h6 id="缓冲流概述"><a href="#缓冲流概述" class="headerlink" title="缓冲流概述"></a>缓冲流概述</h6><p>缓冲流也称为高效流、或者高级流。之前学习的字节流可以称为原始流。<br>作用：缓冲流自带缓冲区、可以提高原始字节流、字符流读写数据的性能</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220429095931746.png" alt="image-20220429095931746"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220429095931746.png"><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220429100034115.png" alt="image-20220429100034115"></p><p>1.缓冲流的作用？<br>    缓冲流自带缓冲区、可以提高原始字节流、字符流读写数据的性能<br>2.缓冲流有几种？<br>字节缓冲流<br>    字节缓冲输入流：BufferedInputStream<br>    字节缓冲输出流：BufferedOutputStream<br>字符缓冲流<br>    字符缓冲输入流：BufferedReader<br>    字符缓冲输出流：BufferedWriter</p><p><strong>字节缓冲流性能优化原理：</strong></p><p>​    字节缓冲输入流自带了8KB缓冲池，以后我们直接从缓冲池读取数据，所以性能较好。</p><p>​    字节缓冲输出流自带了8KB缓冲池，数据就直接写入到缓冲池中去，写数据性能极高了。</p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public BufferedInputStream(InputStream is)</td><td>可以把低级的字节输入流包装成一个高级的缓冲字节输入流管道，从而提高字节输入流读数据的性能</td></tr><tr><td>public BufferedOutputStream(OutputStream os)</td><td>可以把低级的字节输出流包装成一个高级的缓冲字节输出流，从而提高写数据的性能</td></tr></tbody></table><p>1.推荐使用哪种方式提高字节流读写数据的性能？</p><p><strong>建议使用字节缓冲输入流、字节缓冲输出流，结合字节数组的方式，目前来看是性能最优的组合。</strong></p><h6 id="字符缓冲输入流"><a href="#字符缓冲输入流" class="headerlink" title="字符缓冲输入流"></a><strong>字符缓冲输入流</strong></h6><p>字符缓冲输入流：BufferedReader。</p><p>作用：提高字符输入流读取数据的性能，除此之外多了按照行读取数据的功能</p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public  BufferedReader(Reader r)</td><td>可以把低级的字符输入流包装成一个高级的缓冲字符输入流管道，从而提高字符输入流读数据的性能</td></tr></tbody></table><h6 id="字符缓冲输入流新增功能"><a href="#字符缓冲输入流新增功能" class="headerlink" title="字符缓冲输入流新增功能"></a><strong>字符缓冲输入流新增功能</strong></h6><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public  String readLine()</td><td>读取一行数据返回，如果读取没有完毕，无行可读返回null</td></tr></tbody></table><h6 id="字符缓冲输出流"><a href="#字符缓冲输出流" class="headerlink" title="字符缓冲输出流"></a><strong>字符缓冲输出流</strong></h6><p> 字符缓冲输出流：BufferedWriter。</p><p> 作用：提高字符输出流写取数据的性能，除此之外多了换行功能</p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public BufferedWriter(Writer  w)</td><td>可以把低级的字符输出流包装成一个高级的缓冲字符输出流管道，从而提高字符输出流写数据的性能</td></tr></tbody></table><h6 id="字符缓冲输出流新增功能"><a href="#字符缓冲输出流新增功能" class="headerlink" title="字符缓冲输出流新增功能"></a><strong>字符缓冲输出流新增功能</strong></h6><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public  void newLine()</td><td>换行操作</td></tr></tbody></table><h4 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h4><p>1、如果代码编码和文件编码不一致，使用字符流直接读取还能不乱码吗？<br>    会乱码。<br>2、如果如何解决呢？<br>    使用字符输入转换流<br>    可以提取文件(GBK)的原始字节流，原始字节不会存在问题。<br>    然后把字节流以指定编码转换成字符输入流，这样字符输入流中的字符就不乱码了</p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public InputStreamReader(InputStream is)</td><td>可以把原始的字节流按照代码默认编码转换成字符输入流。几乎不用，与默认的FileReader一样。</td></tr><tr><td>public InputStreamReader(InputStream is ，String charset)</td><td>可以把原始的字节流按照指定编码转换成字符输入流，这样字符流中的字符就不乱码了(重点)</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     目标：字符输入转换流InputStreamReader的使用。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">             字节流                                     字符流</span><br><span class="hljs-comment">     字节输入流               字节输出流              字符输入流            字符输出流</span><br><span class="hljs-comment">     InputStream             OutputStream          Reader               Writer   (抽象类)</span><br><span class="hljs-comment">     FileInputStream         FileOutputStream      FileReader           FileWriter(实现类)</span><br><span class="hljs-comment">     BufferedInputStream     BufferedOutputStream  BufferedReader       BufferedWriter(实现类，缓冲流)</span><br><span class="hljs-comment">                                                   InputStreamReader    OutputStreamWriter</span><br><span class="hljs-comment">     字符输入转换流InputStreamReader:</span><br><span class="hljs-comment">          -- 作用：可以解决字符流读取不同编码乱码的问题。</span><br><span class="hljs-comment">                  也可以把原始的字节流按照指定编码转换成字符输入流</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">          -- 构造器：</span><br><span class="hljs-comment">                public InputStreamReader(InputStream is)：可以使用当前代码默认编码转换成字符流，几乎不用！</span><br><span class="hljs-comment">                public InputStreamReader(InputStream is,String charset):可以指定编码把字节流转换成字符流(核心)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     小结：</span><br><span class="hljs-comment">        字符输入转换流InputStreamReader:作用：可以解决字符流读取不同编码乱码的问题。</span><br><span class="hljs-comment">        public InputStreamReader(InputStream is,String charset):可以指定编码把字节流转换成字符流(核心)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputStreamReaderDemo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 代码UTF-8   文件 GBK  &quot;D:\\resources\\data.txt&quot;</span><br>        <span class="hljs-comment">// 1、提取GBK文件的原始字节流。   abc 我</span><br>        <span class="hljs-comment">//                            ooo oo</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:\\resources\\data.txt&quot;</span>);<br>        <span class="hljs-comment">// 2、把原始字节流转换成字符输入流</span><br>        <span class="hljs-comment">// Reader isr = new InputStreamReader(is); // 默认以UTF-8的方式转换成字符流。 还是会乱码的  跟直接使用FileReader是一样的</span><br>        <span class="hljs-type">Reader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(is , <span class="hljs-string">&quot;GBK&quot;</span>); <span class="hljs-comment">// 以指定的GBK编码转换成字符输入流  完美的解决了乱码问题</span><br><br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(isr);<br>        String line;<br>        <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-literal">null</span>)&#123;<br>            System.out.println(line);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>字符输出转换流</strong></p><p>字符输入转换流：OutputStreamWriter，可以把字节输出流按照指定编码转换成字符输出流。</p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public OutputStreamWriter(OutputStream os)</td><td>可以把原始的字节输出流按照代码默认编码转换成字符输出流。几乎不用。</td></tr><tr><td>public OutputStreamWriter(OutputStream os，String  charset)</td><td>可以把原始的字节输出流按照指定编码转换成字符输出流(重点)</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     目标：字符输出转换OutputStreamWriter流的使用。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                字节流                                         字符流</span><br><span class="hljs-comment">     字节输入流               字节输出流              字符输入流            字符输出流</span><br><span class="hljs-comment">     InputStream             OutputStream          Reader               Writer   (抽象类)</span><br><span class="hljs-comment">     FileInputStream         FileOutputStream      FileReader           FileWriter(实现类)</span><br><span class="hljs-comment">     BufferedInputStream     BufferedOutputStream  BufferedReader       BufferedWriter(实现类，缓冲流)</span><br><span class="hljs-comment">                                                   InputStreamReader    OutputStreamWriter</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     字符输出转换流：OutputStreamWriter</span><br><span class="hljs-comment">           -- 作用：可以指定编码把字节输出流转换成字符输出流。</span><br><span class="hljs-comment">                   可以指定写出去的字符的编码。</span><br><span class="hljs-comment">           -- 构造器：</span><br><span class="hljs-comment">                public OutputStreamWriter(OutputStream os) :   用当前默认编码UTF-8把字节输出流转换成字符输出流</span><br><span class="hljs-comment">                public OutputStreamWriter(OutputStream os , String charset):指定编码把字节输出流转换成字符输出流</span><br><span class="hljs-comment">     小结：</span><br><span class="hljs-comment">        字符输出转换流OutputStreamWriter可以指定编码把字节输出流转换成字符输出流。</span><br><span class="hljs-comment">        从而实现指定写出去的字符编码！</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OutputStreamWriterDemo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1、定义一个字节输出流</span><br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;io-app2/src/out03.txt&quot;</span>);<br><br>        <span class="hljs-comment">// 2、把原始的字节输出流转换成字符输出流</span><br>        <span class="hljs-comment">// Writer osw = new OutputStreamWriter(os); // 以默认的UTF-8写字符出去 跟直接写FileWriter一样</span><br>        <span class="hljs-type">Writer</span> <span class="hljs-variable">osw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(os , <span class="hljs-string">&quot;GBK&quot;</span>); <span class="hljs-comment">// 指定GBK的方式写字符出去</span><br><br>        <span class="hljs-comment">// 3、把低级的字符输出流包装成高级的缓冲字符输出流。</span><br>        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(osw);<br><br>        bw.write(<span class="hljs-string">&quot;我爱中国1~~&quot;</span>);<br>        bw.write(<span class="hljs-string">&quot;我爱中国2~~&quot;</span>);<br>        bw.write(<span class="hljs-string">&quot;我爱中国3~~&quot;</span>);<br><br>        bw.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h4><h6 id="对象序列化："><a href="#对象序列化：" class="headerlink" title="对象序列化："></a><strong>对象序列化</strong>：</h6><p>作用：以内存为基准，把内存中的对象存储到磁盘文件中去，称为对象序列化。</p><p>使用到的流是对象字节输出流：ObjectOutputStream</p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public ObjectOutputStream(OutputStream  out)</td><td>把低级字节输出流包装成高级的对象字节输出流</td></tr></tbody></table><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public final void writeObject(Object obj)</td><td>把对象写出去到对象序列化流的文件中去</td></tr></tbody></table><p>1.对象序列化的含义是什么？</p><p><strong>把对象数据存入到文件中去。</strong></p><p>2.对象序列化用到了哪个流？</p><p><strong>对象字节输出流ObjectOutputStram</strong></p><p><strong>public void writeObject(Object obj)</strong></p><p>3.序列化对象的要求是怎么样的？</p><p><strong>对象必须实现序列化接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  对象如果要序列化，必须实现Serializable序列化接口。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-comment">// 申明序列化的版本号码</span><br>    <span class="hljs-comment">// 序列化的版本号与反序列化的版本号必须一致才不会出错！</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String loginName;<br>    <span class="hljs-comment">// transient修饰的成员变量不参与序列化了</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> String passWord;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age ;<br>.<br>    .<br>    .  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     目标：学会对象序列化，使用 ObjectOutputStream 把内存中的对象存入到磁盘文件中。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     transient修饰的成员变量不参与序列化了</span><br><span class="hljs-comment">     对象如果要序列化，必须实现Serializable序列化接口。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     申明序列化的版本号码</span><br><span class="hljs-comment">     序列化的版本号与反序列化的版本号必须一致才不会出错！</span><br><span class="hljs-comment">     private static final long serialVersionUID = 1;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectOutputStreamDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1、创建学生对象</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;陈磊&quot;</span>, <span class="hljs-string">&quot;chenlei&quot;</span>,<span class="hljs-string">&quot;1314520&quot;</span>, <span class="hljs-number">21</span>);<br><br>        <span class="hljs-comment">// 2、对象序列化：使用对象字节输出流包装字节输出流管道</span><br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;io-app2/src/obj.txt&quot;</span>));<br><br>        <span class="hljs-comment">// 3、直接调用序列化方法</span><br>        oos.writeObject(s);<br><br>        <span class="hljs-comment">// 4、释放资源</span><br>        oos.close();<br>        System.out.println(<span class="hljs-string">&quot;序列化完成了~~&quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="对象反序列化："><a href="#对象反序列化：" class="headerlink" title="对象反序列化："></a><strong>对象反序列化</strong>：</h6><p>使用到的流是对象字节输入流：ObjectInputStream</p><p>作用：以内存为基准，把存储到磁盘文件中去的对象数据恢复成内存中的对象，称为对象反序列化。</p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public ObjectInputStream(InputStream  out)</td><td>把低级字节输如流包装成高级的对象字节输入流</td></tr></tbody></table><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public  Object readObject()</td><td>把存储到磁盘文件中去的对象数据恢复成内存中的对象返回</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：学会进行对象反序列化：使用对象字节输入流把文件中的对象数据恢复成内存中的Java对象。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectInputStreamDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1、创建对象字节输入流管道包装低级的字节输入流管道</span><br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;io-app2/src/obj.txt&quot;</span>));<br><br>        <span class="hljs-comment">// 2、调用对象字节输入流的反序列化方法</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (Student) is.readObject();<br><br>        System.out.println(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h6><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220429103304035.png" alt="image-20220429103304035"></p><p><strong>打印流</strong></p><p>作用：打印流可以实现方便、高效的打印数据到文件中去。打印流一般是指：PrintStream，PrintWriter两个类。</p><p>可以实现打印什么数据就是什么数据，例如打印整数97写出去就是97，打印boolean的true，写出去就是true。</p><p><strong>PrintStream</strong></p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public PrintStream(OutputStream os)</td><td>打印流直接通向字节输出流管道</td></tr><tr><td>public PrintStream(File f)</td><td>打印流直接通向文件对象</td></tr><tr><td>public PrintStream(String filepath)</td><td>打印流直接通向文件路径</td></tr></tbody></table><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public void print(Xxx  xx)</td><td>打印任意类型的数据出去</td></tr></tbody></table><p><strong>PrintWriter</strong></p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public PrintWriter(OutputStream os)</td><td>打印流直接通向字节输出流管道</td></tr><tr><td>public PrintWriter (Writer w)</td><td>打印流直接通向字符输出流管道</td></tr><tr><td>public PrintWriter (File f)</td><td>打印流直接通向文件对象</td></tr><tr><td>public PrintWriter (String filepath)</td><td>打印流直接通向文件路径</td></tr></tbody></table><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public void print(Xxx  xx)</td><td>打印任意类型的数据出去</td></tr></tbody></table><p><strong>PrintStream和PrintWriter的区别</strong></p><p>打印数据功能上是一模一样的，都是使用方便，性能高效（核心优势）</p><p>PrintStream继承自字节输出流OutputStream，支持写字节数据的方法。</p><p>PrintWriter继承自字符输出流Writer，支持写字符数据出去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：学会使用打印流 高效  方便写数据到文件。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1、创建一个打印流对象</span><br><span class="hljs-comment">//        PrintStream ps = new PrintStream(new FileOutputStream(&quot;io-app2/src/ps.txt&quot;));</span><br><span class="hljs-comment">//        PrintStream ps = new PrintStream(new FileOutputStream(&quot;io-app2/src/ps.txt&quot; , true)); // 追加数据，在低级管道后面加True</span><br><span class="hljs-comment">//        PrintStream ps = new PrintStream(&quot;io-app2/src/ps.txt&quot; );</span><br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(<span class="hljs-string">&quot;io-app2/src/ps.txt&quot;</span>); <span class="hljs-comment">// 打印功能上与PrintStream的使用没有区别</span><br><br>        ps.println(<span class="hljs-number">97</span>);<br>        ps.println(<span class="hljs-string">&#x27;a&#x27;</span>);<br>        ps.println(<span class="hljs-number">23.3</span>);<br>        ps.println(<span class="hljs-literal">true</span>);<br>        ps.println(<span class="hljs-string">&quot;我是打印流输出的，我是啥就打印啥&quot;</span>);<br><br>        ps.close();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：了解改变输出语句的位置到文件</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;锦瑟无端五十弦&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;一弦一柱思华年&quot;</span>);<br><br>        <span class="hljs-comment">// 改变输出语句的位置（重定向）</span><br>        <span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(<span class="hljs-string">&quot;io-app2/src/log.txt&quot;</span>);<br>        System.setOut(ps); <span class="hljs-comment">// 把系统打印流改成我们自己的打印流</span><br><br>        System.out.println(<span class="hljs-string">&quot;庄生晓梦迷蝴蝶&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;望帝春心托杜鹃&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>1.打印流有几种？各有什么特点？</p><p><strong>打印流一般是指：PrintStream，PrintWriter两个类。</strong></p><p><strong>打印功能2者是一样的使用方式</strong></p><p><strong>PrintStream继承自字节输出流OutputStream，支持写字节</strong></p><p><strong>PrintWrite继承自字符输出流Writer，支持写字符</strong></p><p>2.打印流的优势是什么？</p><p><strong>两者在打印功能上都是使用方便，性能高效（核心优势）</strong></p><h6 id="补充知识Properties"><a href="#补充知识Properties" class="headerlink" title="补充知识Properties"></a>补充知识Properties</h6><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220429104602782.png" alt="image-20220429104602782"></p><p><strong>Properties属性集对象</strong></p><p>​    其实就是一个Map集合，但是我们一般不会当集合使用，因为HashMap更好用。</p><p><strong>Properties核心作用：</strong></p><p>​    Properties代表的是一个属性文件，可以把自己对象中的键值对信息存入到一个属性文件中去。</p><p>​    属性文件：后缀是.properties结尾的文件,里面的内容都是 key=value，后续做系统配置信息的。</p><p>1.Properties的作用？</p><p><strong>可以存储Properties属性集的键值对数据到属性文件中去：</strong></p><p>​    <strong>void store(Writer writer, String comments)</strong></p><p><strong>可以加载属性文件中的数据到Properties对象中来：</strong></p><p>​    <strong>void load(Reader reader)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：Properties的概述和使用(框架底层使用，了解这个技术即可)（保存数据到属性文件）</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Properties: 属性集对象。</span><br><span class="hljs-comment">         其实就是一个Map集合。也就是一个键值对集合，但是我们一般不会当集合使用，</span><br><span class="hljs-comment">         因为有HashMap。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Properties核心作用：</span><br><span class="hljs-comment">         Properties代表的是一个属性文件，可以把键值对的数据存入到一个属性文件中去。</span><br><span class="hljs-comment">         属性文件：后缀是.properties结尾的文件,里面的内容都是 key=value。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    大家在后期学的很多大型框架技术中，属性文件都是很重要的系统配置文件。</span><br><span class="hljs-comment">        users.properties</span><br><span class="hljs-comment">                admin=123456</span><br><span class="hljs-comment">                dlei=dlei</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     需求：使用Properties对象生成一个属性文件，里面存入用户名和密码信息。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     Properties的方法：</span><br><span class="hljs-comment">         -- public Object setProperty(String key, String value) ： 保存一对属性。  (put)</span><br><span class="hljs-comment">         -- public String getProperty(String key) : 使用此属性列表中指定的键搜索属性值 (get)</span><br><span class="hljs-comment">         -- public Set&lt;String&gt; stringPropertyNames() : 所有键的名称的集合  (keySet())</span><br><span class="hljs-comment">         -- public void store(OutputStream out, String comments): 保存数据到属性文件中去</span><br><span class="hljs-comment">         -- public void store(Writer fw, String comments): 保存数据到属性文件中去</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     小结：</span><br><span class="hljs-comment">            Properties可以保存键值对数据到属性文件</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PropertiesDemo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 需求：使用Properties把键值对信息存入到属性文件中去。</span><br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        properties.setProperty(<span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>);<br>        properties.setProperty(<span class="hljs-string">&quot;dlei&quot;</span>, <span class="hljs-string">&quot;003197&quot;</span>);<br>        properties.setProperty(<span class="hljs-string">&quot;heima&quot;</span>, <span class="hljs-string">&quot;itcast&quot;</span>);<br>        System.out.println(properties);<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">           参数一：保存管道 字符输出流管道</span><br><span class="hljs-comment">           参数二：保存心得</span><br><span class="hljs-comment">         */</span><br>        properties.store(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;io-app2/src/users.properties&quot;</span>)<br>                , <span class="hljs-string">&quot;this is users!! i am very happy! give me 100!&quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：Properties读取属性文件中的键值对信息。（读取）</span><br><span class="hljs-comment">    Properties的方法：</span><br><span class="hljs-comment">        -- public Object setProperty(String key, String value) ： 保存一对属性。</span><br><span class="hljs-comment">        -- public String getProperty(String key) ：使用此属性列表中指定的键搜索属性值</span><br><span class="hljs-comment">        -- public Set&lt;String&gt; stringPropertyNames() ：所有键的名称的集合</span><br><span class="hljs-comment">        -- public void store(OutputStream out, String comments):保存数据到属性文件中去</span><br><span class="hljs-comment">        -- public synchronized void load(InputStream inStream):加载属性文件的数据到属性集对象中去</span><br><span class="hljs-comment">        -- public synchronized void load(Reader fr):加载属性文件的数据到属性集对象中去</span><br><span class="hljs-comment">    小结：</span><br><span class="hljs-comment">        属性集对象可以加载读取属性文件中的数据!!</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PropertiesDemo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 需求：Properties读取属性文件中的键值对信息。（读取）</span><br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        System.out.println(properties);<br><br>        <span class="hljs-comment">// 加载属性文件中的键值对数据到属性对象properties中去</span><br>        properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;io-app2/src/users.properties&quot;</span>));<br><br>        System.out.println(properties);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;dlei&quot;</span>);<br>        System.out.println(rs);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">rs1</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;admin&quot;</span>);<br>        System.out.println(rs1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>void load(InputStream inStream)</td><td>从输入字节流读取属性列表（键和元素对）</td></tr><tr><td>void  load(Reader reader)</td><td>从输入字符流读取属性列表（键和元素对）</td></tr><tr><td>void store(OutputStream out,  String comments)</td><td>将此属性列表（键和元素对）写入此  Properties表中，以适合于使用 load(InputStream)方法的格式写入输出字节流</td></tr><tr><td>void  store(Writer writer, String comments)</td><td>将此属性列表（键和元素对）写入此  Properties表中，以适合使用 load(Reader)方法的格式写入输出字符流</td></tr><tr><td>public Object setProperty(String  key, String value)</td><td>保存键值对（put）</td></tr><tr><td>public String getProperty(String  key)</td><td>使用此属性列表中指定的键搜索属性值  (get)</td></tr><tr><td>public Set<String> stringPropertyNames()</td><td>所有键的名称的集合 (keySet())</td></tr></tbody></table><h4 id="IO框架：commons-io"><a href="#IO框架：commons-io" class="headerlink" title="IO框架：commons-io"></a>IO框架：commons-io</h4><p><strong>commons-io概述</strong></p><ul><li><p>commons-io是apache开源基金组织提供的一组有关IO操作的类库，可以提高IO功能开发的效率。</p></li><li><p>commons-io工具包提供了很多有关io操作的类。有两个主要的类FileUtils, IOUtils</p></li></ul><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>String  readFileToString(File  file, String encoding)</td><td>读取文件中的数据, 返回字符串</td></tr><tr><td>void  copyFile(File  srcFile, File destFile)</td><td>复制文件。</td></tr><tr><td>void  copyDirectoryToDirectory(File  srcDir,  File destDir)</td><td>复制文件夹。</td></tr></tbody></table><p>导入commons-io-2.6.jar做开发</p><p><strong>需求</strong></p><p>使用commons-io简化io流读写</p><p><strong>分析</strong></p><p>①在项目中创建一个文件夹：lib</p><p>②将commons-io-2.6.jar文件复制到lib文件夹</p><p>③在jar文件上点右键，选择 Add as Library -&gt; 点击OK</p><p>④在类中导包使用</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h4 id="线程创建方式"><a href="#线程创建方式" class="headerlink" title="线程创建方式"></a>线程创建方式</h4><h6 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a><strong>Thread类</strong></h6><p>Java是通过java.lang.Thread 类来代表线程的。 </p><p>按照面向对象的思想，Thread类应该提供了实现多线程的方式。</p><h6 id="多线程的实现方案一：继承Thread类"><a href="#多线程的实现方案一：继承Thread类" class="headerlink" title="多线程的实现方案一：继承Thread类"></a><strong>多线程的实现方案一：继承Thread类</strong></h6><p>①定义一个子类MyThread继承线程类java.lang.Thread，重写run()方法</p><p>②创建MyThread类的对象</p><p>③调用线程对象的start()方法启动线程（启动后还是执行run方法的）</p><p><strong>1.为什么不直接调用了run方法，而是调用start启动线程?</strong></p><ul><li><p>直接调用run方法会当成普通方法执行，此时相当于还是单线程执行。</p></li><li><p>只有调用start方法才是启动一个新的线程执行。</p></li></ul><p><strong>2、把主线程任务放在子线程之前了。</strong></p><ul><li>这样主线程一直是先跑完的，相当于是一个单线程的效果了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   目标：多线程的创建方式一：继承Thread类实现。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 3、new一个新线程对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        <span class="hljs-comment">// 4、调用start方法启动线程（执行的还是run方法）</span><br>        t.start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;主线程执行输出：&quot;</span> + i);<br>        &#125;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">   1、定义一个线程类继承Thread类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">       2、重写run方法，里面是定义线程以后要干啥</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;子线程执行输出：&quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>方式一优缺点：</strong></p><p>优点：编码简单</p><p>缺点：线程类已经继承Thread，无法继承其他类，不利于扩展。</p><h6 id="多线程的实现方案二：实现Runnable口"><a href="#多线程的实现方案二：实现Runnable口" class="headerlink" title="多线程的实现方案二：实现Runnable口"></a><strong>多线程的实现方案二：实现Runnable口</strong></h6><p>①定义一个线程任务类MyRunnable实现Runnable接口，重写run()方法</p><p>②创建MyRunnable任务对象</p><p>③把MyRunnable任务对象交给Thread处理。</p><p>④调用线程对象的start()方法启动线程</p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public Thread(String name)</td><td>可以为当前线程指定名称</td></tr><tr><td>public Thread(Runnable target)</td><td>封装Runnable对象成为线程对象</td></tr><tr><td>public Thread(Runnable target ，String name )</td><td>封装Runnable对象成为线程对象，并指定线程名称</td></tr></tbody></table><p><strong>方式二优缺点：</strong></p><p>优点：线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强。</p><p>缺点：编程多一层对象包装，如果线程有执行结果是不可以直接返回的</p><h6 id="多线程的实现方案三：利用Callable、FutureTask接口实现。"><a href="#多线程的实现方案三：利用Callable、FutureTask接口实现。" class="headerlink" title="多线程的实现方案三：利用Callable、FutureTask接口实现。"></a><strong>多线程的实现方案三：利用Callable、FutureTask接口实现。</strong></h6><p>①、得到任务对象</p><p>​    1.定义类实现Callable接口，重写call方法，封装要做的事情。</p><p>​    2.用FutureTask把Callable对象封装成线程任务对象。</p><p>②、把线程任务对象交给Thread处理。</p><p>③、调用Thread的start方法启动线程，执行任务</p><p>④、线程执行完毕后、通过FutureTask的get方法去获取任务执行的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   目标：学会线程的创建方式三：实现Callable接口，结合FutureTask完成。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 3、创建Callable任务对象</span><br>        Callable&lt;String&gt; call = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">100</span>);<br>        <span class="hljs-comment">// 4、把Callable任务对象 交给 FutureTask 对象</span><br>        <span class="hljs-comment">//  FutureTask对象的作用1： 是Runnable的对象（实现了Runnable接口），可以交给Thread了</span><br>        <span class="hljs-comment">//  FutureTask对象的作用2： 可以在线程执行完毕之后通过调用其get方法得到线程执行完成的结果</span><br>        FutureTask&lt;String&gt; f1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(call);<br>        <span class="hljs-comment">// 5、交给线程处理</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(f1);<br>        <span class="hljs-comment">// 6、启动线程</span><br>        t1.start();<br><br><br>        Callable&lt;String&gt; call2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">200</span>);<br>        FutureTask&lt;String&gt; f2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(call2);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(f2);<br>        t2.start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 如果f1任务没有执行完毕，这里的代码会等待，直到线程1跑完才提取结果。</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">rs1</span> <span class="hljs-operator">=</span> f1.get();<br>            System.out.println(<span class="hljs-string">&quot;第一个结果：&quot;</span> + rs1);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 如果f2任务没有执行完毕，这里的代码会等待，直到线程2跑完才提取结果。</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">rs2</span> <span class="hljs-operator">=</span> f2.get();<br>            System.out.println(<span class="hljs-string">&quot;第二个结果：&quot;</span> + rs2);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    1、定义一个任务类 实现Callable接口  应该申明线程任务执行完毕后的结果的数据类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt;&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyCallable</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">       2、重写call方法（任务方法）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n ; i++) &#123;<br>            sum += i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;子线程执行的结果是：&quot;</span> + sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public FutureTask&lt;&gt;(Callable call)</td><td>把Callable对象封装成FutureTask对象。</td></tr><tr><td>public V get() throws Exception</td><td>获取线程执行call方法返回的结果。</td></tr></tbody></table><p><strong>方式三优缺点：</strong></p><p>优点：线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强。</p><p>可以在线程执行完毕后去获取线程执行的结果。</p><p>缺点：编码复杂一点。</p><h6 id="三种方法对比"><a href="#三种方法对比" class="headerlink" title="三种方法对比"></a>三种方法对比</h6><table><thead><tr><th>方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>继承Thread类</td><td>编程比较简单，可以直接使用Thread类中的方法</td><td>扩展性较差，不能再继承其他的类，不能返回线程执行的结果</td></tr><tr><td>实现Runnable接口</td><td>扩展性强，实现该接口的同时还可以继承其他的类。</td><td>编程相对复杂，不能返回线程执行的结果</td></tr><tr><td>实现Callable接口</td><td>扩展性强，实现该接口的同时还可以继承其他的类。可以得到线程执行的结果</td><td>编程相对复杂</td></tr></tbody></table><h6 id="线程常用API"><a href="#线程常用API" class="headerlink" title="线程常用API"></a>线程常用API</h6><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>String  getName()</td><td>获取当前线程的名称，默认线程名称是Thread-索引</td></tr><tr><td>void  setName(String  name)</td><td>设置线程名称</td></tr><tr><td>public  static Thread currentThread()：</td><td>返回对当前正在执行的线程对象的引用</td></tr><tr><td>public  static void sleep(long time)</td><td>让线程休眠指定的时间，单位为毫秒。</td></tr><tr><td>public  void run()</td><td>线程任务方法</td></tr><tr><td>public  void start()</td><td>线程启动方法</td></tr></tbody></table><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public  Thread(String name)</td><td>可以为当前线程指定名称</td></tr><tr><td>public  Thread(Runnable target)</td><td>把Runnable对象交给线程对象</td></tr><tr><td>public  Thread(Runnable target ，String name )</td><td>把Runnable对象交给线程对象，并指定线程名称</td></tr></tbody></table><h6 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a><strong>线程安全问题</strong></h6><p>多个线程同时操作同一个共享资源的时候可能会出现业务安全问题，称为线程安全问题。</p><p>1.线程安全问题出现的原因？</p><p><strong>存在多线程并发</strong></p><p><strong>同时访问共享资源</strong></p><p><strong>存在修改共享资源</strong></p><h6 id="案例：家庭账户问题"><a href="#案例：家庭账户问题" class="headerlink" title="案例：家庭账户问题"></a>案例：家庭账户问题</h6><p>小明和小红是一对夫妻，他们有一个共同的账户，余额是10万元，模拟2人同时去取钱10万。</p><p><strong>分析：</strong></p><p>①：需要提供一个账户类，创建一个账户对象代表2个人的共享账户。</p><p>②：需要定义一个线程类，线程类可以处理账户对象。</p><p>③：创建2个线程对象，传入同一个账户对象。</p><p>④：启动2个线程，去同一个账户对象中取钱10万。</p><p>//银行亏十万</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br>    <span class="hljs-keyword">private</span> String cardId;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> money; <span class="hljs-comment">// 账户的余额</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Account</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Account</span><span class="hljs-params">(String cardId, <span class="hljs-type">double</span> money)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cardId = cardId;<br>        <span class="hljs-built_in">this</span>.money = money;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">       小明 小红</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawMoney</span><span class="hljs-params">(<span class="hljs-type">double</span> money)</span> &#123;<br>        <span class="hljs-comment">// 0、先获取是谁来取钱，线程的名字就是人名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>        <span class="hljs-comment">// 1、判断账户是否够钱</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.money &gt;= money)&#123;<br>            <span class="hljs-comment">// 2、取钱</span><br>            System.out.println(name + <span class="hljs-string">&quot;来取钱成功，吐出：&quot;</span> + money);<br>            <span class="hljs-comment">// 3、更新余额</span><br>            <span class="hljs-built_in">this</span>.money -= money;<br>            System.out.println(name + <span class="hljs-string">&quot;取钱后剩余：&quot;</span> + <span class="hljs-built_in">this</span>.money);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 4、余额不足</span><br>            System.out.println(name +<span class="hljs-string">&quot;来取钱，余额不足！&quot;</span>);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCardId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> cardId;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCardId</span><span class="hljs-params">(String cardId)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cardId = cardId;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getMoney</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> money;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMoney</span><span class="hljs-params">(<span class="hljs-type">double</span> money)</span> &#123;<br>        <span class="hljs-built_in">this</span>.money = money;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   取钱的线程类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DrawThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-comment">// 接收处理的账户对象</span><br>    <span class="hljs-keyword">private</span> Account acc;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DrawThread</span><span class="hljs-params">(Account acc,String name)</span>&#123;<br>        <span class="hljs-built_in">super</span>(name);<br>        <span class="hljs-built_in">this</span>.acc = acc;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 小明 小红：取钱</span><br>        acc.drawMoney(<span class="hljs-number">100000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    需求：模拟取钱案例。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1、定义线程类，创建一个共享的账户对象</span><br>        <span class="hljs-type">Account</span> <span class="hljs-variable">acc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Account</span>(<span class="hljs-string">&quot;ICBC-111&quot;</span>, <span class="hljs-number">100000</span>);<br><br>        <span class="hljs-comment">// 2、创建2个线程对象，代表小明和小红同时进来了。</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">DrawThread</span>(acc, <span class="hljs-string">&quot;小明&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">DrawThread</span>(acc, <span class="hljs-string">&quot;小红&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h6><p><strong>同步代码块</strong></p><p>作用：把出现线程安全问题的核心代码给上锁。</p><p>原理：每次只能一个线程进入，执行完毕后自动解锁，其他线程才可以进来执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(同步锁对象) &#123;<br>  操作共享资源的代码(核心代码)<br> &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">      小明 小红</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawMoney</span><span class="hljs-params">(<span class="hljs-type">double</span> money)</span> &#123;<br>        <span class="hljs-comment">// 1、拿到是谁来取钱</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>        <span class="hljs-comment">// 同步代码块</span><br>        <span class="hljs-comment">// 小明 小红</span><br>        <span class="hljs-comment">// this == acc 共享账户</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-comment">// 2、判断余额是否足够</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.money &gt;= money)&#123;<br>                <span class="hljs-comment">// 钱够了</span><br>                System.out.println(name+<span class="hljs-string">&quot;来取钱，吐出：&quot;</span> + money);<br>                <span class="hljs-comment">// 更新余额</span><br>                <span class="hljs-built_in">this</span>.money -= money;<br>                System.out.println(name+<span class="hljs-string">&quot;取钱后，余额剩余：&quot;</span> + <span class="hljs-built_in">this</span>.money);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 3、余额不足</span><br>                System.out.println(name+<span class="hljs-string">&quot;来取钱，余额不足！&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>锁对象的规范要求</strong></p><p>规范上：建议使用共享资源作为锁对象。</p><p>对于实例方法建议使用this作为锁对象。</p><p>对于静态方法建议使用字节码（类名.class）对象作为锁对象。</p><h6 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a><strong>同步方法</strong></h6><p>作用：把出现线程安全问题的核心方法给上锁。</p><p>原理：每次只能一个线程进入，执行完毕以后自动解锁，其他线程才可以进来执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-keyword">synchronized</span> 返回值类型 方法名称(形参列表) &#123;<br>    操作共享资源的代码<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">      小明 小红</span><br><span class="hljs-comment">       this == acc</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawMoney</span><span class="hljs-params">(<span class="hljs-type">double</span> money)</span> &#123;<br>        <span class="hljs-comment">// 1、拿到是谁来取钱</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>        <span class="hljs-comment">// 2、判断余额是否足够</span><br>        <span class="hljs-comment">// 小明  小红</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.money &gt;= money)&#123;<br>            <span class="hljs-comment">// 钱够了</span><br>            System.out.println(name+<span class="hljs-string">&quot;来取钱，吐出：&quot;</span> + money);<br>            <span class="hljs-comment">// 更新余额</span><br>            <span class="hljs-built_in">this</span>.money -= money;<br>            System.out.println(name+<span class="hljs-string">&quot;取钱后，余额剩余：&quot;</span> + <span class="hljs-built_in">this</span>.money);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 3、余额不足</span><br>            System.out.println(name+<span class="hljs-string">&quot;来取钱，余额不足！&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>同步方法底层原理</strong></p><ul><li><p>同步方法其实底层也是有隐式锁对象的，只是锁的范围是整个方法代码。</p></li><li><p>如果方法是实例方法：同步方法默认用this作为的锁对象。但是代码要高度面向对象！</p></li><li><p>如果方法是静态方法：同步方法默认用类名.class作为的锁对象。</p></li></ul><h6 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a><strong>Lock锁</strong></h6><ul><li><p>为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock，更加灵活、方便。</p></li><li><p>Lock实现提供比使用synchronized方法和语句可以获得更广泛的锁定操作。</p></li><li><p>Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来构建Lock锁对象。</p></li></ul><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public ReentrantLock()</td><td>获得Lock锁的实现类对象</td></tr></tbody></table><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>void lock()</td><td>获得锁</td></tr><tr><td>void  unlock()</td><td>释放锁</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// final修饰后：锁对象是唯一和不可替换的，非常专业</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     小明 小红</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawMoney</span><span class="hljs-params">(<span class="hljs-type">double</span> money)</span> &#123;<br>       <span class="hljs-comment">// 1、拿到是谁来取钱</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>       <span class="hljs-comment">// 2、判断余额是否足够</span><br>       <span class="hljs-comment">// 小明  小红</span><br>       lock.lock(); <span class="hljs-comment">// 上锁</span><br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.money &gt;= money)&#123;<br>               <span class="hljs-comment">// 钱够了</span><br>               System.out.println(name+<span class="hljs-string">&quot;来取钱，吐出：&quot;</span> + money);<br>               <span class="hljs-comment">// 更新余额</span><br>               <span class="hljs-built_in">this</span>.money -= money;<br>               System.out.println(name+<span class="hljs-string">&quot;取钱后，余额剩余：&quot;</span> + <span class="hljs-built_in">this</span>.money);<br>           &#125;<span class="hljs-keyword">else</span>&#123;<br>               <span class="hljs-comment">// 3、余额不足</span><br>               System.out.println(name+<span class="hljs-string">&quot;来取钱，余额不足！&quot;</span>);<br>           &#125;<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>           lock.unlock(); <span class="hljs-comment">// 解锁</span><br>       &#125;<br><br>   &#125;<br></code></pre></td></tr></table></figure><h6 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h6><p><strong>什么是线程通信、如何实现？</strong></p><p>所谓线程通信就是线程间相互发送数据，线程间共享一个资源即可实现线程通信。</p><p><strong>线程通信常见形式</strong></p><p>通过共享一个数据的方式实现。</p><p>根据共享数据的情况决定自己该怎么做，以及通知其他线程怎么做。</p><p><strong>线程通信实际应用场景</strong></p><ul><li><p>生产者与消费者模型：生产者线程负责生产数据，消费者线程负责消费生产者产生的数据。</p></li><li><p>要求：生产者线程生产完数据后唤醒消费者，然后等待自己，消费者消费完该数据后唤醒生产者，然后等待自己。</p></li></ul><h6 id="线程通信案例模拟"><a href="#线程通信案例模拟" class="headerlink" title="线程通信案例模拟"></a><strong>线程通信案例模拟</strong></h6><p>模拟客服系统，系统可以不断的接入电话 和 分发给客服。</p><p>线程通信的前提：线程通信通常是在多个线程操作同一个共享资源的时候需要进行通信，且要保证线程安全。</p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>void  wait()</td><td>让当前线程等待并释放所占锁，直到另一个线程调用notify()方法或 notifyAll()方法</td></tr><tr><td>void  notify()</td><td>唤醒正在等待的单个线程</td></tr><tr><td>void notifyAll()</td><td>唤醒正在等待的所有线程</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">打电话线程</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 不断的打入电话</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            CallSystem.call();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">   接电话线程类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReceiveThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 1号  2号</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            CallSystem.receive();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">测试</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1、生产者线程：负责不断接收打进来的电话</span><br>        <span class="hljs-type">CallThread</span> <span class="hljs-variable">call</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CallThread</span>();<br>        call.start();<br><br>        <span class="hljs-comment">// 2、消费者线程：客服，每个客服每次接听一个电话</span><br>        <span class="hljs-type">ReceiveThread</span> <span class="hljs-variable">r1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReceiveThread</span>();<br>        r1.start();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">   呼叫系统。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallSystem</span> &#123;<br>    <span class="hljs-comment">// 定义一个变量记录当前呼入进来的电话。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 最多只接听一个。</span><br><br>    <span class="hljs-comment">/* 接入电话</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            number++;<br>            System.out.println(<span class="hljs-string">&quot;成功接入一个用户，等待分发~~~~&quot;</span>);<br><br>            <span class="hljs-comment">// 唤醒别人 : 1个</span><br>            CallSystem.class.notify();<br>            <span class="hljs-comment">// 让当前线程对象进入等待状态。</span><br>            CallSystem.class.wait();<br><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">       分发电话</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receive</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>            <span class="hljs-keyword">if</span>(number == <span class="hljs-number">1</span>)&#123;<br>                System.out.println(name + <span class="hljs-string">&quot;此电话已经分发给客服并接听完毕了~~~~~&quot;</span>);<br>                number--;<br>                <span class="hljs-comment">// 唤醒别人 : 1个</span><br>                CallSystem.class.notify();<br>                CallSystem.class.wait(); <span class="hljs-comment">// 让当前线程等待</span><br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 唤醒别人 : 1个</span><br>                CallSystem.class.notify();<br>                CallSystem.class.wait(); <span class="hljs-comment">// 让当前线程等待</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h6><p>线程池就是一个可以复用线程的技术。</p><p><strong>不使用线程池的问题</strong> </p><p>如果用户每发起一个请求，后台就创建一个新线程来处理，下次新任务来了又要创建新线程，而创建新线程的开销是很大的，这样会严重影响系统的性能。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220429161856082.png" alt="image-20220429161856082"></p><p><strong>如何得到线程池对象</strong></p><p>方式一：使用ExecutorService的实现类ThreadPoolExecutor自创建一个线程池对象</p><p>方式二：使用Executors（线程池的工具类）调用方法返回不同特点的线程池对象</p><p><strong>ThreadPoolExecutor构造器的参数说明</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(</span><br><span class="hljs-params"><span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params"><span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params"><span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">TimeUnit unit,</span><br><span class="hljs-params">BlockingQueue&lt;Runnable&gt; workQueue,                          </span><br><span class="hljs-params">ThreadFactory threadFactory,                   RejectedExecutionHandler handler)</span> <br></code></pre></td></tr></table></figure><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220429162504314.png" alt="image-20220429162504314"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;输出了：HelloWorld ==&gt; &quot;</span>  + i);<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;本任务与线程绑定了，线程进入休眠了~~~&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">10000000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：自定义一个线程池对象，并测试其特性。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1、创建线程池对象</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         public ThreadPoolExecutor(int corePoolSize,</span><br><span class="hljs-comment">                                 int maximumPoolSize,</span><br><span class="hljs-comment">                                 long keepAliveTime,</span><br><span class="hljs-comment">                                 TimeUnit unit,</span><br><span class="hljs-comment">                                 BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-comment">                                 ThreadFactory threadFactory,</span><br><span class="hljs-comment">                                 RejectedExecutionHandler handler)</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5</span> ,<br>                <span class="hljs-number">6</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">5</span>) , Executors.defaultThreadFactory(),<br>               <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy() );<br><br>        <span class="hljs-comment">// 2、给任务线程池处理。</span><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br>        <span class="hljs-comment">//线程池工作线程</span><br>        pool.execute(target);<br>        pool.execute(target);<br>        pool.execute(target);<br><span class="hljs-comment">//线程队列</span><br>        pool.execute(target);<br>        pool.execute(target);<br>        pool.execute(target);<br>        pool.execute(target);<br>        pool.execute(target);<br><br>        <span class="hljs-comment">// 创建临时线程</span><br>        pool.execute(target);<br>        pool.execute(target);<br><span class="hljs-comment">//        // 不创建，拒绝策略被触发！！！</span><br><span class="hljs-comment">//        pool.execute(target);</span><br><br>        <span class="hljs-comment">// 关闭线程池（开发中一般不会使用）。</span><br>        <span class="hljs-comment">// pool.shutdownNow(); // 立即关闭，即使任务没有完成，会丢失任务的！</span><br>        pool.shutdown(); <span class="hljs-comment">// 会等待全部任务执行完毕之后再关闭（建议使用的）</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>void execute(Runnable command)</td><td>执行任务/命令，没有返回值，一般用来执行  Runnable 任务</td></tr><tr><td>Future<T>  submit(Callable<T> task)</td><td>执行任务，返回未来任务对象获取线程结果，一般拿来执行  Callable 任务</td></tr><tr><td>void  shutdown()</td><td>等任务执行完毕后关闭线程池</td></tr><tr><td>List&lt;[Runnable]&gt;shutdownNow()</td><td>立刻关闭，停止正在执行的任务，并返回队列中未执行的任务</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：自定义一个线程池对象，并测试其特性。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1、创建线程池对象</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         public ThreadPoolExecutor(int corePoolSize,</span><br><span class="hljs-comment">                                 int maximumPoolSize,</span><br><span class="hljs-comment">                                 long keepAliveTime,</span><br><span class="hljs-comment">                                 TimeUnit unit,</span><br><span class="hljs-comment">                                 BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-comment">                                 ThreadFactory threadFactory,</span><br><span class="hljs-comment">                                 RejectedExecutionHandler handler)</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5</span> ,<br>                <span class="hljs-number">6</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">5</span>) , Executors.defaultThreadFactory(),<br>               <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy() );<br><br>        <span class="hljs-comment">// 2、给任务线程池处理。</span><br>        Future&lt;String&gt; f1 = pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">100</span>));<br>        Future&lt;String&gt; f2 = pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">200</span>));<br>        Future&lt;String&gt; f3 = pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">300</span>));<br>        Future&lt;String&gt; f4 = pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">400</span>));<br>        Future&lt;String&gt; f5 = pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">500</span>));<br><br><span class="hljs-comment">//        String rs = f1.get();</span><br><span class="hljs-comment">//        System.out.println(rs);</span><br><br>        System.out.println(f1.get());<br>        System.out.println(f2.get());<br>        System.out.println(f3.get());<br>        System.out.println(f4.get());<br>        System.out.println(f5.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="Executors得到线程池对象的常用方法"><a href="#Executors得到线程池对象的常用方法" class="headerlink" title="Executors得到线程池对象的常用方法"></a><strong>Executors得到线程池对象的常用方法</strong></h6><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public  static <a href="mk:@MSITStore:D:\course\jdk-11中文api修订版.CHM::/java.base/java/util/concurrent/ExecutorService.html">ExecutorService</a> newCachedThreadPool()</td><td>线程数量随着任务增加而增加，如果线程任务执行完毕且空闲了一段时间则会被回收掉。</td></tr><tr><td>public static <a href="mk:@MSITStore:D:\course\jdk-11中文api修订版.CHM::/java.base/java/util/concurrent/ExecutorService.html">ExecutorService</a> newFixedThreadPool(int nThreads)</td><td>创建固定线程数量的线程池，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程替代它。</td></tr><tr><td>public  static <a href="mk:@MSITStore:D:\course\jdk-11中文api修订版.CHM::/java.base/java/util/concurrent/ExecutorService.html">ExecutorService</a> newSingleThreadExecutor ()</td><td>创建只有一个线程的线程池对象，如果该线程出现异常而结束，那么线程池会补充一个新线程。</td></tr><tr><td>public  static <a href="mk:@MSITStore:D:\course\jdk-11中文api修订版.CHM::/java.base/java/util/concurrent/ScheduledExecutorService.html">ScheduledExecutorService</a> newScheduledThreadPool(int corePoolSize)</td><td>创建一个线程池，可以实现在给定的延迟后运行任务，或者定期执行任务。</td></tr></tbody></table><table><thead><tr><th>方法名称</th><th>存在问题</th></tr></thead><tbody><tr><td>public  static <a href="mk:@MSITStore:D:\course\jdk-11中文api修订版.CHM::/java.base/java/util/concurrent/ExecutorService.html">ExecutorService</a> newFixedThreadPool(int nThreads)</td><td>允许请求的任务队列长度是Integer.MAX_VALUE，可能出现OOM错误（ java.lang.OutOfMemoryError  ）</td></tr><tr><td>public  static <a href="mk:@MSITStore:D:\course\jdk-11中文api修订版.CHM::/java.base/java/util/concurrent/ExecutorService.html">ExecutorService</a> newSingleThreadExecutor()</td><td>同上</td></tr><tr><td>public  static <a href="mk:@MSITStore:D:\course\jdk-11中文api修订版.CHM::/java.base/java/util/concurrent/ExecutorService.html">ExecutorService</a> newCachedThreadPool()</td><td>创建的线程数量最大上限是Integer.MAX_VALUE，  线程数可能会随着任务1:1增长，也可能出现OOM错误（ java.lang.OutOfMemoryError  ）</td></tr><tr><td>public  static <a href="mk:@MSITStore:D:\course\jdk-11中文api修订版.CHM::/java.base/java/util/concurrent/ScheduledExecutorService.html">ScheduledExecutorService</a> newScheduledThreadPool(int corePoolSize)</td><td>同上</td></tr></tbody></table><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220429165534998.png" alt="image-20220429165534998"></p><h6 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a><strong>定时器</strong></h6><p>定时器是一种控制任务延时调用，或者周期调用的技术。</p><p>作用：闹钟、定时邮件发送。</p><p><strong>定时器的实现方式</strong></p><p>方式一：Timer</p><p>方式二： ScheduledExecutorService</p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public  Timer()</td><td>创建Timer定时器对象</td></tr></tbody></table><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public void schedule(<a href="file:///D:/course/%E5%9F%BA%E7%A1%80%E9%98%B6%E6%AE%B5/API%E6%96%87%E6%A1%A3/docs/api/java.base/java/util/TimerTask.html">TimerTask</a> task,  long delay, long period)</td><td>开启一个定时器，按照计划处理TimerTask任务</td></tr></tbody></table><p><strong>Timer定时器的特点和存在的问题</strong></p><p>1、Timer是单线程，处理多个任务按照顺序执行，存在延时与设置定时器的时间有出入。</p><p>2、可能因为其中的某个任务的异常使Timer线程死掉，从而影响后续任务执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：Timer定时器的使用和了解。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TimerDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1、创建Timer定时器</span><br>        <span class="hljs-type">Timer</span> <span class="hljs-variable">timer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>();  <span class="hljs-comment">// 定时器本身就是一个单线程。</span><br>        <span class="hljs-comment">// 2、调用方法，处理定时任务</span><br>        timer.schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;执行AAA~~~&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br><span class="hljs-comment">//                try &#123;</span><br><span class="hljs-comment">//                    Thread.sleep(5000);</span><br><span class="hljs-comment">//                &#125; catch (InterruptedException e) &#123;</span><br><span class="hljs-comment">//                    e.printStackTrace();</span><br><span class="hljs-comment">//                &#125;</span><br>            &#125;<br>        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">2000</span>);<br><br>        timer.schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;执行BB~~~&quot;</span>+ <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>                System.out.println(<span class="hljs-number">10</span>/<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">2000</span>);<br><br>        timer.schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;执行CCC~~~&quot;</span>+ <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>            &#125;<br>        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">3000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="ScheduledExecutorService定时器"><a href="#ScheduledExecutorService定时器" class="headerlink" title="ScheduledExecutorService定时器"></a><strong>ScheduledExecutorService定时器</strong></h6><table><thead><tr><th>Executors的方法</th><th>说明</th></tr></thead><tbody><tr><td>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)</td><td>得到线程池对象</td></tr></tbody></table><table><thead><tr><th>ScheduledExecutorService的方法</th><th>说明</th></tr></thead><tbody><tr><td>public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period,                              TimeUnit unit)</td><td>周期调度方法</td></tr></tbody></table><p><strong>ScheduledExecutorService的优点</strong></p><p>1、基于线程池，某个任务的执行情况不会影响其他定时任务的执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：Timer定时器的使用和了解。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TimerDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1、创建ScheduledExecutorService线程池，做定时器</span><br>        <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">// 2、开启定时任务</span><br>        pool.scheduleAtFixedRate(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;执行输出：AAA  ==》 &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">100000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, TimeUnit.SECONDS);<br><br><br>        pool.scheduleAtFixedRate(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;执行输出：BBB  ==》 &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>                <span class="hljs-comment">//该线程挂了，其他线程不挂</span><br>                System.out.println(<span class="hljs-number">10</span> / <span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, TimeUnit.SECONDS);<br><br><br>        pool.scheduleAtFixedRate(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;执行输出：CCC  ==》 &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>            &#125;<br>        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, TimeUnit.SECONDS);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a><strong>并发与并行</strong></h6><p>正在运行的程序（软件）就是一个独立的进程， 线程是属于进程的，多个线程其实是并发与并行同时进行的。</p><p><strong>并发的理解：</strong></p><ul><li><p>CPU同时处理线程的数量有限。</p></li><li><p>CPU会轮询为系统的每个线程服务，由于CPU切换的速度很快，给我们的感觉这些线程在同时执行，这就是并发。</p></li></ul><p><strong>并行的理解：</strong></p><ul><li>在同一个时刻上，同时有多个线程在被CPU处理并执行。</li></ul><h6 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a><strong>线程的状态</strong></h6><ul><li><p>线程的状态：也就是线程从生到死的过程，以及中间经历的各种状态及状态转换。</p></li><li><p>理解线程的状态有利于提升并发编程的理解能力。</p></li></ul><table><thead><tr><th>NEW(新建)</th><th>解释</th></tr></thead><tbody><tr><td>NEW(新建)</td><td>线程刚被创建，但是并未启动。</td></tr><tr><td>Runnable(可运行)</td><td>线程已经调用了start()等待CPU调度</td></tr><tr><td>Blocked(锁阻塞)</td><td>线程在执行的时候未竞争到锁对象，则该线程进入Blocked状态；。</td></tr><tr><td>Waiting(无限等待)</td><td>一个线程进入Waiting状态，另一个线程调用notify或者notifyAll方法才能够唤醒</td></tr><tr><td>Timed Waiting(计时等待)</td><td>同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。带有超时参数的常用方法有Thread.sleep 、Object.wait。</td></tr><tr><td>Teminated(被终止)</td><td>因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。</td></tr></tbody></table><h4 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h4><p>常见的通信模式有如下2种形式：Client-Server(CS) 、Browser/Server(BS)</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220429174326693.png" alt="image-20220429174326693"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220429174340243.png" alt="image-20220429174340243"></p><h6 id="实现网络编程关键的三要素"><a href="#实现网络编程关键的三要素" class="headerlink" title="实现网络编程关键的三要素"></a><strong>实现网络编程关键的三要素</strong></h6><p><strong>IP地址</strong>：设备在网络中的地址，是唯一的标识。</p><p><strong>端口：</strong>应用程序在设备中唯一的标识。</p><p><strong>协议</strong>:  数据在网络中传输的规则，常见的协议有UDP协议和TCP协议。</p><p><strong>IP地址</strong></p><p>IPv6：128位（16个字节），号称可以为地球每一粒沙子编号。</p><p>IPv6分成8个整数，每个整数用四个十六进制位表示， 数之间用冒号（：）分开。</p><p><strong>IP地址形式：</strong></p><p>公网地址、和私有地址(局域网使用)。</p><p>192.168. 开头的就是常见的局域网地址，范围即为192.168.0.0–192.168.255.255，专门为组织机构内部使用。 </p><p><strong>IP常用命令：</strong></p><p>ipconfig：查看本机IP地址</p><p>ping IP地址：检查网络是否连通</p><p><strong>特殊IP地址</strong>：</p><p>本机IP: 127.0.0.1或者localhost：称为回送地址也可称本地回环地址，只会寻找当前所在本机。</p><h6 id="InetAddress-的使用"><a href="#InetAddress-的使用" class="headerlink" title="InetAddress 的使用"></a><strong>InetAddress</strong> <strong>的使用</strong></h6><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>public static <a href="mk:@MSITStore:D:\course\jdk-11中文api修订版.CHM::/java.base/java/net/InetAddress.html">InetAddress</a> getLocalHost()</td><td>返回本主机的地址对象</td></tr><tr><td>public static  InetAddress getByName(String host)</td><td>得到指定主机的IP地址对象，参数是域名或者IP地址</td></tr><tr><td>public String  getHostName()</td><td>获取此IP地址的主机名</td></tr><tr><td>public String  getHostAddress()</td><td>返回IP地址字符串</td></tr><tr><td>public boolean isReachable(int timeout)</td><td>在指定毫秒内连通该IP地址对应的主机，连通返回true</td></tr></tbody></table><h6 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a><strong>端口号</strong></h6><p>l端口号：标识正在计算机设备上运行的进程（程序），被规定为一个 16 位的二进制，范围是 0~65535。</p><p><strong>端口类型</strong></p><p>周知端口：0~1023，被预先定义的知名应用占用（如：HTTP占用 80，FTP占用21） </p><p><strong>注册端口</strong>：1024~49151，分配给用户进程或某些应用程序。（如：Tomcat占 用8080，MySQL占用3306）</p><p>动态端口：49152到65535，之所以称为动态端口，是因为它 一般不固定分配某种进程，而是动态分配。</p><p><strong>注意：我们自己开发的程序选择注册端口，且一个设备中不能出现两个程序的端口号一样，否则出错。</strong></p><h6 id="网络通信协议有两套参考模型"><a href="#网络通信协议有两套参考模型" class="headerlink" title="网络通信协议有两套参考模型"></a><strong>网络通信协议有两套参考模型</strong></h6><ul><li><p>OSI参考模型：世界互联协议标准，全球通信规范，由于此模型过于理想化，未能在因特网上进行广泛推广。</p></li><li><p>TCP/IP参考模型(或TCP/IP协议)：事实上的国际标准。</p></li></ul><table><thead><tr><th>OSI参考模型</th><th>TCP/IP参考模型</th><th>各层对应</th><th>面向操作</th></tr></thead><tbody><tr><td>应用层</td><td>应用层</td><td>HTTP、FTP、DNS、SMTP…</td><td>应用程序需要关注的：浏览器，邮箱。程序员一般在这一层开发</td></tr><tr><td>表示层</td><td></td><td></td><td></td></tr><tr><td>会话层</td><td></td><td></td><td></td></tr><tr><td>传输层</td><td>传输层</td><td>TCP、UDP…</td><td>选择使用的TCP , UDP协议</td></tr><tr><td>网络层</td><td>网络层</td><td>IP、ICMP…</td><td>封装源和目标IP，进行路径选择</td></tr><tr><td>数据链路层</td><td>数据链路层+物理</td><td>物理寻址、比特流…</td><td>物理设备中传输</td></tr><tr><td>物理层</td><td></td><td></td><td></td></tr></tbody></table><p><strong>TCP协议特点</strong></p><ul><li><p>使用TCP协议，必须双方先建立连接，它是一种面向连接的可靠通信协议。</p></li><li><p>传输前，采用“三次握手”方式建立连接，所以是可靠的 。</p></li><li><p>在连接中可进行大数据量的传输 。</p></li><li><p>连接、发送数据都需要确认，且传输完毕后，还需释放已建立的连接，通信效率较低。 </p></li></ul><p><strong>TCP协议通信场景</strong></p><ul><li>对信息安全要求较高的场景，例如：文件下载、金融等数据通信。</li></ul><p><strong>UDP协议：</strong> </p><ul><li><p>UDP是一种无连接、不可靠传输的协议。</p></li><li><p>将数据源IP、目的地IP和端口封装成数据包，不需要建立连接</p></li><li><p>每个数据包的大小限制在64KB内</p></li><li><p>发送不管对方是否准备好，接收方收到也不确认，故是不可靠的 </p></li><li><p>可以广播发送 ，发送数据结束时无需释放资源，开销小，速度快。</p></li></ul><p><strong>UDP协议通信场景</strong></p><ul><li>语音通话，视频会话等。</li></ul><h6 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h6><p><strong>DatagramPacket：数据包对象（韭菜盘子）</strong></p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public DatagramPacket(byte[] buf, int  length, InetAddress address,  int port)</td><td>创建发送端数据包对象  buf：要发送的内容，字节数组  length：要发送内容的字节长度  address：接收端的IP地址对象  port：接收端的端口号</td></tr><tr><td>public DatagramPacket(byte[] buf, int  length)</td><td>创建接收端的数据包对象  buf：用来存储接收的内容  length：能够接收内容的长度</td></tr></tbody></table><p><strong>DatagramSocket类成员方法</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public void send(DatagramPacket dp)</td><td>发送数据包</td></tr><tr><td>public void receive(DatagramPacket p)</td><td>接收数据包</td></tr></tbody></table><p>需求：客户端实现步骤</p><p>①创建DatagramSocket对象（发送端对象）           扔韭菜的人</p><p>②创建DatagramPacket对象封装需要发送的数据（数据包对象）        韭菜盘子</p><p>③使用DatagramSocket对象的send方法传入DatagramPacket对象         开始抛出韭菜</p><p>④释放资源</p><p>需求：接收端实现步骤</p><p>①创建DatagramSocket对象并指定端口（接收端对象）           接韭菜的人</p><p>②创建DatagramPacket对象接收数据（数据包对象）         韭菜盘子</p><p>③使用DatagramSocket对象的receive方法传入DatagramPacket对象         开始接收韭菜</p><p>④释放资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  发送端  一发 一收</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;=====客户端启动======&quot;</span>);<br><br>        <span class="hljs-comment">// 1、创建发送端对象：发送端自带默认的端口号（人）</span><br>        <span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(<span class="hljs-number">6666</span>);<br><br>        <span class="hljs-comment">// 2、创建一个数据包对象封装数据（韭菜盘子）</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         public DatagramPacket(byte buf[], int length,</span><br><span class="hljs-comment">         InetAddress address, int port)</span><br><span class="hljs-comment">         参数一：封装要发送的数据（韭菜）</span><br><span class="hljs-comment">         参数二：发送数据的大小</span><br><span class="hljs-comment">         参数三：服务端的主机IP地址</span><br><span class="hljs-comment">         参数四：服务端的端口</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-string">&quot;我是一颗快乐的韭菜，你愿意吃吗？&quot;</span>.getBytes();<br>        <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>( buffer, buffer.length,<br>                InetAddress.getLocalHost() , <span class="hljs-number">8888</span>);<br><br>        <span class="hljs-comment">// 3、发送数据出去</span><br>        socket.send(packet);<br><br>        socket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  接收端</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;=====服务端启动======&quot;</span>);<br>        <span class="hljs-comment">// 1、创建接收端对象：注册端口（人）</span><br>        <span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(<span class="hljs-number">8888</span>);<br><br>        <span class="hljs-comment">// 2、创建一个数据包对象接收数据（韭菜盘子）</span><br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">64</span>];<br>        <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buffer, buffer.length);<br><br>        <span class="hljs-comment">// 3、等待接收数据。</span><br>        socket.receive(packet);<br><br>        <span class="hljs-comment">// 4、取出数据即可</span><br>        <span class="hljs-comment">// 读取多少倒出多少</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> packet.getLength();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer,<span class="hljs-number">0</span>, len);<br>        System.out.println(<span class="hljs-string">&quot;收到了：&quot;</span> + rs);<br><br>        <span class="hljs-comment">// 获取发送端的ip和端口</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">ip</span>  <span class="hljs-operator">=</span>packet.getSocketAddress().toString();<br>        System.out.println(<span class="hljs-string">&quot;对方地址：&quot;</span> + ip);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">port</span>  <span class="hljs-operator">=</span> packet.getPort();<br>        System.out.println(<span class="hljs-string">&quot;对方端口：&quot;</span> + port);<br><br>        socket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="UDP的三种通信方式"><a href="#UDP的三种通信方式" class="headerlink" title="UDP的三种通信方式"></a><strong>UDP的三种通信方式</strong></h6><p>单播：单台主机与单台主机之间的通信。</p><p>广播：当前主机与所在网络中的所有主机通信。</p><p>组播：当前主机与选定的一组主机的通信。</p><h6 id="UDP如何实现广播"><a href="#UDP如何实现广播" class="headerlink" title="UDP如何实现广播"></a><strong>UDP如何实现广播</strong></h6><p>使用广播地址：255.255.255.255</p><p>具体操作：</p><p>①发送端发送的数据包的目的地写的是广播地址、且指定端口。 （255.255.255.255 ,  9999）</p><p>②本机所在网段的其他主机的程序只要注册对应端口就可以收到消息了。（9999）</p><h6 id="UDP如何实现组播"><a href="#UDP如何实现组播" class="headerlink" title="UDP如何实现组播"></a><strong>UDP如何实现组播</strong></h6><p>使用组播地址：224.0.0.0 ~ 239.255.255.255</p><p>具体操作：</p><p>①发送端的数据包的目的地是组播IP (例如：224.0.1.1, 端口：9999)</p><p>②接收端必须绑定该组播IP(224.0.1.1)，端口还要注册发送端的目的端口9999 ，这样即可接收该组播消息。</p><p>③DatagramSocket的子类MulticastSocket可以在接收端绑定组播IP。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">            <span class="hljs-comment">// 2、创建一个数据包对象封装数据（韭菜盘子）</span><br>            <span class="hljs-type">byte</span>[] buffer = msg.getBytes();<br>            <span class="hljs-comment">// 注意：只要目的地IP是 255.255.255.255 这个消息将以广播的形式对外发送</span><br><span class="hljs-comment">//            DatagramPacket packet = new DatagramPacket( buffer, buffer.length,</span><br><span class="hljs-comment">//                    InetAddress.getByName(&quot;255.255.255.255&quot;) , 8888);</span><br><br>            <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>( buffer, buffer.length,<br>                    InetAddress.getByName(<span class="hljs-string">&quot;224.0.1.1&quot;</span>) , <span class="hljs-number">9898</span>);<br><br>                    <span class="hljs-comment">// 3、发送数据出去</span><br>            socket.send(packet);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  接收端,广播</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;=====服务端启动======&quot;</span>);<br>        <span class="hljs-comment">// 1、创建接收端对象：注册端口（人）</span><br>        <span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(<span class="hljs-number">8888</span>);<br><br>        <span class="hljs-comment">// 2、创建一个数据包对象接收数据（韭菜盘子）</span><br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">64</span>];<br>        <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buffer, buffer.length);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 3、等待接收数据。</span><br>            socket.receive(packet);<br>            <span class="hljs-comment">// 4、取出数据即可</span><br>            <span class="hljs-comment">// 读取多少倒出多少</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> packet.getLength();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer,<span class="hljs-number">0</span>, len);<br>            System.out.println(<span class="hljs-string">&quot;收到了来自：&quot;</span> + packet.getAddress() +<span class="hljs-string">&quot;, 对方端口是&quot;</span> + packet.getPort() +<span class="hljs-string">&quot;的消息：&quot;</span> + rs);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  接收端，组播</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerDemo3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;=====服务端启动======&quot;</span>);<br>        <span class="hljs-comment">// 1、创建接收端对象：注册端口（人）</span><br>        <span class="hljs-type">MulticastSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MulticastSocket</span>(<span class="hljs-number">9898</span>);<br><br>        <span class="hljs-comment">// 注意：绑定组播地址（加群）</span><br>        socket.joinGroup(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(InetAddress.getByName(<span class="hljs-string">&quot;224.0.1.1&quot;</span>) , <span class="hljs-number">9898</span>),<br>                NetworkInterface.getByInetAddress(InetAddress.getLocalHost()));<br><br>        <span class="hljs-comment">// 2、创建一个数据包对象接收数据（韭菜盘子）</span><br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">64</span>];<br>        <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buffer, buffer.length);<br><br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 3、等待接收数据。</span><br>            socket.receive(packet);<br>            <span class="hljs-comment">// 4、取出数据即可</span><br>            <span class="hljs-comment">// 读取多少倒出多少</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> packet.getLength();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer,<span class="hljs-number">0</span>, len);<br>            System.out.println(<span class="hljs-string">&quot;收到了来自：&quot;</span> + packet.getAddress() +<span class="hljs-string">&quot;, 对方端口是&quot;</span> + packet.getPort() +<span class="hljs-string">&quot;的消息：&quot;</span> + rs);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h6><ul><li><p>TCP是一种面向连接，安全、可靠的传输数据的协议 </p></li><li><p>传输前，采用“三次握手”方式，点对点通信，是可靠的 </p></li><li><p>在连接中可进行大数据量的传输 </p></li></ul><h6 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a><strong>Socket</strong></h6><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public Socket(String host , int port)</td><td>创建发送端的Socket对象与服务端连接，参数为服务端程序的ip和端口。</td></tr></tbody></table><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>OutputStream getOutputStream()</td><td>获得字节输出流对象</td></tr><tr><td>InputStream getInputStream()</td><td>获得字节输入流对象</td></tr></tbody></table><h6 id="客户端发送消息"><a href="#客户端发送消息" class="headerlink" title="客户端发送消息"></a>客户端发送消息</h6><p>需求：客户端实现步骤</p><p>①创建客户端的Socket对象，请求与服务端的连接。</p><p>②使用socket对象调用getOutputStream()方法得到字节输出流。</p><p>③使用字节输出流完成数据的发送。</p><p>④释放资源：关闭socket管道。</p><p><strong>ServerSocket(服务端)</strong></p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public ServerSocket(int port)</td><td>注册服务端端口</td></tr></tbody></table><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public Socket accept()</td><td>等待接收客户端的Socket通信连接  连接成功返回Socket对象与客户端建立端到端通信</td></tr></tbody></table><h6 id="服务端实现接收消息"><a href="#服务端实现接收消息" class="headerlink" title="服务端实现接收消息"></a>服务端实现接收消息</h6><p>需求：服务端实现步骤</p><p>①创建ServerSocket对象，注册服务端端口。</p><p>②调用ServerSocket对象的accept()方法，等待客户端的连接，并得到Socket管道对象。</p><p>③通过Socket对象调用getInputStream()方法得到字节输入流、完成数据的接收。</p><p>④释放资源：关闭socket管道</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   目标：完成Socket网络编程入门案例的客户端开发，实现1发1收。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;====客户端启动===&quot;</span>);<br>            <span class="hljs-comment">// 1、创建Socket通信管道请求有服务端的连接</span><br>            <span class="hljs-comment">// public Socket(String host, int port)</span><br>            <span class="hljs-comment">// 参数一：服务端的IP地址</span><br>            <span class="hljs-comment">// 参数二：服务端的端口</span><br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">7777</span>);<br><br>            <span class="hljs-comment">// 2、从socket通信管道中得到一个字节输出流 负责发送数据</span><br>            <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br><br>            <span class="hljs-comment">// 3、把低级的字节流包装成打印流</span><br>            <span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(os);<br><br>            <span class="hljs-comment">// 4、发送消息</span><br>            ps.println(<span class="hljs-string">&quot;我是TCP的客户端，我已经与你对接，并发出邀请：约吗？&quot;</span>);<br>            ps.flush();<br><br>            <span class="hljs-comment">// 关闭资源。</span><br>            <span class="hljs-comment">// socket.close();</span><br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   目标：开发Socket网络编程入门代码的服务端，实现接收消息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;===服务端启动成功===&quot;</span>);<br>            <span class="hljs-comment">// 1、注册端口</span><br>            <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">7777</span>);<br>            <span class="hljs-comment">// 2、必须调用accept方法：等待接收客户端的Socket连接请求，建立Socket通信管道</span><br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>            <span class="hljs-comment">// 3、从socket通信管道中得到一个字节输入流</span><br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>            <span class="hljs-comment">// 4、把字节输入流包装成缓冲字符输入流进行消息的接收</span><br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(is));<br>            <span class="hljs-comment">// 5、按照行读取消息</span><br>            String msg;<br>            <span class="hljs-keyword">if</span> ((msg = br.readLine()) != <span class="hljs-literal">null</span>)&#123;<br>                System.out.println(socket.getRemoteSocketAddress() + <span class="hljs-string">&quot;说了：: &quot;</span> + msg);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>1.TCP通信服务端用的代表类？</p><p><strong>ServerSocket类,注册端口。</strong></p><p><strong>调用accept()方法阻塞等待接收客户端连接。得到Socket对象。</strong></p><p>2.TCP通信的基本原理？</p><p><strong>客户端怎么发，服务端就应该怎么收。</strong></p><p><strong>客户端如果没有消息，服务端会进入阻塞等待。</strong></p><p><strong>Socket一方关闭或者出现异常、对方Socket也会失效或者出错。</strong></p><p>1、之前我们的通信是否可以同时与多个客户端通信，为什么？</p><p><strong>不可以的</strong></p><p><strong>单线程每次只能处理一个客户端的Socket通信</strong></p><p>2、如何才可以让服务端可以处理多个客户端的通信需求？</p><p><strong>引入多线程。</strong></p><h6 id="多发多收"><a href="#多发多收" class="headerlink" title="多发多收"></a>多发多收</h6><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220429203603902.png" alt="image-20220429203603902"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：实现服务端可以同时处理多个客户端的消息。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;====客户端启动===&quot;</span>);<br>            <span class="hljs-comment">// 1、创建Socket通信管道请求有服务端的连接</span><br>            <span class="hljs-comment">// public Socket(String host, int port)</span><br>            <span class="hljs-comment">// 参数一：服务端的IP地址</span><br>            <span class="hljs-comment">// 参数二：服务端的端口</span><br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">7777</span>);<br><br>            <span class="hljs-comment">// 2、从socket通信管道中得到一个字节输出流 负责发送数据</span><br>            <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br><br>            <span class="hljs-comment">// 3、把低级的字节流包装成打印流</span><br>            <span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(os);<br><br>            <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;请说：&quot;</span>);<br>                <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> sc.nextLine();<br>                <span class="hljs-comment">// 4、发送消息</span><br>                ps.println(msg);<br>                ps.flush();<br>            &#125;<br><br>            <span class="hljs-comment">// 关闭资源。</span><br>            <span class="hljs-comment">// socket.close();</span><br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   目标：实现服务端可以同时处理多个客户端的消息。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;===服务端启动成功===&quot;</span>);<br>            <span class="hljs-comment">// 1、注册端口</span><br>            <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">7777</span>);<br>            <span class="hljs-comment">// a.定义一个死循环由主线程负责不断的接收客户端的Socket管道连接。</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-comment">// 2、每接收到一个客户端的Socket管道，交给一个独立的子线程负责读取消息</span><br>                <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>                System.out.println(socket.getRemoteSocketAddress()+ <span class="hljs-string">&quot;它来了，上线了！&quot;</span>);<br>                <span class="hljs-comment">// 3、开始创建独立线程处理socket</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerReaderThread</span>(socket).start();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerReaderThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> Socket socket;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ServerReaderThread</span><span class="hljs-params">(Socket socket)</span>&#123;<br>        <span class="hljs-built_in">this</span>.socket = socket;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 3、从socket通信管道中得到一个字节输入流</span><br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>            <span class="hljs-comment">// 4、把字节输入流包装成缓冲字符输入流进行消息的接收</span><br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(is));<br>            <span class="hljs-comment">// 5、按照行读取消息</span><br>            String msg;<br>            <span class="hljs-keyword">while</span> ((msg = br.readLine()) != <span class="hljs-literal">null</span>)&#123;<br>                System.out.println(socket.getRemoteSocketAddress() + <span class="hljs-string">&quot;说了：: &quot;</span> + msg);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(socket.getRemoteSocketAddress() + <span class="hljs-string">&quot;下线了！！！&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="引入线程池"><a href="#引入线程池" class="headerlink" title="引入线程池"></a>引入线程池</h6><p>解决N:N资源耗尽问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    拓展：使用线程池优化：实现通信。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;====客户端启动===&quot;</span>);<br>            <span class="hljs-comment">// 1、创建Socket通信管道请求有服务端的连接</span><br>            <span class="hljs-comment">// public Socket(String host, int port)</span><br>            <span class="hljs-comment">// 参数一：服务端的IP地址</span><br>            <span class="hljs-comment">// 参数二：服务端的端口</span><br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6666</span>);<br><br>            <span class="hljs-comment">// 2、从socket通信管道中得到一个字节输出流 负责发送数据</span><br>            <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br><br>            <span class="hljs-comment">// 3、把低级的字节流包装成打印流</span><br>            <span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(os);<br><br>            <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;请说：&quot;</span>);<br>                <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> sc.nextLine();<br>                <span class="hljs-comment">// 4、发送消息</span><br>                ps.println(msg);<br>                ps.flush();<br>            &#125;<br>            <span class="hljs-comment">// 关闭资源。</span><br>            <span class="hljs-comment">// socket.close();</span><br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   目标：实现服务端可以同时处理多个客户端的消息。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerDemo2</span> &#123;<br><br>    <span class="hljs-comment">// 使用静态变量记住一个线程池对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">300</span>,<br>            <span class="hljs-number">1500</span>, <span class="hljs-number">6</span>, TimeUnit.SECONDS,<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">2</span>)<br>    , Executors.defaultThreadFactory(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy());<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;===服务端启动成功===&quot;</span>);<br>            <span class="hljs-comment">// 1、注册端口</span><br>            <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">6666</span>);<br>            <span class="hljs-comment">// a.定义一个死循环由主线程负责不断的接收客户端的Socket管道连接。</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-comment">// 2、每接收到一个客户端的Socket管道，</span><br>                <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>                System.out.println(socket.getRemoteSocketAddress()+ <span class="hljs-string">&quot;它来了，上线了！&quot;</span>);<br><br>                <span class="hljs-comment">// 任务对象负责读取消息。</span><br>                <span class="hljs-type">Runnable</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerReaderRunnable</span>(socket);<br>                pool.execute(target);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerReaderRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">private</span> Socket socket;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ServerReaderRunnable</span><span class="hljs-params">(Socket socket)</span>&#123;<br>        <span class="hljs-built_in">this</span>.socket = socket;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 3、从socket通信管道中得到一个字节输入流</span><br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>            <span class="hljs-comment">// 4、把字节输入流包装成缓冲字符输入流进行消息的接收</span><br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(is));<br>            <span class="hljs-comment">// 5、按照行读取消息</span><br>            String msg;<br>            <span class="hljs-keyword">while</span> ((msg = br.readLine()) != <span class="hljs-literal">null</span>)&#123;<br>                System.out.println(socket.getRemoteSocketAddress() + <span class="hljs-string">&quot;说了：: &quot;</span> + msg);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(socket.getRemoteSocketAddress() + <span class="hljs-string">&quot;下线了！！！&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="即时通信"><a href="#即时通信" class="headerlink" title="即时通信"></a>即时通信</h6><p><strong>即时通信，是指一个客户端的消息发出去，其他客户端可以接收到。</strong></p><p><strong>之前我们的消息都是发给服务端的。</strong></p><p><strong>即时通信需要进行端口转发的设计思想。</strong></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220430093310743.png" alt="image-20220430093310743"></p><p>1.即时通信是什么含义，要实现怎么样的设计？</p><p><strong>即时通信，是指一个客户端的消息发出去，其他客户端可以接收到</strong></p><p><strong>即时通信需要进行端口转发的设计思想。</strong></p><p><strong>服务端需要把在线的Socket管道存储起来</strong></p><p><strong>一旦收到一个消息要推送给其他管道</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    拓展：即时通信</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    客户端：发消息的同时，随时有人发消息过来。</span><br><span class="hljs-comment">    服务端：接收消息后，推送给其他所有的在线socket</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;====客户端启动===&quot;</span>);<br>            <span class="hljs-comment">// 1、创建Socket通信管道请求有服务端的连接</span><br>            <span class="hljs-comment">// public Socket(String host, int port)</span><br>            <span class="hljs-comment">// 参数一：服务端的IP地址</span><br>            <span class="hljs-comment">// 参数二：服务端的端口</span><br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6868</span>);<br><br>            <span class="hljs-comment">// 马上为客户端分配一个独立的线程负责读取它收到的消息</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientReaderThread</span>(socket).start();<br><br>            <span class="hljs-comment">// 2、从socket通信管道中得到一个字节输出流 负责发送数据</span><br>            <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br><br>            <span class="hljs-comment">// 3、把低级的字节流包装成打印流</span><br>            <span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(os);<br><br>            <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;请说：&quot;</span>);<br>                <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> sc.nextLine();<br>                <span class="hljs-comment">// 4、发送消息</span><br>                ps.println(msg);<br>                ps.flush();<br>            &#125;<br>            <span class="hljs-comment">// 关闭资源。</span><br>            <span class="hljs-comment">// socket.close();</span><br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientReaderThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> Socket socket;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ClientReaderThread</span><span class="hljs-params">(Socket socket)</span>&#123;<br>        <span class="hljs-built_in">this</span>.socket = socket;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 3、从socket通信管道中得到一个字节输入流</span><br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>            <span class="hljs-comment">// 4、把字节输入流包装成缓冲字符输入流进行消息的接收</span><br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(is));<br>            <span class="hljs-comment">// 5、按照行读取消息</span><br>            String msg;<br>            <span class="hljs-keyword">while</span> ((msg = br.readLine()) != <span class="hljs-literal">null</span>)&#123;<br>                System.out.println(socket.getRemoteSocketAddress() + <span class="hljs-string">&quot;收到了: &quot;</span> + msg);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;服务端把你踢出去了~~&quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   目标: 即时通信</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerDemo2</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Socket&gt; onLineSockets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;===服务端启动成功===&quot;</span>);<br>            <span class="hljs-comment">// 1、注册端口</span><br>            <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">6868</span>);<br>            <span class="hljs-comment">// a.定义一个死循环由主线程负责不断的接收客户端的Socket管道连接。</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-comment">// 2、每接收到一个客户端的Socket管道，交给一个独立的子线程负责读取消息</span><br>                <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>                System.out.println(socket.getRemoteSocketAddress()+ <span class="hljs-string">&quot;它来了，上线了！&quot;</span>);<br>                <span class="hljs-comment">// 把当前客户端管道Socket加入到在线集合中去</span><br>                onLineSockets.add(socket);<br><br>                <span class="hljs-comment">// 3、开始创建独立线程处理socket</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerReaderThread</span>(socket).start();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerReaderThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> Socket socket;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ServerReaderThread</span><span class="hljs-params">(Socket socket)</span>&#123;<br>        <span class="hljs-built_in">this</span>.socket = socket;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 3、从socket通信管道中得到一个字节输入流</span><br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>            <span class="hljs-comment">// 4、把字节输入流包装成缓冲字符输入流进行消息的接收</span><br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(is));<br>            <span class="hljs-comment">// 5、按照行读取消息</span><br>            String msg;<br>            <span class="hljs-keyword">while</span> ((msg = br.readLine()) != <span class="hljs-literal">null</span>)&#123;<br>                System.out.println(socket.getRemoteSocketAddress() + <span class="hljs-string">&quot;说了：: &quot;</span> + msg);<br>                <span class="hljs-comment">// 把这个消息发给当前所有在线socket</span><br>                sendMsgToAll(msg);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(socket.getRemoteSocketAddress() + <span class="hljs-string">&quot;下线了！！！&quot;</span>);<br>            <span class="hljs-comment">// 从在线集合中抹掉本客户端socket</span><br>            ServerDemo2.onLineSockets.remove(socket);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMsgToAll</span><span class="hljs-params">(String msg)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 遍历全部的在线 socket给他们发消息</span><br>            <span class="hljs-keyword">for</span> (Socket onLineSocket : ServerDemo2.onLineSockets) &#123;<br>                <span class="hljs-comment">// 除了自己的socket，其他socket我都发！！</span><br>                <span class="hljs-keyword">if</span>(onLineSocket != socket)&#123;<br>                    <span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(socket.getOutputStream());<br>                    ps.println(msg);<br>                    ps.flush();<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="BS开发"><a href="#BS开发" class="headerlink" title="BS开发"></a>BS开发</h6><p><strong>HTTP响应数据的协议格式：就是给浏览器显示的网页信息</strong></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220430094241610.png" alt="image-20220430094241610"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerReaderRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">private</span> Socket socket;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ServerReaderRunnable</span><span class="hljs-params">(Socket socket)</span>&#123;<br>        <span class="hljs-built_in">this</span>.socket = socket;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 浏览器 已经与本线程建立了Socket管道</span><br>            <span class="hljs-comment">// 响应消息给浏览器显示</span><br>            <span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(socket.getOutputStream());<br>            <span class="hljs-comment">// 必须响应HTTP协议格式数据，否则浏览器不认识消息</span><br>            ps.println(<span class="hljs-string">&quot;HTTP/1.1 200 OK&quot;</span>); <span class="hljs-comment">// 协议类型和版本 响应成功的消息！</span><br>            ps.println(<span class="hljs-string">&quot;Content-Type:text/html;charset=UTF-8&quot;</span>); <span class="hljs-comment">// 响应的数据类型：文本/网页</span><br><br>            ps.println(); <span class="hljs-comment">// 必须发送一个空行</span><br><br>            <span class="hljs-comment">// 才可以响应数据回去给浏览器</span><br>            ps.println(<span class="hljs-string">&quot;&lt;span style=&#x27;color:red;font-size:90px&#x27;&gt;《最牛的149期》 &lt;/span&gt;&quot;</span>);<br>            ps.close();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(socket.getRemoteSocketAddress() + <span class="hljs-string">&quot;下线了！！！&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java">**<br>    了解：BS-浏览器-服务器基本了解。<br><br>    引入：<br>        之前客户端和服务端都需要自己开发。也就是CS架构。<br>        接下来模拟一下BS架构。<br><br>    客户端：浏览器。（无需开发）<br>    服务端：自己开发。<br>    需求：在浏览器中请求本程序，响应一个网页文字给浏览器显示<br><br><br> */<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BSserverDemo</span> &#123;<br>    <span class="hljs-comment">// 使用静态变量记住一个线程池对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">3</span>,<br>            <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, TimeUnit.SECONDS,<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">2</span>)<br>            , Executors.defaultThreadFactory(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy());<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 1.注册端口</span><br>            <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">ss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8080</span>);<br>            <span class="hljs-comment">// 2.创建一个循环接收多个客户端的请求。</span><br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> ss.accept();<br>                <span class="hljs-comment">// 3.交给一个独立的线程来处理！</span><br>                pool.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerReaderRunnable</span>(socket));<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="单元测试、反射、注解、动态管理"><a href="#单元测试、反射、注解、动态管理" class="headerlink" title="单元测试、反射、注解、动态管理"></a>单元测试、反射、注解、动态管理</h4><h5 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h5><ul><li>单元测试就是针对最小的功能单元编写测试代码，Java程序最小的功能单元是方法，因此，单元测试就是针对Java方法的测试，进而检查方法的正确性。</li></ul><p><strong>目前测试方法是怎么进行的，存在什么问题</strong></p><ul><li><p>只有一个main方法，如果一个方法的测试失败了，其他方法测试会受到影响。</p></li><li><p>无法得到测试的结果报告，需要程序员自己去观察测试是否成功。</p></li><li><p>无法实现自动化测试。</p></li></ul><h6 id="Junit单元测试框架"><a href="#Junit单元测试框架" class="headerlink" title="Junit单元测试框架"></a><strong>Junit单元测试框架</strong></h6><ul><li><p>JUnit是使用Java语言实现的单元测试框架，它是开源的，Java开发者都应当学习并使用JUnit编写单元测试。</p></li><li><p>此外，几乎所有的IDE工具都集成了JUnit，这样我们就可以直接在IDE中编写并运行JUnit测试，JUnit目前最新版本是5。</p></li></ul><p><strong>JUnit优点</strong></p><ul><li><p>JUnit可以灵活的选择执行哪些测试方法，可以一键执行全部测试方法。</p></li><li><p>Junit可以生成全部方法的测试报告。</p></li><li><p>单元测试中的某个方法测试失败了，不会影响其他测试方法的测试。</p></li></ul><h6 id="单元测试快速入门"><a href="#单元测试快速入门" class="headerlink" title="单元测试快速入门"></a>单元测试快速入门</h6><p>需求：使用单元测试进行业务方法预期结果、正确性测试的快速入门</p><p>分析：</p><p>①将JUnit的jar包导入到项目中</p><p>​        IDEA通常整合好了Junit框架，一般不需要导入。</p><p>​        如果IDEA没有整合好，需要自己手工导入如下2个JUnit的jar包        到模块</p><p>②编写测试方法：该测试方法必须是公共的无参数无返回值的非静态方法。</p><p>③在测试方法上使用@Test注解：标注该方法是一个测试方法</p><p>④在测试方法中完成被测试方法的预期正确性测试。</p><p>⑤选中测试方法，选择“JUnit运行” ，如果测试良好则是绿色；如果测试失败，则是红色</p><p><strong>Junit常用注解(Junit 4.xxxx版本)</strong></p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Test</td><td>测试方法</td></tr><tr><td>@Before</td><td>用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。</td></tr><tr><td>@After</td><td>用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次。</td></tr><tr><td>@BeforeClass</td><td>用来静态修饰方法，该方法会在所有测试方法之前只执行一次。</td></tr><tr><td>@AfterClass</td><td>用来静态修饰方法，该方法会在所有测试方法之后只执行一次。</td></tr></tbody></table><p><strong>Junit常用注解(Junit 5.xxxx版本)</strong></p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Test</td><td>测试方法</td></tr><tr><td>@BeforeEach</td><td>用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。</td></tr><tr><td>@AfterEach</td><td>用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次。</td></tr><tr><td>@BeforeAll</td><td>用来静态修饰方法，该方法会在所有测试方法之前只执行一次。</td></tr><tr><td>@AfterAll</td><td>用来静态修饰方法，该方法会在所有测试方法之后只执行一次。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   业务方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">loginName</span><span class="hljs-params">(String loginName , String passWord)</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;admin&quot;</span>.equals(loginName) &amp;&amp; <span class="hljs-string">&quot;123456&quot;</span>.equals(passWord))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;登录成功&quot;</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;用户名或者密码有问题&quot;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectNames</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-number">10</span>/<span class="hljs-number">2</span>);<br>        System.out.println(<span class="hljs-string">&quot;查询全部用户名称成功~~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   测试类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestUserService</span> &#123;<br><br>    <span class="hljs-comment">// 修饰实例方法的</span><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;===before方法执行一次===&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@After</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;===after方法执行一次===&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 修饰静态方法</span><br>    <span class="hljs-meta">@BeforeClass</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeClass</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;===beforeClass方法执行一次===&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@AfterClass</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterClass</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;===afterClass方法执行一次===&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">       测试方法</span><br><span class="hljs-comment">       注意点：</span><br><span class="hljs-comment">            1、必须是公开的，无参数 无返回值的方法</span><br><span class="hljs-comment">            2、测试方法必须使用<span class="hljs-doctag">@Test</span>注解标记。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testLoginName</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserService</span>();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> userService.loginName(<span class="hljs-string">&quot;admin&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>);<br><br>        <span class="hljs-comment">// 进行预期结果的正确性测试：断言。</span><br>        Assert.assertEquals(<span class="hljs-string">&quot;您的登录业务可能出现问题&quot;</span>, <span class="hljs-string">&quot;登录成功&quot;</span>, rs );<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectNames</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserService</span>();<br>        userService.selectNames();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h5><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220430164907424.png" alt="image-20220430164907424"></p><h6 id="反射概述"><a href="#反射概述" class="headerlink" title="反射概述"></a><strong>反射概述</strong></h6><ul><li><p>反射是指对于任何一个Class类，在”运行的时候”都可以直接得到这个类全部成分。</p></li><li><p>在运行时,可以直接得到这个类的构造器对象：Constructor</p></li><li><p>在运行时,可以直接得到这个类的成员变量对象：Field</p></li><li><p>在运行时,可以直接得到这个类的成员方法对象：Method</p></li><li><p>这种运行时动态获取类信息以及动态调用类中成分的能力称为Java语言的反射机制。</p></li></ul><h6 id="反射的关键："><a href="#反射的关键：" class="headerlink" title="反射的关键："></a><strong>反射的关键：</strong></h6><ul><li>反射的第一步都是先得到编译后的Class类对象，然后就可以得到Class的全部成分。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">HelloWorld.java -&gt; javac -&gt; HelloWorld.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">Class</span> c = HelloWorld.class;<br></code></pre></td></tr></table></figure><h6 id="获取类的对象"><a href="#获取类的对象" class="headerlink" title="获取类的对象"></a><strong>获取类的对象</strong></h6><p><strong>方式一：Class c1 =</strong> <strong>Class.forName(“全类名”);</strong></p><p><strong>方式二：Class c2 =</strong> <strong>类名.class</strong></p><p><strong>方式三：Class c3 =</strong> <strong>对象.getClass();</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs jV">/**<br>   目标：反射的第一步：获取Class对象<br> */<br>public class Test &#123;<br>    public static void main(String[] args) throws Exception &#123;<br>        // 1、Class类中的一个静态方法：forName(全限名：包名 + 类名)<br>        Class c = Class.forName(&quot;com.itheima.d2_reflect_class.Student&quot;);<br>        System.out.println(c); // Student.class<br><br>        // 2、类名.class<br>        Class c1 = Student.class;<br>        System.out.println(c1);<br><br>        // 3、对象.getClass() 获取对象对应类的Class对象。<br>        Student s = new Student();<br>        Class c2 = s.getClass();<br>        System.out.println(c2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="使用反射技术获取构造器对象并使用"><a href="#使用反射技术获取构造器对象并使用" class="headerlink" title="使用反射技术获取构造器对象并使用"></a><strong>使用反射技术获取构造器对象并使用</strong></h6><ul><li><p>反射的第一步是先得到类对象，然后从类对象中获取类的成分对象。</p></li><li><p>Class类中用于获取构造器的方法</p></li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Constructor&lt;?&gt;[]  getConstructors()</td><td>返回所有构造器对象的数组（只能拿public的）</td></tr><tr><td>Constructor&lt;?&gt;[]  getDeclaredConstructors()</td><td>返回所有构造器对象的数组，存在就能拿到</td></tr><tr><td>Constructor<T>  getConstructor(Class&lt;?&gt;…  parameterTypes)</td><td>返回单个构造器对象（只能拿public的）</td></tr><tr><td>Constructor<T>  getDeclaredConstructor(Class&lt;?&gt;…  parameterTypes)</td><td>返回单个构造器对象，存在就能拿到</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;无参数构造器执行！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;有参数构造器执行！&quot;</span>);<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：反射_获取Constructor构造器对象.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    反射的第一步是先得到Class类对象。（Class文件）</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    反射中Class类型获取构造器提供了很多的API:</span><br><span class="hljs-comment">         1. Constructor getConstructor(Class... parameterTypes)</span><br><span class="hljs-comment">            根据参数匹配获取某个构造器，只能拿public修饰的构造器，几乎不用！</span><br><span class="hljs-comment">         2. Constructor getDeclaredConstructor(Class... parameterTypes)</span><br><span class="hljs-comment">            根据参数匹配获取某个构造器，只要申明就可以定位，不关心权限修饰符，建议使用！</span><br><span class="hljs-comment">         3. Constructor[] getConstructors()</span><br><span class="hljs-comment">            获取所有的构造器，只能拿public修饰的构造器。几乎不用！！太弱了！</span><br><span class="hljs-comment">         4. Constructor[] getDeclaredConstructors()</span><br><span class="hljs-comment">            获取所有申明的构造器，只要你写我就能拿到，无所谓权限。建议使用！！</span><br><span class="hljs-comment">    小结：</span><br><span class="hljs-comment">        获取类的全部构造器对象： Constructor[] getDeclaredConstructors()</span><br><span class="hljs-comment">            -- 获取所有申明的构造器，只要你写我就能拿到，无所谓权限。建议使用！！</span><br><span class="hljs-comment">        获取类的某个构造器对象：Constructor getDeclaredConstructor(Class... parameterTypes)</span><br><span class="hljs-comment">            -- 根据参数匹配获取某个构造器，只要申明就可以定位，不关心权限修饰符，建议使用！</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestStudent01</span> &#123;<br>    <span class="hljs-comment">// 1. getConstructors:</span><br>    <span class="hljs-comment">// 获取全部的构造器：只能获取public修饰的构造器。</span><br>    <span class="hljs-comment">// Constructor[] getConstructors()</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getConstructors</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// a.第一步：获取类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Student.class;<br>        <span class="hljs-comment">// b.提取类中的全部的构造器对象(这里只能拿public修饰)</span><br>        Constructor[] constructors = c.getConstructors();<br>        <span class="hljs-comment">// c.遍历构造器</span><br>        <span class="hljs-keyword">for</span> (Constructor constructor : constructors) &#123;<br>            System.out.println(constructor.getName() + <span class="hljs-string">&quot;===&gt;&quot;</span> + constructor.getParameterCount());<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">// 2.getDeclaredConstructors():</span><br>    <span class="hljs-comment">// 获取全部的构造器：只要你敢写，这里就能拿到，无所谓权限是否可及。</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getDeclaredConstructors</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// a.第一步：获取类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Student.class;<br>        <span class="hljs-comment">// b.提取类中的全部的构造器对象</span><br>        Constructor[] constructors = c.getDeclaredConstructors();<br>        <span class="hljs-comment">// c.遍历构造器</span><br>        <span class="hljs-keyword">for</span> (Constructor constructor : constructors) &#123;<br>            System.out.println(constructor.getName() + <span class="hljs-string">&quot;===&gt;&quot;</span> + constructor.getParameterCount());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 3.getConstructor(Class... parameterTypes)</span><br>    <span class="hljs-comment">// 获取某个构造器：只能拿public修饰的某个构造器</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getConstructor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// a.第一步：获取类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Student.class;<br>        <span class="hljs-comment">// b.定位单个构造器对象 (按照参数定位无参数构造器 只能拿public修饰的某个构造器)</span><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">cons</span> <span class="hljs-operator">=</span> c.getConstructor();<br>        System.out.println(cons.getName() + <span class="hljs-string">&quot;===&gt;&quot;</span> + cons.getParameterCount());<br>    &#125;<br><br><br>    <span class="hljs-comment">// 4.getConstructor(Class... parameterTypes)</span><br>    <span class="hljs-comment">// 获取某个构造器：只要你敢写，这里就能拿到，无所谓权限是否可及。</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getDeclaredConstructor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// a.第一步：获取类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Student.class;<br>        <span class="hljs-comment">// b.定位单个构造器对象 (按照参数定位无参数构造器)</span><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">cons</span> <span class="hljs-operator">=</span> c.getDeclaredConstructor();<br>        System.out.println(cons.getName() + <span class="hljs-string">&quot;===&gt;&quot;</span> + cons.getParameterCount());<br><br>        <span class="hljs-comment">// c.定位某个有参构造器</span><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">cons1</span> <span class="hljs-operator">=</span> c.getDeclaredConstructor(String.class, <span class="hljs-type">int</span>.class);<br>        System.out.println(cons1.getName() + <span class="hljs-string">&quot;===&gt;&quot;</span> + cons1.getParameterCount());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="Constructor类中用于创建对象的方法"><a href="#Constructor类中用于创建对象的方法" class="headerlink" title="Constructor类中用于创建对象的方法"></a><strong>Constructor类中用于创建对象的方法</strong></h6><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>T newInstance(Object…  initargs)</td><td>根据指定的构造器创建对象</td></tr><tr><td>public  void setAccessible(boolean  flag)</td><td>设置为true,表示取消访问检查，进行暴力反射</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标: 反射_获取Constructor构造器然后通过这个构造器初始化对象。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    反射获取Class中的构造器对象Constructor作用：</span><br><span class="hljs-comment">            也是初始化并得到类的一个对象返回。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Constructor的API:</span><br><span class="hljs-comment">         1. T newInstance(Object... initargs)</span><br><span class="hljs-comment">                创建对象，注入构造器需要的数据。</span><br><span class="hljs-comment">         2. void setAccessible(true)</span><br><span class="hljs-comment">                修改访问权限，true代表暴力攻破权限，false表示保留不可访问权限(暴力反射)</span><br><span class="hljs-comment">    小结：</span><br><span class="hljs-comment">        可以通过定位类的构造器对象。</span><br><span class="hljs-comment">        如果构造器对象没有访问权限可以通过：void setAccessible(true)打开权限</span><br><span class="hljs-comment">        构造器可以通过T newInstance(Object... initargs)调用自己，传入参数！</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestStudent02</span> &#123;<br>    <span class="hljs-comment">// 1.调用构造器得到一个类的对象返回。</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getDeclaredConstructor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// a.第一步：获取类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Student.class;<br>        <span class="hljs-comment">// b.定位单个构造器对象 (按照参数定位无参数构造器)</span><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">cons</span> <span class="hljs-operator">=</span> c.getDeclaredConstructor();<br>        System.out.println(cons.getName() + <span class="hljs-string">&quot;===&gt;&quot;</span> + cons.getParameterCount());<br><br>        <span class="hljs-comment">// 如果遇到了私有的构造器，可以暴力反射</span><br>        cons.setAccessible(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 权限被打开，被打开一次</span><br><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (Student) cons.newInstance();<br>        System.out.println(s);<br><br>        System.out.println(<span class="hljs-string">&quot;-------------------&quot;</span>);<br><br>        <span class="hljs-comment">// c.定位某个有参构造器</span><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">cons1</span> <span class="hljs-operator">=</span> c.getDeclaredConstructor(String.class, <span class="hljs-type">int</span>.class);<br>        System.out.println(cons1.getName() + <span class="hljs-string">&quot;===&gt;&quot;</span> + cons1.getParameterCount());<br><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> (Student) cons1.newInstance(<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-number">1000</span>);<br>        System.out.println(s1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="使用反射技术获取成员变量对象并使用"><a href="#使用反射技术获取成员变量对象并使用" class="headerlink" title="使用反射技术获取成员变量对象并使用"></a><strong>使用反射技术获取成员变量对象并使用</strong></h6><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220430170214454.png" alt="image-20220430170214454"></p><ul><li><p>反射的第一步是先得到类对象，然后从类对象中获取类的成分对象。</p></li><li><p>Class类中用于获取成员变量的方法</p></li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Field[]  getFields()</td><td>返回所有成员变量对象的数组（只能拿public的）</td></tr><tr><td>Field[]  getDeclaredFields()</td><td>返回所有成员变量对象的数组，存在就能拿到</td></tr><tr><td>Field  getField(String  name)</td><td>返回单个成员变量对象（只能拿public的）</td></tr><tr><td>Field  getDeclaredField(String  name)</td><td>返回单个成员变量对象，存在就能拿到</td></tr></tbody></table><p><strong>Field类中用于取值、赋值的方法</strong></p><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>void  set(Object obj, Object value)：</td><td>赋值</td></tr><tr><td>Object  get(Object obj)</td><td>获取值。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     目标：反射_获取Field成员变量对象。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     反射的第一步是先得到Class类对象。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     1、Field getField(String name);</span><br><span class="hljs-comment">            根据成员变量名获得对应Field对象，只能获得public修饰</span><br><span class="hljs-comment">     2.Field getDeclaredField(String name);</span><br><span class="hljs-comment">            根据成员变量名获得对应Field对象，只要申明了就可以得到</span><br><span class="hljs-comment">     3.Field[] getFields();</span><br><span class="hljs-comment">            获得所有的成员变量对应的Field对象，只能获得public的</span><br><span class="hljs-comment">     4.Field[] getDeclaredFields();</span><br><span class="hljs-comment">            获得所有的成员变量对应的Field对象，只要申明了就可以得到</span><br><span class="hljs-comment">     小结：</span><br><span class="hljs-comment">        获取全部成员变量：getDeclaredFields</span><br><span class="hljs-comment">        获取某个成员变量：getDeclaredField</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FieldDemo01</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1.获取全部的成员变量。</span><br><span class="hljs-comment">     * Field[] getDeclaredFields();</span><br><span class="hljs-comment">     *  获得所有的成员变量对应的Field对象，只要申明了就可以得到</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getDeclaredFields</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// a.定位Class对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Student.class;<br>        <span class="hljs-comment">// b.定位全部成员变量</span><br>        Field[] fields = c.getDeclaredFields();<br>        <span class="hljs-comment">// c.遍历一下</span><br>        <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>            System.out.println(field.getName() + <span class="hljs-string">&quot;==&gt;&quot;</span> + field.getType());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">        2.获取某个成员变量对象 Field getDeclaredField(String name);</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getDeclaredField</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// a.定位Class对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Student.class;<br>        <span class="hljs-comment">// b.根据名称定位某个成员变量</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;age&quot;</span>);<br>        System.out.println(f.getName() +<span class="hljs-string">&quot;===&gt;&quot;</span> + f.getType());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：反射获取成员变量: 取值和赋值。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Field的方法：给成员变量赋值和取值</span><br><span class="hljs-comment">        void set(Object obj, Object value)：给对象注入某个成员变量数据</span><br><span class="hljs-comment">        Object get(Object obj):获取对象的成员变量的值。</span><br><span class="hljs-comment">        void setAccessible(true);暴力反射，设置为可以直接访问私有类型的属性。</span><br><span class="hljs-comment">        Class getType(); 获取属性的类型，返回Class对象。</span><br><span class="hljs-comment">        String getName(); 获取属性的名称。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FieldDemo02</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setField</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// a.反射第一步，获取类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Student.class;<br>        <span class="hljs-comment">// b.提取某个成员变量</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">ageF</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;age&quot;</span>);<br><br>        ageF.setAccessible(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 暴力打开权限</span><br><br>        <span class="hljs-comment">// c.赋值</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        ageF.set(s , <span class="hljs-number">18</span>);  <span class="hljs-comment">// s.setAge(18);</span><br>        System.out.println(s);<br><br>        <span class="hljs-comment">// d、取值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) ageF.get(s);<br>        System.out.println(age);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="使用反射技术获取方法对象并使用"><a href="#使用反射技术获取方法对象并使用" class="headerlink" title="使用反射技术获取方法对象并使用"></a><strong>使用反射技术获取方法对象并使用</strong></h6><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220430171323459-165154597765923.png" alt="image-20220430171323459"></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Method[]  getMethods()</td><td>返回所有成员方法对象的数组（只能拿public的）</td></tr><tr><td>Method[]  getDeclaredMethods()</td><td>返回所有成员方法对象的数组，存在就能拿到</td></tr><tr><td>Method  getMethod(String  name, Class&lt;?&gt;… parameterTypes)</td><td>返回单个成员方法对象（只能拿public的）</td></tr><tr><td>Method  getDeclaredMethod(String  name, Class&lt;?&gt;… parameterTypes)</td><td>返回单个成员方法对象，存在就能拿到</td></tr></tbody></table><p><strong>Method类中用于触发执行的方法</strong></p><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>Object invoke(Object obj, Object… args)</td><td>运行方法  参数一：用obj对象调用该方法  参数二：调用方法的传递的参数（如果没有就不写）  返回值：方法的返回值（如果没有就不写）</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>    <span class="hljs-keyword">private</span> String name ;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;狗跑的贼快~~&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;狗吃骨头&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">eat</span><span class="hljs-params">(String name)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;狗吃&quot;</span> + name);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;吃的很开心！&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inAddr</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;在黑马学习Java!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：反射——获取Method方法对象</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    反射获取类的Method方法对象：</span><br><span class="hljs-comment">         1、Method getMethod(String name,Class...args);</span><br><span class="hljs-comment">             根据方法名和参数类型获得对应的方法对象，只能获得public的</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">         2、Method getDeclaredMethod(String name,Class...args);</span><br><span class="hljs-comment">             根据方法名和参数类型获得对应的方法对象，包括private的</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">         3、Method[] getMethods();</span><br><span class="hljs-comment">             获得类中的所有成员方法对象，返回数组，只能获得public修饰的且包含父类的</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">         4、Method[] getDeclaredMethods();</span><br><span class="hljs-comment">            获得类中的所有成员方法对象，返回数组,只获得本类申明的方法。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Method的方法执行：</span><br><span class="hljs-comment">        Object invoke(Object obj, Object... args)</span><br><span class="hljs-comment">          参数一：触发的是哪个对象的方法执行。</span><br><span class="hljs-comment">          参数二： args：调用方法时传递的实际参数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodDemo01</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1.获得类中的所有成员方法对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getDeclaredMethods</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// a.获取类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Dog.class;<br>        <span class="hljs-comment">// b.提取全部方法；包括私有的</span><br>        Method[] methods = c.getDeclaredMethods();<br>        <span class="hljs-comment">// c.遍历全部方法</span><br>        <span class="hljs-keyword">for</span> (Method method : methods) &#123;<br>            System.out.println(method.getName() +<span class="hljs-string">&quot; 返回值类型：&quot;</span> + method.getReturnType() + <span class="hljs-string">&quot; 参数个数：&quot;</span> + method.getParameterCount());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 2. 获取某个方法对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getDeclardMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// a.获取类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Dog.class;<br>        <span class="hljs-comment">// b.提取单个方法对象</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> c.getDeclaredMethod(<span class="hljs-string">&quot;eat&quot;</span>);<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">m2</span> <span class="hljs-operator">=</span> c.getDeclaredMethod(<span class="hljs-string">&quot;eat&quot;</span>, String.class);<br><br>        <span class="hljs-comment">// 暴力打开权限了</span><br>        m.setAccessible(<span class="hljs-literal">true</span>);<br>        m2.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-comment">// c.触发方法的执行</span><br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        <span class="hljs-comment">// 注意：方法如果是没有结果回来的，那么返回的是null.</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> m.invoke(d);<br>        System.out.println(result);<br><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result2</span> <span class="hljs-operator">=</span> m2.invoke(d, <span class="hljs-string">&quot;骨头&quot;</span>);<br>        System.out.println(result2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="反射的作用——绕过编译阶段为集合添加数据"><a href="#反射的作用——绕过编译阶段为集合添加数据" class="headerlink" title="反射的作用——绕过编译阶段为集合添加数据****"></a><strong>反射的作用</strong>——绕过编译阶段为集合添加数据****</h6><ul><li>反射是作用在运行时的技术，此时集合的泛型将不能产生约束了，此时是可以为集合存入其他任意类型的元素的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-number">100</span>);<br><span class="hljs-comment">// list.add(“黑马&quot;); // 报错</span><br>list.add(<span class="hljs-number">99</span>);<br></code></pre></td></tr></table></figure><ul><li>泛型只是在编译阶段可以约束集合只能操作某种数据类型，在编译成Class文件进入运行阶段的时候，其真实类型都是ArrayList了，泛型相当于被擦除了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 需求：反射实现泛型擦除后，加入其他类型的元素</span><br>        ArrayList&lt;String&gt; lists1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        ArrayList&lt;Integer&gt; lists2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        System.out.println(lists1.getClass());<br>        System.out.println(lists2.getClass());<br><br>        System.out.println(lists1.getClass() ==  lists2.getClass());  <span class="hljs-comment">// ArrayList.class</span><br><br>        System.out.println(<span class="hljs-string">&quot;---------------------------&quot;</span>);<br>        ArrayList&lt;Integer&gt; lists3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        lists3.add(<span class="hljs-number">23</span>);<br>        lists3.add(<span class="hljs-number">22</span>);<br>        <span class="hljs-comment">// lists3.add(&quot;黑马&quot;);</span><br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> lists3.getClass(); <span class="hljs-comment">// ArrayList.class  ===&gt; public boolean add(E e)</span><br>        <span class="hljs-comment">// 定位c类中的add方法</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">add</span> <span class="hljs-operator">=</span> c.getDeclaredMethod(<span class="hljs-string">&quot;add&quot;</span>, Object.class);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> (<span class="hljs-type">boolean</span>) add.invoke(lists3, <span class="hljs-string">&quot;黑马&quot;</span>);<br>        System.out.println(rs);<br><br>        System.out.println(lists3);<br><span class="hljs-comment">//也可以这样</span><br>        <span class="hljs-type">ArrayList</span> <span class="hljs-variable">list4</span> <span class="hljs-operator">=</span> lists3;<br>        list4.add(<span class="hljs-string">&quot;白马&quot;</span>);<br>        list4.add(<span class="hljs-literal">false</span>);<br>        System.out.println(lists3);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="反射做通用框架"><a href="#反射做通用框架" class="headerlink" title="反射做通用框架"></a>反射做通用框架</h6><p>给你任意一个对象，在不清楚对象字段的情况可以，可以把对象的字段名称和对应值存储到文件中去。</p><p><strong>分析</strong></p><p>①定义一个方法，可以接收任意类的对象。</p><p>②每次收到一个对象后，需要解析这个对象的全部成员变量名称。</p><p>③这个对象可能是任意的，那么怎么样才可以知道这个对象的全部成员变量名称呢？</p><p>④使用反射获取对象的Class类对象，然后获取全部成员变量信息。</p><p>⑤遍历成员变量信息，然后提取本成员变量在对象中的具体值</p><p>⑥存入成员变量名称和值到文件中去即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   目标：提供一个通用框架，支持保存所有对象的具体信息。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        s.setName(<span class="hljs-string">&quot;猪八戒&quot;</span>);<br>        s.setClassName(<span class="hljs-string">&quot;西天跑路1班&quot;</span>);<br>        s.setAge(<span class="hljs-number">1000</span>);<br>        s.setHobby(<span class="hljs-string">&quot;吃，睡&quot;</span>);<br>        s.setSex(<span class="hljs-string">&#x27;男&#x27;</span>);<br>        MybatisUtil.save(s);<br><br>        <span class="hljs-type">Teacher</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>();<br>        t.setName(<span class="hljs-string">&quot;波仔&quot;</span>);<br>        t.setSex(<span class="hljs-string">&#x27;男&#x27;</span>);<br>        t.setSalary(<span class="hljs-number">6000</span>);<br>        MybatisUtil.save(t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisUtil</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     保存任意类型的对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> obj</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(Object obj)</span>&#123;<br>        <span class="hljs-keyword">try</span> (<br>                <span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;junit-reflect-annotation-proxy-app/src/data.txt&quot;</span>, <span class="hljs-literal">true</span>));<br>        )&#123;<br>            <span class="hljs-comment">// 1、提取这个对象的全部成员变量：只有反射可以解决</span><br>            <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> obj.getClass();  <span class="hljs-comment">//   c.getSimpleName()获取当前类名   c.getName获取全限名：包名+类名</span><br>            ps.println(<span class="hljs-string">&quot;================&quot;</span> + c.getSimpleName() + <span class="hljs-string">&quot;================&quot;</span>);<br><br>            <span class="hljs-comment">// 2、提取它的全部成员变量</span><br>            Field[] fields = c.getDeclaredFields();<br>            <span class="hljs-comment">// 3、获取成员变量的信息</span><br>            <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> field.getName();<br>                <span class="hljs-comment">// 提取本成员变量在obj对象中的值（取值）</span><br>                field.setAccessible(<span class="hljs-literal">true</span>);<br>                <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> field.get(obj) + <span class="hljs-string">&quot;&quot;</span>;<br>                ps.println(name  + <span class="hljs-string">&quot;=&quot;</span> + value);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="注解概述、作用"><a href="#注解概述、作用" class="headerlink" title="注解概述、作用"></a><strong>注解概述、作用</strong></h6><ul><li><p>Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。</p></li><li><p>Java 语言中的类、构造器、方法、成员变量、参数等都可以被注解进行标注。</p></li></ul><p><strong>注解的作用是什么呢？</strong></p><ul><li><p>对Java中类、方法、成员变量做标记，然后进行特殊处理，至于到底做何种处理由业务需求来决定。</p></li><li><p>例如：JUnit框架中，标记了注解@Test的方法就可以被当成测试方法执行，而没有标记的就不能当成测试方法执行。</p></li></ul><p><strong>自定义注解</strong> <strong>—</strong> <strong>格式</strong></p><p>自定义注解就是自己做一个注解来使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> 注解名称 &#123;<br><span class="hljs-keyword">public</span> 属性类型 属性名() <span class="hljs-keyword">default</span> 默认值 ;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyBook &#123;<br>    String <span class="hljs-title function_">name</span><span class="hljs-params">()</span>;<br>    String[] authors();<br>    <span class="hljs-type">double</span> <span class="hljs-title function_">price</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">   目标：学会自定义注解。掌握其定义格式和语法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@MyBook(name=&quot;《精通JavaSE》&quot;,authors = &#123;&quot;黑马&quot;, &quot;dlei&quot;&#125; , price = 199.5)</span><br><span class="hljs-comment">//@Book(value = &quot;/delete&quot;)</span><br><span class="hljs-comment">// @Book(&quot;/delete&quot;)</span><br><span class="hljs-meta">@Book(value = &quot;/delete&quot;, price = 23.5)</span><br><span class="hljs-comment">//@Book(&quot;/delete&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnnotationDemo1</span> &#123;<br><br>    <span class="hljs-meta">@MyBook(name=&quot;《精通JavaSE2》&quot;,authors = &#123;&quot;黑马&quot;, &quot;dlei&quot;&#125; , price = 199.5)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">AnnotationDemo1</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@MyBook(name=&quot;《精通JavaSE1》&quot;,authors = &#123;&quot;黑马&quot;, &quot;dlei&quot;&#125; , price = 199.5)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-meta">@MyBook(name=&quot;《精通JavaSE2》&quot;,authors = &#123;&quot;黑马&quot;, &quot;dlei&quot;&#125; , price = 199.5)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">21</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>特殊属性</strong></p><ul><li><p>value属性，如果只有一个value属性的情况下，使用value属性的时候可以省略value名称不写!!</p></li><li><p>但是如果有多个属性, 且多个属性没有默认值，那么value名称是不能省略的。</p></li></ul><h6 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h6><ul><li>元注解：就是注解注解的注解。 </li></ul><p><strong>元注解有两个：</strong></p><ul><li><p><strong>@Target</strong>: 约束自定义注解只能在哪些地方使用，</p></li><li><p><strong>@Retention</strong>：申明注解的生命周期</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD,ElementType.FIELD&#125;)</span> <span class="hljs-comment">// 元注解</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="hljs-comment">// 一直活着，在运行阶段这个注解也不消失</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyTest &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>@Target中可使用的值定义在ElementType枚举类中，常用值如下</p><ul><li><p> TYPE，类，接口</p></li><li><p> FIELD, 成员变量</p></li><li><p> METHOD, 成员方法</p></li><li><p> PARAMETER, 方法参数</p></li><li><p> CONSTRUCTOR, 构造器</p></li><li><p> LOCAL_VARIABLE, 局部变量</p></li></ul><p>@Retention中可使用的值定义在RetentionPolicy枚举类中，常用值如下</p><ul><li><p> SOURCE： 注解只作用在源码阶段，生成的字节码文件中不存在</p></li><li><p> CLASS： 注解作用在源码阶段，字节码文件阶段，运行阶段不存在，默认值.</p></li><li><p> RUNTIME：注解作用在源码阶段，字节码文件阶段，运行阶段（开发常用）</p></li></ul><h6 id="注解的解析"><a href="#注解的解析" class="headerlink" title="注解的解析"></a><strong>注解的解析</strong></h6><ul><li>注解的操作中经常需要进行解析，注解的解析就是判断是否存在注解，存在注解就解析出内容。</li></ul><p><strong>与注解解析相关的接口</strong></p><ul><li><p>Annotation: 注解的顶级接口，注解都是Annotation类型的对象</p></li><li><p>AnnotatedElement:该接口定义了与注解解析相关的解析方法</p></li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Annotation[]  getDeclaredAnnotations()</td><td>获得当前对象上使用的所有注解，返回注解数组。</td></tr><tr><td>T getDeclaredAnnotation(Class<T>  annotationClass)</td><td>根据注解类型获得对应注解对象</td></tr><tr><td>boolean isAnnotationPresent(Class<Annotation>  annotationClass)</td><td>判断当前对象是否使用了指定的注解，如果使用了则返回true，否则false</td></tr></tbody></table><p>所有的类成分Class, Method , Field , Constructor，都实现了AnnotatedElement接口他们都拥有解析注解的能力</p><p><strong>解析注解的技巧</strong></p><ul><li><p>注解在哪个成分上，我们就先拿哪个成分对象。</p></li><li><p>比如注解作用成员方法，则要获得该成员方法对应的Method对象，再来拿上面的注解</p></li><li><p>比如注解作用在类上，则要该类的Class对象，再来拿上面的注解</p></li><li><p>比如注解作用在成员变量上，则要获得该成员变量对应的Field对象，再来拿上面的注解</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   目标：完成注解的解析</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnnotationDemo3</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseClass</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// a.先得到类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> BookStore.class;<br>        <span class="hljs-comment">// b.判断这个类上面是否存在这个注解</span><br>        <span class="hljs-keyword">if</span>(c.isAnnotationPresent(Bookk.class))&#123;<br>            <span class="hljs-comment">//c.直接获取该注解对象</span><br>            <span class="hljs-type">Bookk</span> <span class="hljs-variable">book</span> <span class="hljs-operator">=</span> (Bookk) c.getDeclaredAnnotation(Bookk.class);<br>            System.out.println(book.value());<br>            System.out.println(book.price());<br>            System.out.println(Arrays.toString(book.author()));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NoSuchMethodException &#123;<br>        <span class="hljs-comment">// a.先得到类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> BookStore.class;<br><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> c.getDeclaredMethod(<span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-comment">// b.判断这个类上面是否存在这个注解</span><br>        <span class="hljs-keyword">if</span>(m.isAnnotationPresent(Bookk.class))&#123;<br>            <span class="hljs-comment">//c.直接获取该注解对象</span><br>            <span class="hljs-type">Bookk</span> <span class="hljs-variable">book</span> <span class="hljs-operator">=</span> (Bookk) m.getDeclaredAnnotation(Bookk.class);<br>            System.out.println(book.value());<br>            System.out.println(book.price());<br>            System.out.println(Arrays.toString(book.author()));<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Bookk(value = &quot;《情深深雨濛濛》&quot;, price = 99.9, author = &#123;&quot;琼瑶&quot;, &quot;dlei&quot;&#125;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BookStore</span>&#123;<br><br>    <span class="hljs-meta">@Bookk(value = &quot;《三少爷的剑》&quot;, price = 399.9, author = &#123;&quot;古龙&quot;, &quot;熊耀华&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h5><h6 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   模拟用户业务功能</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> &#123;<br>    String <span class="hljs-title function_">login</span><span class="hljs-params">(String loginName , String passWord)</span> ;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectUsers</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">deleteUsers</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateUsers</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">login</span><span class="hljs-params">(String loginName, String passWord)</span>  &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;admin&quot;</span>.equals(loginName) &amp;&amp; <span class="hljs-string">&quot;1234&quot;</span>.equals(passWord)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;登录名和密码可能有毛病&quot;</span>;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectUsers</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;查询了100个用户数据！&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">deleteUsers</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;删除100个用户数据！&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">500</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateUsers</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;修改100个用户数据！&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">2500</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1、把业务对象，直接做成一个代理对象返回，代理对象的类型也是 UserService类型</span><br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> ProxyUtil.getProxy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>());<br>        System.out.println(userService.login(<span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;1234&quot;</span>));<br>        System.out.println(userService.deleteUsers());<br>        userService.selectUsers();<br>        userService.updateUsers(); <span class="hljs-comment">// 走代理</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    public static Object newProxyInstance(ClassLoader loader,  Class&lt;?&gt;[] interfaces, InvocationHandler h)</span><br><span class="hljs-comment">    参数一：类加载器，负责加载代理类到内存中使用。</span><br><span class="hljs-comment">    参数二：获取被代理对象实现的全部接口。代理要为全部接口的全部方法进行代理</span><br><span class="hljs-comment">    参数三：代理的核心处理逻辑</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyUtil</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">      生成业务对象的代理对象。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> obj</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T  <span class="hljs-title function_">getProxy</span><span class="hljs-params">(T obj)</span> &#123;<br>        <span class="hljs-comment">// 返回了一个代理对象了</span><br>        <span class="hljs-keyword">return</span> (T)Proxy.newProxyInstance(obj.getClass().getClassLoader(),<br>                obj.getClass().getInterfaces(),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>                        <span class="hljs-comment">// 参数一：代理对象本身。一般不管</span><br>                        <span class="hljs-comment">// 参数二：正在被代理的方法</span><br>                        <span class="hljs-comment">// 参数三：被代理方法，应该传入的参数</span><br>                       <span class="hljs-type">long</span> <span class="hljs-variable">startTimer</span> <span class="hljs-operator">=</span> System .currentTimeMillis();<br>                        <span class="hljs-comment">// 马上触发方法的真正执行。(触发真正的业务功能)</span><br>                        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(obj, args);<br><br>                        <span class="hljs-type">long</span> <span class="hljs-variable">endTimer</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>                        System.out.println(method.getName() + <span class="hljs-string">&quot;方法耗时：&quot;</span> + (endTimer - startTimer) / <span class="hljs-number">1000.0</span> + <span class="hljs-string">&quot;s&quot;</span>);<br><br>                        <span class="hljs-comment">// 把业务功能方法执行的结果返回给调用者</span><br>                        <span class="hljs-keyword">return</span> result;<br>                    &#125;<br>                &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>业务对象的的每个方法都要进行性能统计，存在大量重复的代码</strong>。</p><h6 id="动态代理-1"><a href="#动态代理-1" class="headerlink" title="动态代理"></a>动态代理</h6><ul><li>代理就是被代理者没有能力或者不愿意去完成某件事情，需要找个人代替自己去完成这件事，动态代理就是用来对业务功能（方法）进行代理的。</li></ul><p>关键步骤</p><p>1.必须有接口，实现类要实现接口（代理通常是基于接口实现的）。</p><p>3.创建一个实现类的对象，该对象为业务对象，紧接着为业务对象做一个代理对象。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220430192519797-165154600613126.png" alt="image-20220430192519797"></p><p><strong>动态代理的优点</strong></p><ul><li><p>非常的灵活，支持任意接口类型的实现类对象做代理，也可以直接为接本身做代理。</p></li><li><p>可以为被代理对象的所有方法做代理。</p></li><li><p>可以在不改变方法源码的情况下，实现对方法功能的增强。</p></li><li><p>不仅简化了编程工作、提高了软件系统的可扩展性，同时也提高了开发效率。</p></li></ul><h4 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h4><p>XML是可扩展标记语言（eXtensible Markup Language）的缩写，它是是一种数据表示格式，可以描述非常复杂的数据结构，常用于传输和存储数据。</p><h6 id="XML的几个特点和使用场景"><a href="#XML的几个特点和使用场景" class="headerlink" title="XML的几个特点和使用场景"></a><strong>XML的几个特点和使用场景</strong></h6><p>一是纯文本，默认使用UTF-8编码；二是可嵌套；</p><p>l如果把XML内容存为文件，那么它就是一个XML文件。</p><p>XML的使用场景：XML内容经常被当成消息进行网络传输，或者作为配置文件用于存储系统的信息。</p><h6 id="XML的创建"><a href="#XML的创建" class="headerlink" title="XML的创建"></a><strong>XML的创建</strong></h6><p><strong>IDEA创建XML文件的操作步骤</strong></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220501180353162-165154601918229.png" alt="image-20220501180353162"></p><h6 id="XML的标签-元素-规则"><a href="#XML的标签-元素-规则" class="headerlink" title="XML的标签(元素)规则"></a><strong>XML的标签(元素)规则</strong></h6><p>XML的标签(元素)规则</p><p>标签由一对尖括号和合法标识符组成: <name></name>，必须存在一个根标签，有且只能有一个。</p><p>标签必须成对出现，有开始，有结束: <name></name></p><p>特殊的标签可以不成对，但是必须有结束标记，如:<br/></p><p>标签中可以定义属性，属性和标签名空格隔开,属性值必须用引号引起来&lt;student id = “1”&gt;</name></p><p>标签需要正确的嵌套</p><h6 id="XML的其他组成"><a href="#XML的其他组成" class="headerlink" title="XML的其他组成"></a><strong>XML的其他组成</strong></h6><p>XML文件中可以定义注释信息：<!-- 注释内容 --></p><p>XML文件中可以存在以下特殊字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&amp;lt;    &lt;  小于<br>&amp;gt;    &gt;  大于<br>&amp;amp;   &amp;  和号<br>&amp;apos;  <span class="hljs-string">&#x27;  单引号</span><br><span class="hljs-string">&amp;quot;  &quot;  引号</span><br></code></pre></td></tr></table></figure><p>XML文件中可以存在CDATA区: <![CDATA[  …内容… ]]></p><p><strong>由于XML文件可以自定义标签，导致XML文件可以随意定义，程序在解析的时候可能出现问题。</strong></p><h6 id="什么是文档约束？"><a href="#什么是文档约束？" class="headerlink" title="什么是文档约束？"></a><strong>什么是文档约束？</strong></h6><p>文档约束：是用来限定xml文件中的标签以及属性应该怎么写。</p><p>以此强制约束程序员必须按照文档约束的规定来编写xml文件。</p><h6 id="文档约束的分类"><a href="#文档约束的分类" class="headerlink" title="文档约束的分类"></a><strong>文档约束的分类</strong></h6><h6 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h6><p>schema</p><p><strong>需求：</strong>利用DTD文档约束，约束一个XML文件的编写。</p><p><strong>分析：</strong></p><p>①：编写DTD约束文档，后缀必须是.dtd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;!ELEMENT 书架 (书+)&gt;<br>&lt;!ELEMENT 书 (书名,作者,售价)&gt;<br>&lt;!ELEMENT 书名 (#PCDATA)&gt;<br>&lt;!ELEMENT 作者 (#PCDATA)&gt;<br>&lt;!ELEMENT 售价 (#PCDATA)&gt;<br></code></pre></td></tr></table></figure><p>②：在需要编写的XML文件中导入该DTD约束文档</p><p>③：按照约束的规定编写XML文件的内容。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE 书架 <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;data.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">书架</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">书</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">书名</span>&gt;</span>精通JavaSE加强<span class="hljs-tag">&lt;/<span class="hljs-name">书名</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">作者</span>&gt;</span>dlei<span class="hljs-tag">&lt;/<span class="hljs-name">作者</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">售价</span>&gt;</span>很贵<span class="hljs-tag">&lt;/<span class="hljs-name">售价</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">书</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">书</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">书名</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">书名</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">作者</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">作者</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">售价</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">售价</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">书</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">书</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">书名</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">书名</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">作者</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">作者</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">售价</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">售价</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">书</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">书架</span>&gt;</span><br></code></pre></td></tr></table></figure><h6 id="文档约束-schema"><a href="#文档约束-schema" class="headerlink" title="文档约束-schema"></a><strong>文档约束-schema</strong></h6><p>schema可以约束具体的数据类型，约束能力上更强大。</p><p>schema本身也是一个xml文件，本身也受到其他约束文件的要求，所以编写的更加严谨</p><p>1.XML的文档约束-schema的优点？</p><p>可以约束XML文件的标签内容格式，以及具体的数据类型。</p><p>本身也是xml文件，格式更严谨。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">schema</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">targetNamespace</span>=<span class="hljs-string">&quot;http://www.itcast.cn&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">elementFormDefault</span>=<span class="hljs-string">&quot;qualified&quot;</span> &gt;</span><br>    <span class="hljs-comment">&lt;!-- targetNamespace:申明约束文档的地址（命名空间）--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">element</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;书架&#x27;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 写子元素 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">complexType</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- maxOccurs=&#x27;unbounded&#x27;: 书架下的子元素可以有任意多个！--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">sequence</span> <span class="hljs-attr">maxOccurs</span>=<span class="hljs-string">&#x27;unbounded&#x27;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">element</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;书&#x27;</span>&gt;</span><br>                    <span class="hljs-comment">&lt;!-- 写子元素 --&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">complexType</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">sequence</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">element</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;书名&#x27;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;string&#x27;</span>/&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">element</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;作者&#x27;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;string&#x27;</span>/&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">element</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;售价&#x27;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;double&#x27;</span>/&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">sequence</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">complexType</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">element</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">sequence</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">complexType</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">element</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">schema</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">书架</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.itcast.cn&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.itcast.cn data.xsd&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- xmlns=&quot;http://www.itcast.cn&quot;  基本位置</span><br><span class="hljs-comment">         xsi:schemaLocation=&quot;http://www.itcast.cn books02.xsd&quot; 具体的位置 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">书</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">书名</span>&gt;</span>神雕侠侣<span class="hljs-tag">&lt;/<span class="hljs-name">书名</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">作者</span>&gt;</span>金庸<span class="hljs-tag">&lt;/<span class="hljs-name">作者</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">售价</span>&gt;</span>399.9<span class="hljs-tag">&lt;/<span class="hljs-name">售价</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">书</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">书</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">书名</span>&gt;</span>神雕侠侣<span class="hljs-tag">&lt;/<span class="hljs-name">书名</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">作者</span>&gt;</span>金庸<span class="hljs-tag">&lt;/<span class="hljs-name">作者</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">售价</span>&gt;</span>19.5<span class="hljs-tag">&lt;/<span class="hljs-name">售价</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">书</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">书架</span>&gt;</span><br></code></pre></td></tr></table></figure><h6 id="XML解析"><a href="#XML解析" class="headerlink" title="XML解析"></a><strong>XML解析</strong></h6><p>使用程序读取XML中的数据</p><p><strong>两种解析方式</strong></p><p>SAX解析//一行一行</p><p>DOM解析//整个文档解析</p><p><strong>Dom常见的解析工具</strong></p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>JAXP</td><td>SUN公司提供的一套XML的解析的API</td></tr><tr><td>JDOM</td><td>JDOM是一个开源项目，它基于树型结构，利用纯JAVA的技术对XML文档实现解析、生成、序列化以及多种操作。</td></tr><tr><td>dom4j</td><td>是JDOM的升级品，用来读写XML文件的。具有性能优异、功能强大和极其易使用的特点，它的性能超过sun公司官方的dom  技术，同时它也是一个开放源代码的软件，Hibernate也用它来读写配置文件。</td></tr><tr><td>jsoup</td><td>功能强大DOM方式的XML解析开发包，尤其对HTML解析更加方便</td></tr></tbody></table><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220501182543306-165154603584732.png" alt="image-20220501182543306"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220501182605641-165154605152335.png" alt="image-20220501182605641"></p><h6 id="使用Dom4J解析出XML文件"><a href="#使用Dom4J解析出XML文件" class="headerlink" title="使用Dom4J解析出XML文件"></a>使用Dom4J解析出XML文件</h6><p><strong>需求：</strong>使用Dom4J把一个XML文件的数据进行解析</p><p><strong>分析：</strong></p><p>①下载Dom4j框架，官网下载。</p><p>②在项目中创建一个文件夹：lib</p><p>③将dom4j-2.1.1.jar文件复制到 lib 文件夹</p><p>④在jar文件上点右键，选择 Add as Library -&gt; 点击OK</p><p>⑤在类中导包使用</p><p><strong>Dom4j解析XML-得到Document对象</strong></p><p>SAXReader类</p><table><thead><tr><th>构造器/方法</th><th>说明</th></tr></thead><tbody><tr><td>public SAXReader()</td><td>创建Dom4J的解析器对象</td></tr><tr><td>Document  read(String url)</td><td>加载XML文件成为Document对象</td></tr></tbody></table><p>Document类</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Element getRootElement()</td><td>获得根元素对象</td></tr></tbody></table><p><strong>Dom4j解析XML的元素、属性、文本</strong></p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>List<Element> elements()</td><td>得到当前元素下所有子元素</td></tr><tr><td>List<Element>  elements(String name)</td><td>得到当前元素下指定名字的子元素返回集合</td></tr><tr><td>Element  element(String name)</td><td>得到当前元素下指定名字的子元素,如果有很多名字相同的返回第一个</td></tr><tr><td>String  getName()</td><td>得到元素名字</td></tr><tr><td>String attributeValue(String name)</td><td>通过属性名直接得到属性值</td></tr><tr><td>String  elementText(子元素名)</td><td>得到指定名称的子元素的文本</td></tr><tr><td>String  getText()</td><td>得到文本</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   目标：学会使用dom4j解析XML文件中的数据。</span><br><span class="hljs-comment">    1、导入dom4j框架。</span><br><span class="hljs-comment">    2、准备一个XML文件。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dom4JHelloWorldDemo1</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseXMLData</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1、创建一个Dom4j的解析器对象，代表了整个dom4j框架</span><br>        <span class="hljs-type">SAXReader</span> <span class="hljs-variable">saxReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXReader</span>();<br><br>        <span class="hljs-comment">// 2、把XML文件加载到内存中成为一个Document文档对象</span><br>        <span class="hljs-comment">// Document document = saxReader.read(new File(&quot;xml-app\\src\\Contacts.xml&quot;)); // 需要通过模块名去定位</span><br>        <span class="hljs-comment">// Document document = saxReader.read(new FileInputStream(&quot;xml-app\\src\\Contacts.xml&quot;));</span><br><br>        <span class="hljs-comment">// 注意: getResourceAsStream中的/是直接去src下寻找的文件</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> Dom4JHelloWorldDemo1.class.getResourceAsStream(<span class="hljs-string">&quot;/Contacts.xml&quot;</span>);<br>        <span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span> saxReader.read(is);<br><br>        <span class="hljs-comment">// 3、获取根元素对象</span><br>        <span class="hljs-type">Element</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> document.getRootElement();<br>        System.out.println(root.getName());<br><br>        <span class="hljs-comment">// 4、拿根元素下的全部子元素对象(一级)</span><br>        <span class="hljs-comment">// List&lt;Element&gt; sonEles =  root.elements();</span><br>        List&lt;Element&gt; sonEles =  root.elements(<span class="hljs-string">&quot;contact&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Element sonEle : sonEles) &#123;<br>            System.out.println(sonEle.getName());<br>        &#125;<br><br>        <span class="hljs-comment">// 拿某个子元素</span><br>        <span class="hljs-type">Element</span> <span class="hljs-variable">userEle</span> <span class="hljs-operator">=</span> root.element(<span class="hljs-string">&quot;user&quot;</span>);<br>        System.out.println(userEle.getName());<br><br>        <span class="hljs-comment">// 默认提取第一个子元素对象 (Java语言。)</span><br>        <span class="hljs-type">Element</span> <span class="hljs-variable">contact</span> <span class="hljs-operator">=</span> root.element(<span class="hljs-string">&quot;contact&quot;</span>);<br>        <span class="hljs-comment">// 获取子元素文本</span><br>        System.out.println(contact.elementText(<span class="hljs-string">&quot;name&quot;</span>));<br>        <span class="hljs-comment">// 去掉前后空格</span><br>        System.out.println(contact.elementTextTrim(<span class="hljs-string">&quot;name&quot;</span>));<br>        <span class="hljs-comment">// 获取当前元素下的子元素对象</span><br>        <span class="hljs-type">Element</span> <span class="hljs-variable">email</span> <span class="hljs-operator">=</span> contact.element(<span class="hljs-string">&quot;email&quot;</span>);<br>        System.out.println(email.getText());<br>        <span class="hljs-comment">// 去掉前后空格</span><br>        System.out.println(email.getTextTrim());<br><br>        <span class="hljs-comment">// 根据元素获取属性值</span><br>        <span class="hljs-type">Attribute</span> <span class="hljs-variable">idAttr</span> <span class="hljs-operator">=</span> contact.attribute(<span class="hljs-string">&quot;id&quot;</span>);<br>        System.out.println(idAttr.getName() + <span class="hljs-string">&quot;--&gt;&quot;</span> + idAttr.getValue());<br>        <span class="hljs-comment">// 直接提取属性值</span><br>        System.out.println(contact.attributeValue(<span class="hljs-string">&quot;id&quot;</span>));<br>        System.out.println(contact.attributeValue(<span class="hljs-string">&quot;vip&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需求:利用Dom4J的知识，将Contact.xml文件中的联系人数据封装成List集合，其中每个元素是实体类Contact。打印输出 List 中的每个元素</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">contactList</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">contact</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">vip</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>   潘金莲  <span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">gender</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">gender</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">email</span>&gt;</span>panpan@itcast.cn<span class="hljs-tag">&lt;/<span class="hljs-name">email</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">contact</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">contact</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">vip</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>武松<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">gender</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">gender</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">email</span>&gt;</span>wusong@itcast.cn<span class="hljs-tag">&lt;/<span class="hljs-name">email</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">contact</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">contact</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;3&quot;</span> <span class="hljs-attr">vip</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>武大狼<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">gender</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">gender</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">email</span>&gt;</span>wuda@itcast.cn<span class="hljs-tag">&lt;/<span class="hljs-name">email</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">contact</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">user</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">user</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">contactList</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> &lt;contact id=&quot;1&quot; vip=&quot;true&quot;&gt;</span><br><span class="hljs-comment"> &lt;name&gt;   潘金莲  &lt;/name&gt;</span><br><span class="hljs-comment"> &lt;gender&gt;女&lt;/gender&gt;</span><br><span class="hljs-comment"> &lt;email&gt;panpan@itcast.cn&lt;/email&gt;</span><br><span class="hljs-comment"> &lt;/contact&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Contact</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> vip;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> gender;<br>    <span class="hljs-keyword">private</span> String email;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Contact</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Contact</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> id, <span class="hljs-type">boolean</span> vip, <span class="hljs-type">char</span> gendar, String email)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.vip = vip;<br>        <span class="hljs-built_in">this</span>.gender = gendar;<br>        <span class="hljs-built_in">this</span>.email = email;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isVip</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> vip;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVip</span><span class="hljs-params">(<span class="hljs-type">boolean</span> vip)</span> &#123;<br>        <span class="hljs-built_in">this</span>.vip = vip;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">getGender</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> gender;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setGender</span><span class="hljs-params">(<span class="hljs-type">char</span> gender)</span> &#123;<br>        <span class="hljs-built_in">this</span>.gender = gender;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getEmail</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> email;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEmail</span><span class="hljs-params">(String email)</span> &#123;<br>        <span class="hljs-built_in">this</span>.email = email;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Contact&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, vip=&quot;</span> + vip +<br>                <span class="hljs-string">&quot;, gendar=&quot;</span> + gender +<br>                <span class="hljs-string">&quot;, email=&#x27;&quot;</span> + email + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dom4JTest2</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseToList</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 需求：解析XML中的数据成为一个List集合对象。</span><br>        <span class="hljs-comment">// 1、导入框架（做过）</span><br>        <span class="hljs-comment">// 2、创建SaxReader对象</span><br>        <span class="hljs-type">SAXReader</span> <span class="hljs-variable">saxReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXReader</span>();<br>        <span class="hljs-comment">// 3、加载XML文件成为文档对象Document对象。</span><br>        <span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span><br>                saxReader.read(Dom4JTest2.class.getResourceAsStream(<span class="hljs-string">&quot;/Contacts.xml&quot;</span>));<br>        <span class="hljs-comment">// 4、先拿根元素</span><br>        <span class="hljs-type">Element</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> document.getRootElement();<br>        <span class="hljs-comment">// 5、提取contact子元素</span><br>        List&lt;Element&gt; contactEles = root.elements(<span class="hljs-string">&quot;contact&quot;</span>);<br>        <span class="hljs-comment">// 6、准备一个ArrayList集合封装联系人信息</span><br>        List&lt;Contact&gt; contacts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 7、遍历Contact子元素</span><br>        <span class="hljs-keyword">for</span> (Element contactEle : contactEles) &#123;<br>            <span class="hljs-comment">// 8、每个子元素都是一个联系人对象</span><br>            <span class="hljs-type">Contact</span> <span class="hljs-variable">contact</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Contact</span>();<br>            contact.setId(Integer.valueOf(contactEle.attributeValue(<span class="hljs-string">&quot;id&quot;</span>)));<br>            contact.setVip(Boolean.valueOf(contactEle.attributeValue(<span class="hljs-string">&quot;vip&quot;</span>)));<br>            contact.setName(contactEle.elementTextTrim(<span class="hljs-string">&quot;name&quot;</span>));<br>            contact.setGender(contactEle.elementTextTrim(<span class="hljs-string">&quot;gender&quot;</span>).charAt(<span class="hljs-number">0</span>));<br>            contact.setEmail(contactEle.elementText(<span class="hljs-string">&quot;email&quot;</span>));<br>            <span class="hljs-comment">// 9、把联系人对象数据加入到List集合</span><br>            contacts.add(contact);<br>        &#125;<br>        <span class="hljs-comment">// 10、遍历List集合</span><br>        <span class="hljs-keyword">for</span> (Contact contact : contacts) &#123;<br>            System.out.println(contact);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要从XML文件中检索需要的某个信息（如name）怎么解决？</p><p><strong>Dom4j需要进行文件的全部解析，然后再寻找数据。</strong></p><p><strong>Xpath技术更加适合做信息检索。</strong></p><h6 id="XPath介绍"><a href="#XPath介绍" class="headerlink" title="XPath介绍"></a><strong>XPath介绍</strong></h6><p>XPath在解析XML文档方面提供了一独树一帜的路径思想，更加优雅，高效</p><p>XPath使用路径表达式来定位XML文档中的元素节点或属性节点。</p><p>/元素/子元素/孙元素</p><p>//子元素//孙元素</p><h6 id="需求：使用Dom4J把一个XML文件的数据进行解析"><a href="#需求：使用Dom4J把一个XML文件的数据进行解析" class="headerlink" title="需求：使用Dom4J把一个XML文件的数据进行解析"></a>需求：使用Dom4J把一个XML文件的数据进行解析</h6><p>分析：</p><p>①导入jar包(dom4j和jaxen-1.1.2.jar)，Xpath技术依赖Dom4j技术</p><p>②通过dom4j的SAXReader获取Document对象</p><p>③利用XPath提供的API,结合XPath的语法完成选取XML文档元素节点进行解析操作。</p><p>④Document中与Xpath相关的API如下：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Node  selectSingleNode(“表达式”)</td><td>获取符合表达式的唯一元素</td></tr><tr><td>List<Node> selectNodes(“表达式”)</td><td>获取符合表达式的元素集合</td></tr></tbody></table><h6 id="Xpath的四大检索方案"><a href="#Xpath的四大检索方案" class="headerlink" title="Xpath的四大检索方案"></a><strong>Xpath的四大检索方案</strong></h6><p>绝对路径</p><p>相对路径</p><p>全文检索</p><p>属性查找</p><h6 id="XPath：绝对路径"><a href="#XPath：绝对路径" class="headerlink" title="XPath：绝对路径"></a><strong>XPath：绝对路径</strong></h6><p>采用绝对路径获取从根节点开始逐层的查找/contactList/contact/name节点列表并打印信息</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>/根元素/子元素/孙元素</td><td>从根元素开始，一级一级向下查找，不能跨级</td></tr></tbody></table><h6 id="XPath：相对路径"><a href="#XPath：相对路径" class="headerlink" title="XPath：相对路径"></a><strong>XPath：相对路径</strong></h6><p>先得到根节点contactList</p><p>再采用相对路径获取下一级contact 节点的name子节点并打印信息</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>./子元素/孙元素</td><td>从当前元素开始，一级一级向下查找，不能跨级</td></tr></tbody></table><h6 id="XPath：全文搜索"><a href="#XPath：全文搜索" class="headerlink" title="XPath：全文搜索"></a><strong>XPath：全文搜索</strong></h6><p>直接全文搜索所有的name元素并打印</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>//contact</td><td>找contact元素，无论元素在哪里</td></tr><tr><td>//contact/name</td><td>找contact，无论在哪一级，但name一定是contact的子节点</td></tr><tr><td>//contact//name</td><td>contact无论在哪一种，name只要是contact的子孙元素都可以找到</td></tr></tbody></table><h6 id="XPath：属性查找"><a href="#XPath：属性查找" class="headerlink" title="XPath：属性查找"></a><strong>XPath：属性查找</strong></h6><p>在全文中搜索属性，或者带属性的元素</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>//@属性名</td><td>查找属性对象，无论是哪个元素，只要有这个属性即可。</td></tr><tr><td>//元素[@属性名]</td><td>查找元素对象，全文搜索指定元素名和属性名。</td></tr><tr><td>//元素//[@属性名=‘值’]</td><td>查找元素对象，全文搜索指定元素名和属性名，并且属性值相等。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：XPath检索XML中的信息啊。(了解)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    引入：</span><br><span class="hljs-comment">        Dom4J可以用于解析整个XML的数据。</span><br><span class="hljs-comment">        但是如果要检索XML中的某些信息，建议使用XPath.（Xpath依赖Dom4j技术）</span><br><span class="hljs-comment">        Dom4J用于解析数据，Xpath用于检索数据。</span><br><span class="hljs-comment">    XPath使用步骤：</span><br><span class="hljs-comment">        1.导入dom4j框架。（XPath依赖于Dom4j技术,必须先导入dom4j框架！）</span><br><span class="hljs-comment">        2.导入XPath独有的框架包。jaxen-1.1.2.jar</span><br><span class="hljs-comment">    XPath常用API:</span><br><span class="hljs-comment">        List&lt;Node&gt; selectNodes(String var1):检索出一批节点集合。</span><br><span class="hljs-comment">        Node selectSingleNode(String var1)：检索出一个节点返回。</span><br><span class="hljs-comment">    XPath提供的四种检索数据的写法：</span><br><span class="hljs-comment">        1.绝对路径。</span><br><span class="hljs-comment">        2.相对路径。</span><br><span class="hljs-comment">        3.全文搜索。</span><br><span class="hljs-comment">        4.属性查找。</span><br><span class="hljs-comment">    小结：</span><br><span class="hljs-comment">         1.绝对路径： /根元素/子元素/子元素。</span><br><span class="hljs-comment">         2.相对路径： ./子元素/子元素。 (.代表了当前元素)</span><br><span class="hljs-comment">         3.全文搜索：</span><br><span class="hljs-comment">                //元素  在全文找这个元素</span><br><span class="hljs-comment">                //元素1/元素2  在全文找元素1下面的一级元素2</span><br><span class="hljs-comment">                //元素1//元素2  在全文找元素1下面的全部元素2</span><br><span class="hljs-comment">         4.属性查找。</span><br><span class="hljs-comment">                //@属性名称  在全文检索属性对象。</span><br><span class="hljs-comment">                //元素[@属性名称]  在全文检索包含该属性的元素对象。</span><br><span class="hljs-comment">                //元素[@属性名称=值]  在全文检索包含该属性的元素且属性值为该值的元素对象。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XPathDemo</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     1.绝对路径: /根元素/子元素/子元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parse01</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// a、创建解析器对象</span><br>        <span class="hljs-type">SAXReader</span> <span class="hljs-variable">saxReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXReader</span>();<br>        <span class="hljs-comment">// b、把XML加载成Document文档对象</span><br>        <span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span><br>                saxReader.read(XPathDemo.class.getResourceAsStream(<span class="hljs-string">&quot;/Contacts2.xml&quot;</span>));<br>        <span class="hljs-comment">// c、检索全部的名称</span><br>        List&lt;Node&gt; nameNodes = document.selectNodes(<span class="hljs-string">&quot;/contactList/contact/name&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Node nameNode : nameNodes) &#123;<br>            <span class="hljs-type">Element</span>  <span class="hljs-variable">nameEle</span> <span class="hljs-operator">=</span> (Element) nameNode;<br>            System.out.println(nameEle.getTextTrim());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     2.相对路径： ./子元素/子元素。 (.代表了当前元素)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parse02</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// a、创建解析器对象</span><br>        <span class="hljs-type">SAXReader</span> <span class="hljs-variable">saxReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXReader</span>();<br>        <span class="hljs-comment">// b、把XML加载成Document文档对象</span><br>        <span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span><br>                saxReader.read(XPathDemo.class.getResourceAsStream(<span class="hljs-string">&quot;/Contacts2.xml&quot;</span>));<br>        <span class="hljs-type">Element</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> document.getRootElement();<br>        <span class="hljs-comment">// c、检索全部的名称</span><br>        List&lt;Node&gt; nameNodes = root.selectNodes(<span class="hljs-string">&quot;./contact/name&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Node nameNode : nameNodes) &#123;<br>            <span class="hljs-type">Element</span>  <span class="hljs-variable">nameEle</span> <span class="hljs-operator">=</span> (Element) nameNode;<br>            System.out.println(nameEle.getTextTrim());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     3.全文搜索：</span><br><span class="hljs-comment">     //元素  在全文找这个元素</span><br><span class="hljs-comment">     //元素1/元素2  在全文找元素1下面的一级元素2</span><br><span class="hljs-comment">     //元素1//元素2  在全文找元素1下面的全部元素2</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parse03</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// a、创建解析器对象</span><br>        <span class="hljs-type">SAXReader</span> <span class="hljs-variable">saxReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXReader</span>();<br>        <span class="hljs-comment">// b、把XML加载成Document文档对象</span><br>        <span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span><br>                saxReader.read(XPathDemo.class.getResourceAsStream(<span class="hljs-string">&quot;/Contacts2.xml&quot;</span>));<br>        <span class="hljs-comment">// c、检索数据</span><br>        <span class="hljs-comment">//List&lt;Node&gt; nameNodes = document.selectNodes(&quot;//name&quot;);</span><br>        <span class="hljs-comment">// List&lt;Node&gt; nameNodes = document.selectNodes(&quot;//contact/name&quot;);</span><br>        List&lt;Node&gt; nameNodes = document.selectNodes(<span class="hljs-string">&quot;//contact//name&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Node nameNode : nameNodes) &#123;<br>            <span class="hljs-type">Element</span>  <span class="hljs-variable">nameEle</span> <span class="hljs-operator">=</span> (Element) nameNode;<br>            System.out.println(nameEle.getTextTrim());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     4.属性查找。</span><br><span class="hljs-comment">     //@属性名称  在全文检索属性对象。</span><br><span class="hljs-comment">     //元素[@属性名称]  在全文检索包含该属性的元素对象。</span><br><span class="hljs-comment">     //元素[@属性名称=值]  在全文检索包含该属性的元素且属性值为该值的元素对象。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parse04</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// a、创建解析器对象</span><br>        <span class="hljs-type">SAXReader</span> <span class="hljs-variable">saxReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXReader</span>();<br>        <span class="hljs-comment">// b、把XML加载成Document文档对象</span><br>        <span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span><br>                saxReader.read(XPathDemo.class.getResourceAsStream(<span class="hljs-string">&quot;/Contacts2.xml&quot;</span>));<br>        <span class="hljs-comment">// c、检索数据</span><br>        List&lt;Node&gt; nodes = document.selectNodes(<span class="hljs-string">&quot;//@id&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Node node : nodes) &#123;<br>            <span class="hljs-type">Attribute</span> <span class="hljs-variable">attr</span> <span class="hljs-operator">=</span> (Attribute) node;<br>            System.out.println(attr.getName() + <span class="hljs-string">&quot;===&gt;&quot;</span> + attr.getValue());<br>        &#125;<br><br>        <span class="hljs-comment">// 查询name元素（包含id属性的）</span><br><span class="hljs-comment">//      Node node = document.selectSingleNode(&quot;//name[@id]&quot;);</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> document.selectSingleNode(<span class="hljs-string">&quot;//name[@id=888]&quot;</span>);<br>        <span class="hljs-type">Element</span> <span class="hljs-variable">ele</span> <span class="hljs-operator">=</span> (Element) node;<br>        System.out.println(ele.getTextTrim());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h5><h6 id="什么是工厂设计模式？"><a href="#什么是工厂设计模式？" class="headerlink" title="什么是工厂设计模式？"></a><strong>什么是工厂设计模式？</strong></h6><ul><li><p>之前我们创建类对象时, 都是使用new 对象的形式创建,在很多业务场景下也提供了不直接new的方式 。</p></li><li><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一， 这种类型的设计模式属于创建型模式，它提供了一种获取对象的方式。</p></li></ul><h6 id="工厂设计模式的作用："><a href="#工厂设计模式的作用：" class="headerlink" title="工厂设计模式的作用："></a><strong>工厂设计模式的作用：</strong></h6><p>工厂的方法可以封装对象的创建细节，比如：为该对象进行加工和数据注入。</p><p>可以实现类与类之间的解耦操作（核心思想）。（不想用了只需要改名字）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FactoryPattern</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">       定义一个方法，创建对象返回</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Computer <span class="hljs-title function_">createComputer</span><span class="hljs-params">(String info)</span>&#123;<br>        <span class="hljs-keyword">switch</span> (info)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;huawei&quot;</span>:<br>                <span class="hljs-type">Computer</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Huawei</span>();<br>                c.setName(<span class="hljs-string">&quot;huawei pro 16&quot;</span>);<br>                c.setPrice(<span class="hljs-number">5999</span>);<br>                <span class="hljs-keyword">return</span> c;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;mac&quot;</span>:<br>                <span class="hljs-type">Computer</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mac</span>();<br>                c2.setName(<span class="hljs-string">&quot;MacBook pro&quot;</span>);<br>                c2.setPrice(<span class="hljs-number">11999</span>);<br>                <span class="hljs-keyword">return</span> c2;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：工厂模式。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    什么是工厂设计模式？</span><br><span class="hljs-comment">            工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。</span><br><span class="hljs-comment">            这种类型的设计模式属于创建型模式，它提供了一种创建对象的方式。</span><br><span class="hljs-comment">            之前我们创建类对象时, 都是使用new 对象的形式创建, 除new 对象方式以外,</span><br><span class="hljs-comment">            工厂模式也可以创建对象。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    工厂设计模式的作用：</span><br><span class="hljs-comment">            1.对象通过工厂的方法创建返回，工厂的方法可以为该对象进行加工和数据注入。</span><br><span class="hljs-comment">            2.可以实现类与类之间的解耦操作（核心思想，重点）</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    小结：</span><br><span class="hljs-comment">        工厂模式的思想是提供一个工厂方法返回对象！</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FactoryDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Computer</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> FactoryPattern.createComputer(<span class="hljs-string">&quot;huawei&quot;</span>);<br>        c1.start();<br><br>        <span class="hljs-type">Computer</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> FactoryPattern.createComputer(<span class="hljs-string">&quot;mac&quot;</span>);<br>        c2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="什么是装饰设计模式？"><a href="#什么是装饰设计模式？" class="headerlink" title="什么是装饰设计模式？"></a><strong>什么是装饰设计模式？</strong></h6><ul><li>创建一个新类，包装原始类，从而在新类中提升原来类的功能。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">InputStream</span><span class="hljs-params">(抽象父类)</span></span><br><span class="hljs-function"><span class="hljs-title">FileInputStream</span><span class="hljs-params">(实现子类，读写性能较差)</span></span><br><span class="hljs-function"><span class="hljs-title">BufferedInputStream</span><span class="hljs-params">(实现子类，装饰类，读写性能高)</span></span><br></code></pre></td></tr></table></figure><ul><li><p>定义父类。</p></li><li><p>定义原始类，继承父类，定义功能。</p></li><li><p>定义装饰类，继承父类，包装原始类，增强功能！！</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   共同父类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputStream</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] buffer)</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">   原始类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStream</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;低性能的方式读取了一个字节a&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">97</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] buffer)</span> &#123;<br>        buffer[<span class="hljs-number">0</span>] = <span class="hljs-number">97</span>;<br>        buffer[<span class="hljs-number">1</span>] = <span class="hljs-number">98</span>;<br>        buffer[<span class="hljs-number">2</span>] = <span class="hljs-number">99</span>;<br>        System.out.println(<span class="hljs-string">&quot;低性能的方式读取了一个字节数组：&quot;</span> + Arrays.toString(buffer));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">   装饰类：继承InputStream 拓展原始类的功能</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStream</span>&#123;<br>    <span class="hljs-keyword">private</span> InputStream is;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BufferedInputStream</span><span class="hljs-params">(InputStream is)</span>&#123;<br>        <span class="hljs-built_in">this</span>.is = is;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;提供8KB的缓冲区，提高读数据性能~~~~&quot;</span>);<br>        <span class="hljs-keyword">return</span> is.read();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] buffer)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;提供8KB的缓冲区，提高读数据性能~~~~&quot;</span>);<br>        <span class="hljs-keyword">return</span> is.read(buffer);<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  装饰模式</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    定义父类：InputStream</span><br><span class="hljs-comment">    定义实现类：FileInputStream 继续父类 定义功能</span><br><span class="hljs-comment">    定义装饰实现类：BufferedInputStream 继承父类 定义功能 包装原始类，增强功能。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DecoratorPattern</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>());<br>        System.out.println(is.read());<br>        System.out.println(is.read(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">3</span>]));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JAVA学习</category>
      
      <category>java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CLion&amp;Navicat</title>
    <link href="/2023/03/20/CLion&amp;Navicat/"/>
    <url>/2023/03/20/CLion&amp;Navicat/</url>
    
    <content type="html"><![CDATA[<p><a href="https://willwoodson.github.io/">作者</a></p><h1 id="Navicat"><a href="#Navicat" class="headerlink" title="Navicat"></a>Navicat</h1><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310178.png" alt="image-20230309175032787" style="zoom:50%;" /><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://baijiahao.baidu.com/s?id=1740971973625189531&wfr=spider&for=pc">Navicat16破解 Navicat最新版破解教程「永久激活，亲测有效」</a></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><a href="https://www.navicat.com.cn/company/aboutus/blog/478-%E4%BD%BF%E7%94%A8-navicat-16-%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E5%BA%93.html">使用 Navicat 16 创建测试数据库</a></p><p><a href="https://www.bilibili.com/video/BV1Ni4y1c7sG/?spm_id_from=333.337.search-card.all.click&vd_source=3f77123f4c4359b83bca0e12557bdf5c">使用navicat连接mysql数据库创建数据库、表、转储sql文件，导入sql数据</a></p><p><a href="https://www.bilibili.com/video/BV1vV411Y7V3/?spm_id_from=333.337.search-card.all.click&vd_source=3f77123f4c4359b83bca0e12557bdf5c">【Am】神兵利器-Navicat在工作中的所有使用技巧总结</a></p><h1 id="CLion"><a href="#CLion" class="headerlink" title="CLion"></a>CLion</h1><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310179.png" alt="image-20230309175141233" style="zoom:50%;" /><p>CLion是JetBrains公司旗下发布的一款跨平台C/C++/Rust IDE开发工具。</p><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p><a href="https://www.bilibili.com/read/cv21621826/">2023年Clion最新版安装破解激活教程，永久免费使用</a></p><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p><a href="https://www.jianshu.com/p/371066499570">clion远程开发|linux开发环境|跨平台开发|ssh连接远程主机</a></p><p>在 windows上用 clion开发 c++，之前 clion用 mingw的环境，但后面遇到 mingw头文件有些不全，或者 linux里的个别函数没有，会导致 IDE报错，虽然最终不会影响在 linux上编译，但是写代码会很别扭，开发效率降低。</p><p>想到 Source Insight软件可以用 ssh远程加载虚拟机 linux上的项目文件，然后可以更好的查看代码。<br> 在 virtual studio 201*上可以进行 c-linux跨平台开发，连接 linux后，可以直接在 linux上创建项目，在 windows上拥有 linux的开发环境。</p><p>试想 clion应该也可以。确实可以，设置起来也还算简单。</p><p>=================<br> 0，先在 windows本地打开一个原有的项目，或者创建一个空项目，反正要先打开一个项目。<br> 虚拟机 linux上面不用下载额外的工具，只需要 clion一个软件 和 项目程序能够运行的 linux环境 就可以。</p><p>1，先看我用的软件版本</p><p>2，之前配置 mingw的情况</p><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310180.png" alt="image-20230309164507118" style="zoom: 50%;" /><p>001_mingw.png</p><p>3，打开 file -&gt; settings -&gt; toolchains 在工具链添加远程主机</p><p><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310181.png" alt="image-20230309164518187"></p><p>4，点击 deploment 设置部署</p><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310182.png" alt="image-20230309164534007" style="zoom:50%;" /><p>003_deployment.png</p><p>或者是在 tools -&gt; deploment 打开部署设置</p><p><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310183.png" alt="image-20230309164541736"></p><p>004_deployment2.png</p><p>5，这里我使用软件自带的 ssh会话工具，你可以用其他的</p><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310184.png" alt="image-20230309164547948" style="zoom:50%;" /><p>005_ssh_session.png</p><p>6，关于本地项目文件修改后 同步到远程项目的事情，软件会自己同步，有时候可能需要你自己手动同步修改的文件。</p><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310185.png" alt="image-20230309164555198" style="zoom:50%;" /><p>006_sync.png</p><p>7，也可以设置自动同步，即使不设置，clion自己也会将更新的修改同步到远程。</p><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310186.png" alt="image-20230309164604779" style="zoom:50%;" /><p>007_auto_sync.png</p><p>8，然后开始写代码，可以看到头文件不是 mingw的，而是虚拟机 linux上的。</p><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310187.png" alt="image-20230309164611878" style="zoom:50%;" /><p>008_head_file.png</p><p>9，代码提示1</p><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310188.png" alt="image-20230309164618457" style="zoom:50%;" /><p>009_tip1.png</p><p>10，代码提示2</p><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310189.png" alt="image-20230309164627616" style="zoom:50%;" /><p>010_tip2.png</p><p>11，函数参数提示</p><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310190.png" alt="image-20230309164704778" style="zoom:50%;" /><p>011_tip3.png</p><p>12，运行前要到 settings -&gt; cmake 设置dubug的工具链为 remote host。</p><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310191.png" alt="image-20230309164718041" style="zoom:50%;" /><p>012_debug.png</p><p>13，然后可能要重新加载一下当前项目。</p><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310192.png" alt="image-20230309164727810" style="zoom:50%;" /><p>013_reload.png</p><p>14，点击右上角的绿色三角形，执行程序。</p><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310193.png" alt="image-20230309164734795" style="zoom:50%;" /><p>014_cout.png</p><p>=======================================================================================<br> 15，以上就是整个流程，clion可能会在 linux的 /tmp目录生成文件，那些文件会自动删除。</p><p>16，这是 jetbrains关于远程开发的帮助文档，或许有用。</p><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310194.png" alt="image-20230309164742583" style="zoom:50%;" /><p>015_help.png</p><p>至此，结束。</p><p>17，后来发现，本地文件的创建和修改 会自动上传到 linux，但本地删除文件后，linux端不会跟着删除文件，我的解决办法，<br> 右键项目，选择部署同步，然后比对差异文件，选中需要删除的删掉。</p><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310195.png" alt="image-20230309164749881" style="zoom:50%;" /><p>diff0.png</p><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310196.png" alt="image-20230309164756851" style="zoom:50%;" /><p>diff1.png</p><h1 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h1><p><a href="https://blog.csdn.net/qq_43257914/article/details/128409831">cmake超详细入门教程，学不会你捶我~</a></p><p><a href="https://zhuanlan.zhihu.com/p/500002865">CMake 良心教程，教你从入门到入魂</a></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>CLion&amp;Navicat</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>debian安装</title>
    <link href="/2023/03/20/debian%E5%AE%89%E8%A3%85/"/>
    <url>/2023/03/20/debian%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/networkTalent/article/details/123375048">debain安装教程</a></p><p>一 准备工作<br>1.虚拟机软件 VMware 16</p><p><a href="https://www.vmware.com/go/getworkstation-win">https://www.vmware.com/go/getworkstation-win</a></p><p>2.Debian ISO镜像</p><p><a href="https://www.debian.org/download">https://www.debian.org/download</a></p><p>二 创建安装Debain的虚拟机<br>1、打开虚拟软件 vmware workstation16 点击创建虚新的拟机</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/25036d2205b740f5b4ff0c3ab128fc6d.png" alt="img"></p><p>2、选择自定义(高级)选项，然后点击下一步</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/8c110db85161408684d6d12ce466b86f.png" alt="img"></p><p>3.、选择硬件兼容，然后下一步</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/c67a509fcfff4cf1a37e838722d9c21e.png" alt="img"></p><p>4、安装客户机操作系统</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/1115f37b2ba14e5ca894dbcfb0fb9bee.png" alt="img"></p><p> 5、选择需要安装的操作系统，这里选择Linux -&gt; Debian</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/f2c31cc50f264bdca105b91403077ace.png" alt="img"></p><p>6、虚拟机命名</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/7276b5cce24c4eb480788d3336f6d7cc.png" alt="img"></p><p> 7、处理器相关配置</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/c7d8969bd12e4b188736e2b91612acd8.png" alt="img"></p><p> 8、内存配置，如果宿主机内存够用的话，可以适当的给虚拟机内存多一些</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/472cd7ab2eec4289938e3e924a80b99d.png" alt="img"></p><p>9、选择<a href="https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE&spm=1001.2101.3001.7020">虚拟机网络配置</a></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/fce6583363494818b2aefb103c2a5a02.png" alt="img"></p><p> 10、选择I/O控制器类型 按照推荐的即可</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/1002e225d269446caba46c06413c931b.png" alt="img"></p><p>11、选择磁盘类型，按照推荐的即可</p><p> <img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/2422a7c5aae543ecb6ed818e2bdf51b5.png" alt="img"></p><p> 12、创建虚拟磁盘</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/f1ecb29547f04eabb036cedd91cb23e8.png" alt="img"></p><p> 13、为创建的虚拟磁盘分配存储空间，宿主机存储空间充足，可适当分配多一些</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/9a55601c7f8b4867af3254334a84ba2c.png" alt="img"></p><p>14、选择磁盘存储位置</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/1e4e3df114824e8587697704fee4a9cb.png" alt="img"></p><p> 15、配置自定义硬件</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/f34061a819ee421394678b0cd7d3aee2.png" alt="img"></p><p> 16、把提前下载好的ISO镜像，进行相关的选择</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/844a035df8ef44a192f57227491292b2.png" alt="img"></p><p> 17、点击完成即虚拟机创建完成</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/da07529e3dfa40349bc5faf310449e77.png" alt="img"></p><h2 id="三-安装-Debian-11-过程"><a href="#三-安装-Debian-11-过程" class="headerlink" title="三 安装 Debian 11 过程"></a>三 安装 Debian 11 过程</h2><p>1、点击开启之前安装好的虚拟机</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/ad7aacab2b5d478480490e527d541456.png" alt="img"></p><p> 2、把鼠标点击虚拟机空白处，然后使用方向键，选择 图形安装，然后回车</p><p> <img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/5cfc1f93e18d4764b43388d95116aadc.png" alt="img"></p><p> 3、选择安装的语言</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/c49b92e8120042de98c16a8dcb8f3f1b.png" alt="img"></p><p> 4、选择地区</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/f8c8a82b3aaa47f0a8885477710d865c.png" alt="img"></p><p> 5、选择硬盘映射的语言</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/c27a6cb665f14462bced50280aa7a123.png" alt="img"></p><p> 6、开始安装</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/ecf761419b8f4a5d8abf1dbee72cf741.png" alt="img"></p><p> 7、设置主机名</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/c4920d2f71cb4556994bdf372660c01c.png" alt="img"></p><p> 8、配置域名，这里空白即可</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/13c4404c0cd84e51a3f15cb61459f732.png" alt="img"></p><p> 9、为root 用户设置登录密码</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/898e4271943f475c8a73145815fd7c97.png" alt="img"></p><p> 10、创建新用户来替代 root 用户 我们起名叫它 [xiaode]</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/2fb84fe674a64200896310fd52855e4e.png" alt="img"></p><p> 11、</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/8868e11ecb0d4cabba8f310490c7e45c.png" alt="img"></p><p>12、为新创建的 登录账号[xiaode] 创建登录密码</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/b78fb17924b34d8db35dc3c8032497c9.png" alt="img"></p><p> 13、对磁盘进行分区</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/e69795da5874457181a7381df8f8587b.png" alt="img"></p><p> 14、选择需要分区的磁盘</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/b3a2831098154c65b712a93f5a0d9c2b.png" alt="img"></p><p> 15、对磁盘进行分区，选择具体的分区方案</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/4812dc72990244dfae189d277c435577.png" alt="img"></p><p> 16、</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/79e1ea5f0132496fa6685f33360d2432.png" alt="img"></p><p> 17、<a href="https://so.csdn.net/so/search?q=%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA&spm=1001.2101.3001.7020">磁盘分区</a>格式化</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/8617e52ddd7e4df6bf54a0f5ac263100.png" alt="img"></p><p>18、配置软件包管理</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/f53f4e1698334107940f760a0e6259a2.png" alt="img"></p><p> 19、选择Debian 仓库镜像所在的国家</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/efeda4c07af2416686b173c7e9196c36.png" alt="img"></p><p> 20、这里选择的进行地址 为网易163的</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/1c9d25c93ed045d6a117cd10eb6f9ee6.png" alt="img"></p><p> 21、设置代理</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/20b330fa1abe4089abf869b8535474a9.png" alt="img"></p><p> 22、<br><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/f994545ff254453eaf639d0a8e33b68d.png" alt="img"></p><p> 23、选择安装软件</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/0a3b4916ff07404188eb22c5303971ef.png" alt="img"></p><p> 24、安装 GRUB 启动引导器</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/2ef27b2175c6493fa3b9a563c2dc56be.png" alt="img"></p><p>25、安装启动引导器设备</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/7c76a38e1b164203b82f9f718372bb26.png" alt="img"></p><p> 26、软件安装完毕</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/37b593ecce504309a45a71cc42ee5aa0.png" alt="img"></p><p> 27、安装完成 用之前创建的账号[xiaode] 登录系统</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/6c4f740fa30a4bf8b314ada7a0e41cc1.png" alt="img"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/60fd65e6b5df4ec69abc62d77d33b3dd.png" alt="img"></p><p> 28、查看安装版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/os-release <br></code></pre></td></tr></table></figure><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/17c5ec529c634077aca2fc32c9da1846.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>debian安装</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建博客</title>
    <link href="/2023/03/18/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/03/18/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="搭建Hexo博客"><a href="#搭建Hexo博客" class="headerlink" title="搭建Hexo博客"></a>搭建Hexo博客</h1><h2 id="1、安装node-js"><a href="#1、安装node-js" class="headerlink" title="1、安装node.js"></a>1、安装node.js</h2><p><a href="https://blog.csdn.net/qq_40712862/article/details/120231621">安装Nodejs</a></p><h2 id="2、注册github"><a href="#2、注册github" class="headerlink" title="2、注册github"></a>2、注册github</h2><p><a href="https://github.com/">github</a></p><h2 id="3、安装hexo"><a href="#3、安装hexo" class="headerlink" title="3、安装hexo"></a>3、安装hexo</h2><p>新建文件夹，打开cmd，输入命令<code>npm install hexo-cli -g</code><br><code>hexo -v</code>出现版本号即安装成功</p><p>卸载hexo：<br>卸载命令：卸载成功后npm文件夹会消失<code>npm uninstall hexo-cli -g</code></p><p>如果遇到权限问题：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230318105214715.png" alt="image-20230318105214715"></p><p>删除本机电脑用户目录下的.npmrc文件：<code>C:\Users\&#123;当前登录的用户名&#125;\.npmrc</code></p><h2 id="4、生成本地静态网页"><a href="#4、生成本地静态网页" class="headerlink" title="4、生成本地静态网页"></a>4、生成本地静态网页</h2><ul><li><code>hexo init 博客名称</code>初始化</li><li><code>cd 博客名称</code>进入文件夹，<code>npm install</code>安装依赖</li><li><code>hexo g</code>生成静态网页</li><li><code>hexo s</code>打开本地预览</li><li><code>hexo clean</code>，清除缓存文件 db.json 和已生成的静态文件在 ./public/文件夹下</li></ul><h2 id="5、将Hexo部署到Github"><a href="#5、将Hexo部署到Github" class="headerlink" title="5、将Hexo部署到Github"></a>5、将Hexo部署到Github</h2><h3 id="1-Github创建个人仓库"><a href="#1-Github创建个人仓库" class="headerlink" title="1.Github创建个人仓库"></a>1.Github创建个人仓库</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">首先，需要有一个github账号。登上账号后建一个仓库：仓库名为你的用户名.github.<span class="hljs-built_in">io</span>，<br>举例如下：<br>创建一个和你用户名相同的仓库，后面加.github.<span class="hljs-built_in">io</span>，<br>只有这样，将来要部署到GitHub的时候，才会被识别，也就是xxxx.github.<span class="hljs-built_in">io</span>，其中xxx就是你注册GitHub的用户名.<br></code></pre></td></tr></table></figure><h3 id="2-生成ssh添加到Github"><a href="#2-生成ssh添加到Github" class="headerlink" title="2.生成ssh添加到Github"></a>2.生成ssh添加到Github</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">在Github上创建仓库完成之后，需要设置ssh免密登录<br></code></pre></td></tr></table></figure><h3 id="3-打开cmd窗口：执行如下命令："><a href="#3-打开cmd窗口：执行如下命令：" class="headerlink" title="3.打开cmd窗口：执行如下命令："></a>3.打开cmd窗口：执行如下命令：</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;yourname&quot;</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;youremail&quot;</span><br></code></pre></td></tr></table></figure><h3 id="4-接着进入到家目录：C-Users-libinbin，右击打开git-bash-。"><a href="#4-接着进入到家目录：C-Users-libinbin，右击打开git-bash-。" class="headerlink" title="4.接着进入到家目录：C:\Users\libinbin，右击打开git bash 。"></a>4.接着进入到家目录：C:\Users\libinbin，右击打开git bash 。</h3><p>输入：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">ssh-keygen -t rsa -C <span class="hljs-symbol">XXXXXXXXXXXXX@</span>qq.com<br></code></pre></td></tr></table></figure><h3 id="5-接着就会发现C-Users-libinbin下多了一个-ssh目录，打开后有一个公钥，一个私钥。id-rsa-pub是公钥，我们需要打开它，复制里面的内容。"><a href="#5-接着就会发现C-Users-libinbin下多了一个-ssh目录，打开后有一个公钥，一个私钥。id-rsa-pub是公钥，我们需要打开它，复制里面的内容。" class="headerlink" title="5.接着就会发现C:\Users\libinbin下多了一个.ssh目录，打开后有一个公钥，一个私钥。id_rsa.pub是公钥，我们需要打开它，复制里面的内容。"></a>5.接着就会发现C:\Users\libinbin下多了一个.ssh目录，打开后有一个公钥，一个私钥。id_rsa.pub是公钥，我们需要打开它，复制里面的内容。</h3><p>然后进入github：</p><p>点击setings</p><p>进行以下操作</p><p>发现我们需要一个密钥，把我们刚刚复制的密钥粘进去，title随便起</p><p>点击 Add SSH Key</p><h2 id="6-进行部署"><a href="#6-进行部署" class="headerlink" title="6.进行部署"></a>6.进行部署</h2><p>这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 _config.yml，翻到最后，修改为<br>YourgithubName就是你的GitHub账户</p><h3 id="1-修改配置文件"><a href="#1-修改配置文件" class="headerlink" title="1.修改配置文件"></a>1.修改配置文件</h3><p>修改内容：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> git@github.com:你的github名/仓库名.github.io.git<br><span class="hljs-symbol">  branch:</span> main（master）<br></code></pre></td></tr></table></figure><h3 id="2-找到自己的博客路径打开cmd"><a href="#2-找到自己的博客路径打开cmd" class="headerlink" title="2.找到自己的博客路径打开cmd"></a>2.找到自己的博客路径打开cmd</h3><p>这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><h3 id="3-然后依次执行以下命令："><a href="#3-然后依次执行以下命令：" class="headerlink" title="3.然后依次执行以下命令："></a>3.然后依次执行以下命令：</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog">hexo c   #清除缓存文件 db<span class="hljs-variable">.json</span> 和已生成的静态文件 public<br>hexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo <span class="hljs-keyword">generate</span> 的缩写)<br>hexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)注意deploy时会让输个yes<br></code></pre></td></tr></table></figure><p>最后回到github上查看自己的仓库：</p><p>这就表示上传成功。</p><p>现在就可以使用xxx.github.io来访问你的博客啦</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>搭建博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>胡桃真好看</title>
    <link href="/2023/03/18/%E8%83%A1%E6%A1%83/"/>
    <url>/2023/03/18/%E8%83%A1%E6%A1%83/</url>
    
    <content type="html"><![CDATA[<h1 id="胡桃真好看"><a href="#胡桃真好看" class="headerlink" title="胡桃真好看"></a>胡桃真好看</h1><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/hutao.jpg" alt="hutao"></p>]]></content>
    
    
    <categories>
      
      <category>原神</category>
      
      <category>图片</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
