<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>nacos集群搭建</title>
    <link href="/2023/03/28/nacos%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <url>/2023/03/28/nacos%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Nacos集群搭建"><a href="#Nacos集群搭建" class="headerlink" title="Nacos集群搭建"></a>Nacos集群搭建</h1><h1 id="1-集群结构图"><a href="#1-集群结构图" class="headerlink" title="1.集群结构图"></a>1.集群结构图</h1><p>官方给出的Nacos集群图：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210409210621117.png" alt="image-20210409210621117"></p><p>其中包含3个nacos节点，然后一个负载均衡器代理3个Nacos。这里负载均衡器可以使用nginx。</p><p>我们计划的集群结构：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210409211355037.png" alt="image-20210409211355037"></p><p>三个nacos节点的地址：</p><table><thead><tr><th>节点</th><th>ip</th><th>port</th></tr></thead><tbody><tr><td>nacos1</td><td>192.168.150.1</td><td>8845</td></tr><tr><td>nacos2</td><td>192.168.150.1</td><td>8846</td></tr><tr><td>nacos3</td><td>192.168.150.1</td><td>8847</td></tr></tbody></table><h1 id="2-搭建集群"><a href="#2-搭建集群" class="headerlink" title="2.搭建集群"></a>2.搭建集群</h1><p>搭建集群的基本步骤：</p><ul><li>搭建数据库，初始化数据库表结构</li><li>下载nacos安装包</li><li>配置nacos</li><li>启动nacos集群</li><li>nginx反向代理</li></ul><h2 id="2-1-初始化数据库"><a href="#2-1-初始化数据库" class="headerlink" title="2.1.初始化数据库"></a>2.1.初始化数据库</h2><p>Nacos默认数据存储在内嵌数据库Derby中，不属于生产可用的数据库。</p><p>官方推荐的最佳实践是使用带有主从的高可用数据库集群，主从模式的高可用数据库可以参考<strong>传智教育</strong>的后续高手课程。</p><p>这里我们以单点的数据库为例来讲解。</p><p>首先新建一个数据库，命名为nacos，而后导入下面的SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `config_info` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;id&#x27;</span>,<br>  `data_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;data_id&#x27;</span>,<br>  `group_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `content` longtext <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;content&#x27;</span>,<br>  `md5` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;md5&#x27;</span>,<br>  `gmt_create` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>  `gmt_modified` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;修改时间&#x27;</span>,<br>  `src_user` text COMMENT <span class="hljs-string">&#x27;source user&#x27;</span>,<br>  `src_ip` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;source ip&#x27;</span>,<br>  `app_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `tenant_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;租户字段&#x27;</span>,<br>  `c_desc` <span class="hljs-type">varchar</span>(<span class="hljs-number">256</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `c_use` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `effect` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `type` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `c_schema` text,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8_bin COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;config_info&#x27;</span>;<br><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-comment">/*   数据库全名 = nacos_config   */</span><br><span class="hljs-comment">/*   表名称 = config_info_aggr   */</span><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `config_info_aggr` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;id&#x27;</span>,<br>  `data_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;data_id&#x27;</span>,<br>  `group_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;group_id&#x27;</span>,<br>  `datum_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;datum_id&#x27;</span>,<br>  `content` longtext <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;内容&#x27;</span>,<br>  `gmt_modified` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;修改时间&#x27;</span>,<br>  `app_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `tenant_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;租户字段&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8_bin COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;增加租户字段&#x27;</span>;<br><br><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-comment">/*   数据库全名 = nacos_config   */</span><br><span class="hljs-comment">/*   表名称 = config_info_beta   */</span><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `config_info_beta` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;id&#x27;</span>,<br>  `data_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;data_id&#x27;</span>,<br>  `group_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;group_id&#x27;</span>,<br>  `app_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;app_name&#x27;</span>,<br>  `content` longtext <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;content&#x27;</span>,<br>  `beta_ips` <span class="hljs-type">varchar</span>(<span class="hljs-number">1024</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;betaIps&#x27;</span>,<br>  `md5` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;md5&#x27;</span>,<br>  `gmt_create` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>  `gmt_modified` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;修改时间&#x27;</span>,<br>  `src_user` text COMMENT <span class="hljs-string">&#x27;source user&#x27;</span>,<br>  `src_ip` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;source ip&#x27;</span>,<br>  `tenant_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;租户字段&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8_bin COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;config_info_beta&#x27;</span>;<br><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-comment">/*   数据库全名 = nacos_config   */</span><br><span class="hljs-comment">/*   表名称 = config_info_tag   */</span><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `config_info_tag` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;id&#x27;</span>,<br>  `data_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;data_id&#x27;</span>,<br>  `group_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;group_id&#x27;</span>,<br>  `tenant_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;tenant_id&#x27;</span>,<br>  `tag_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;tag_id&#x27;</span>,<br>  `app_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;app_name&#x27;</span>,<br>  `content` longtext <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;content&#x27;</span>,<br>  `md5` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;md5&#x27;</span>,<br>  `gmt_create` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>  `gmt_modified` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;修改时间&#x27;</span>,<br>  `src_user` text COMMENT <span class="hljs-string">&#x27;source user&#x27;</span>,<br>  `src_ip` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;source ip&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8_bin COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;config_info_tag&#x27;</span>;<br><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-comment">/*   数据库全名 = nacos_config   */</span><br><span class="hljs-comment">/*   表名称 = config_tags_relation   */</span><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `config_tags_relation` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;id&#x27;</span>,<br>  `tag_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;tag_name&#x27;</span>,<br>  `tag_type` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;tag_type&#x27;</span>,<br>  `data_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;data_id&#x27;</span>,<br>  `group_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;group_id&#x27;</span>,<br>  `tenant_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;tenant_id&#x27;</span>,<br>  `nid` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`nid`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`),<br>  KEY `idx_tenant_id` (`tenant_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8_bin COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;config_tag_relation&#x27;</span>;<br><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-comment">/*   数据库全名 = nacos_config   */</span><br><span class="hljs-comment">/*   表名称 = group_capacity   */</span><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `group_capacity` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;主键ID&#x27;</span>,<br>  `group_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;Group ID，空字符表示整个集群&#x27;</span>,<br>  `quota` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;配额，0表示使用默认值&#x27;</span>,<br>  `usage` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;使用量&#x27;</span>,<br>  `max_size` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,<br>  `max_aggr_count` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;聚合子配置最大个数，，0表示使用默认值&#x27;</span>,<br>  `max_aggr_size` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,<br>  `max_history_count` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;最大变更历史数量&#x27;</span>,<br>  `gmt_create` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>  `gmt_modified` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;修改时间&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `uk_group_id` (`group_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8_bin COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;集群、各Group容量信息表&#x27;</span>;<br><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-comment">/*   数据库全名 = nacos_config   */</span><br><span class="hljs-comment">/*   表名称 = his_config_info   */</span><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `his_config_info` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">64</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `nid` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `data_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `group_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `app_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;app_name&#x27;</span>,<br>  `content` longtext <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `md5` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `gmt_create` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>  `gmt_modified` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>  `src_user` text,<br>  `src_ip` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `op_type` <span class="hljs-type">char</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `tenant_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;租户字段&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`nid`),<br>  KEY `idx_gmt_create` (`gmt_create`),<br>  KEY `idx_gmt_modified` (`gmt_modified`),<br>  KEY `idx_did` (`data_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8_bin COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;多租户改造&#x27;</span>;<br><br><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-comment">/*   数据库全名 = nacos_config   */</span><br><span class="hljs-comment">/*   表名称 = tenant_capacity   */</span><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `tenant_capacity` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;主键ID&#x27;</span>,<br>  `tenant_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;Tenant ID&#x27;</span>,<br>  `quota` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;配额，0表示使用默认值&#x27;</span>,<br>  `usage` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;使用量&#x27;</span>,<br>  `max_size` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,<br>  `max_aggr_count` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;聚合子配置最大个数&#x27;</span>,<br>  `max_aggr_size` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,<br>  `max_history_count` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;最大变更历史数量&#x27;</span>,<br>  `gmt_create` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>  `gmt_modified` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;修改时间&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `uk_tenant_id` (`tenant_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8_bin COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;租户容量信息表&#x27;</span>;<br><br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `tenant_info` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;id&#x27;</span>,<br>  `kp` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;kp&#x27;</span>,<br>  `tenant_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;tenant_id&#x27;</span>,<br>  `tenant_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;tenant_name&#x27;</span>,<br>  `tenant_desc` <span class="hljs-type">varchar</span>(<span class="hljs-number">256</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;tenant_desc&#x27;</span>,<br>  `create_source` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;create_source&#x27;</span>,<br>  `gmt_create` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>  `gmt_modified` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;修改时间&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`),<br>  KEY `idx_tenant_id` (`tenant_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8_bin COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;tenant_info&#x27;</span>;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `users` (<br>`username` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>`password` <span class="hljs-type">varchar</span>(<span class="hljs-number">500</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`enabled` <span class="hljs-type">boolean</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br>);<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `roles` (<br>`username` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`role` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-keyword">UNIQUE</span> INDEX `idx_user_role` (`username` <span class="hljs-keyword">ASC</span>, `role` <span class="hljs-keyword">ASC</span>) <span class="hljs-keyword">USING</span> BTREE<br>);<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `permissions` (<br>    `role` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `resource` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `action` <span class="hljs-type">varchar</span>(<span class="hljs-number">8</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">UNIQUE</span> INDEX `uk_role_permission` (`role`,`resource`,`action`) <span class="hljs-keyword">USING</span> BTREE<br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> users (username, password, enabled) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;nacos&#x27;</span>, <span class="hljs-string">&#x27;$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#x27;</span>, <span class="hljs-literal">TRUE</span>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> roles (username, role) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;nacos&#x27;</span>, <span class="hljs-string">&#x27;ROLE_ADMIN&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="2-2-下载nacos"><a href="#2-2-下载nacos" class="headerlink" title="2.2.下载nacos"></a>2.2.下载nacos</h2><p>nacos在GitHub上有下载地址：<a href="https://github.com/alibaba/nacos/tags%EF%BC%8C%E5%8F%AF%E4%BB%A5%E9%80%89%E6%8B%A9%E4%BB%BB%E6%84%8F%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD%E3%80%82">https://github.com/alibaba/nacos/tags，可以选择任意版本下载。</a></p><p>本例中才用1.4.1版本：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210409212119411.png" alt="image-20210409212119411"></p><h2 id="2-3-配置Nacos"><a href="#2-3-配置Nacos" class="headerlink" title="2.3.配置Nacos"></a>2.3.配置Nacos</h2><p>将这个包解压到任意非中文目录下，如图：</p><p><img src="D:\workspace\java学习\17、微服务开发框架SpringCloud+RabbitMQ+Docker+Redis+搜索+分布式史上最全面的微服务全技术栈课程\day02-SpringCloud02\资料\assets\image-20210402161843337.png" alt="image-20210402161843337"></p><p>目录说明：</p><ul><li>bin：启动脚本</li><li>conf：配置文件</li></ul><p>进入nacos的conf目录，修改配置文件cluster.conf.example，重命名为cluster.conf：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210409212459292.png" alt="image-20210409212459292"></p><p>然后添加内容：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:8845</span><br><span class="hljs-number">127.0.0.1</span>.<span class="hljs-number">8846</span><br><span class="hljs-number">127.0.0.1</span>.<span class="hljs-number">8847</span><br></code></pre></td></tr></table></figure><p>然后修改application.properties文件，添加数据库配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.datasource.platform</span>=<span class="hljs-string">mysql</span><br><br><span class="hljs-attr">db.num</span>=<span class="hljs-string">1</span><br><br><span class="hljs-attr">db.url.0</span>=<span class="hljs-string">jdbc:mysql://127.0.0.1:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span><br><span class="hljs-attr">db.user.0</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">db.password.0</span>=<span class="hljs-string">123</span><br></code></pre></td></tr></table></figure><h2 id="2-4-启动"><a href="#2-4-启动" class="headerlink" title="2.4.启动"></a>2.4.启动</h2><p>将nacos文件夹复制三份，分别命名为：nacos1、nacos2、nacos3</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210409213335538.png" alt="image-20210409213335538"> </p><p>然后分别修改三个文件夹中的application.properties，</p><p>nacos1:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">8845</span><br></code></pre></td></tr></table></figure><p>nacos2:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">8846</span><br></code></pre></td></tr></table></figure><p>nacos3:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">8847</span><br></code></pre></td></tr></table></figure><p>然后分别启动三个nacos节点：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">startup.<span class="hljs-built_in">cmd</span><br></code></pre></td></tr></table></figure><h2 id="2-5-nginx反向代理"><a href="#2-5-nginx反向代理" class="headerlink" title="2.5.nginx反向代理"></a>2.5.nginx反向代理</h2><p>找到课前资料提供的nginx安装包： </p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210410103253355.png" alt="image-20210410103253355"> </p><p>解压到任意非中文目录下：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210410103322874.png" alt="image-20210410103322874"> </p><p>修改conf/nginx.conf文件，配置如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> nacos-cluster &#123;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8845</span>;<br><span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8846</span>;<br><span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8847</span>;<br>&#125;<br><br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span>  localhost;<br><br>    <span class="hljs-section">location</span> /nacos &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://nacos-cluster;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而后在浏览器访问：<a href="http://localhost/nacos%E5%8D%B3%E5%8F%AF%E3%80%82">http://localhost/nacos即可。</a></p><p>代码中application.yml文件配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:80</span> <span class="hljs-comment"># Nacos地址</span><br></code></pre></td></tr></table></figure><h2 id="2-6-优化"><a href="#2-6-优化" class="headerlink" title="2.6.优化"></a>2.6.优化</h2><ul><li><p>实际部署时，需要给做反向代理的nginx服务器设置一个域名，这样后续如果有服务器迁移nacos的客户端也无需更改配置.</p></li><li><p>Nacos的各个节点应该部署到多个不同服务器，做好容灾和隔离</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>JAVA学习</category>
      
      <category>springCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nacos安装指南</title>
    <link href="/2023/03/28/Nacos%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/"/>
    <url>/2023/03/28/Nacos%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="Nacos安装指南"><a href="#Nacos安装指南" class="headerlink" title="Nacos安装指南"></a>Nacos安装指南</h1><h1 id="1-Windows安装"><a href="#1-Windows安装" class="headerlink" title="1.Windows安装"></a>1.Windows安装</h1><p>开发阶段采用单机安装即可。</p><h2 id="1-1-下载安装包"><a href="#1-1-下载安装包" class="headerlink" title="1.1.下载安装包"></a>1.1.下载安装包</h2><p>在Nacos的GitHub页面，提供有下载链接，可以下载编译好的Nacos服务端或者源代码：</p><p>GitHub主页：<a href="https://github.com/alibaba/nacos">https://github.com/alibaba/nacos</a></p><p>GitHub的Release下载页：<a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a></p><p>如图：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210402161102887.png" alt="image-20210402161102887"></p><p>本课程采用1.4.1.版本的Nacos，课前资料已经准备了安装包：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210402161130261.png" alt="image-20210402161130261"></p><p>windows版本使用<code>nacos-server-1.4.1.zip</code>包即可。</p><h2 id="1-2-解压"><a href="#1-2-解压" class="headerlink" title="1.2.解压"></a>1.2.解压</h2><p>将这个包解压到任意非中文目录下，如图：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210402161843337.png" alt="image-20210402161843337"></p><p>目录说明：</p><ul><li>bin：启动脚本</li><li>conf：配置文件</li></ul><h2 id="1-3-端口配置"><a href="#1-3-端口配置" class="headerlink" title="1.3.端口配置"></a>1.3.端口配置</h2><p>Nacos的默认端口是8848，如果你电脑上的其它进程占用了8848端口，请先尝试关闭该进程。</p><p><strong>如果无法关闭占用8848端口的进程</strong>，也可以进入nacos的conf目录，修改配置文件中的端口：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210402162008280.png" alt="image-20210402162008280"></p><p>修改其中的内容：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210402162251093.png" alt="image-20210402162251093"></p><h2 id="1-4-启动"><a href="#1-4-启动" class="headerlink" title="1.4.启动"></a>1.4.启动</h2><p>启动非常简单，进入bin目录，结构如下：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210402162350977.png" alt="image-20210402162350977"></p><p>然后执行命令即可：</p><ul><li><p>windows命令：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">startup.<span class="hljs-built_in">cmd</span> -m standalone<br></code></pre></td></tr></table></figure></li></ul><p>执行后的效果如图：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210402162526774.png" alt="image-20210402162526774"></p><h2 id="1-5-访问"><a href="#1-5-访问" class="headerlink" title="1.5.访问"></a>1.5.访问</h2><p>在浏览器输入地址：<a href="http://127.0.0.1:8848/nacos%E5%8D%B3%E5%8F%AF%EF%BC%9A">http://127.0.0.1:8848/nacos即可：</a></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210402162630427.png" alt="image-20210402162630427"></p><p>默认的账号和密码都是nacos，进入后：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210402162709515.png" alt="image-20210402162709515"></p><h1 id="2-Linux安装"><a href="#2-Linux安装" class="headerlink" title="2.Linux安装"></a>2.Linux安装</h1><p>Linux或者Mac安装方式与Windows类似。</p><h2 id="2-1-安装JDK"><a href="#2-1-安装JDK" class="headerlink" title="2.1.安装JDK"></a>2.1.安装JDK</h2><p>Nacos依赖于JDK运行，索引Linux上也需要安装JDK才行。</p><p>上传jdk安装包：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210402172334810.png" alt="image-20210402172334810"></p><p>上传到某个目录，例如：<code>/usr/local/</code></p><p>然后解压缩：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -xvf jdk-8u144-linux-x64.tar.gz<br></code></pre></td></tr></table></figure><p>然后重命名为java</p><p>配置环境变量：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">export</span> JAVA_HOME=/usr/local/java<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$JAVA_HOME</span>/bin<br></code></pre></td></tr></table></figure><p>设置环境变量：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure><h2 id="2-2-上传安装包"><a href="#2-2-上传安装包" class="headerlink" title="2.2.上传安装包"></a>2.2.上传安装包</h2><p>如图：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210402161102887.png" alt="image-20210402161102887"></p><p>也可以直接使用课前资料中的tar.gz：</p><p><img src="D:\workspace\java学习\17、微服务开发框架SpringCloud+RabbitMQ+Docker+Redis+搜索+分布式史上最全面的微服务全技术栈课程\day01-SpringCloud01\资料\assets\image-20210402161130261.png" alt="image-20210402161130261"></p><p>上传到Linux服务器的某个目录，例如<code>/usr/local/src</code>目录下：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210402163715580.png" alt="image-20210402163715580"></p><h2 id="2-3-解压"><a href="#2-3-解压" class="headerlink" title="2.3.解压"></a>2.3.解压</h2><p>命令解压缩安装包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -xvf nacos-server-1.4.1.tar.gz<br></code></pre></td></tr></table></figure><p>然后删除安装包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">rm</span> -rf nacos-server-1.4.1.tar.gz<br></code></pre></td></tr></table></figure><p>目录中最终样式：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210402163858429.png" alt="image-20210402163858429"></p><p>目录内部：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210402164414827.png" alt="image-20210402164414827"></p><h2 id="2-4-端口配置"><a href="#2-4-端口配置" class="headerlink" title="2.4.端口配置"></a>2.4.端口配置</h2><p>与windows中类似</p><h2 id="2-5-启动"><a href="#2-5-启动" class="headerlink" title="2.5.启动"></a>2.5.启动</h2><p>在nacos/bin目录中，输入命令启动Nacos：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sh startup.sh -m standalone<br></code></pre></td></tr></table></figure><h1 id="3-Nacos的依赖"><a href="#3-Nacos的依赖" class="headerlink" title="3.Nacos的依赖"></a>3.Nacos的依赖</h1><p>父工程：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- nacos客户端依赖包 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JAVA学习</category>
      
      <category>springCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springCloud</title>
    <link href="/2023/03/28/springCloud/"/>
    <url>/2023/03/28/springCloud/</url>
    
    <content type="html"><![CDATA[<p>来源：黑马资料</p><h1 id="SpringCloud01"><a href="#SpringCloud01" class="headerlink" title="SpringCloud01"></a>SpringCloud01</h1><h2 id="0-初识"><a href="#0-初识" class="headerlink" title="0 初识"></a>0 初识</h2><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230328182949123.png" alt="image-20230328182949123"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230328183103245.png" alt="image-20230328183103245"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230328183137912.png" alt="image-20230328183137912"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230328183228218.png" alt="image-20230328183228218"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230328183300614.png" alt="image-20230328183300614"></p><h2 id="1-认识微服务"><a href="#1-认识微服务" class="headerlink" title="1.认识微服务"></a>1.认识微服务</h2><p>随着互联网行业的发展，对服务的要求也越来越高，服务架构也从单体架构逐渐演变为现在流行的微服务架构。这些架构之间有怎样的差别呢？</p><h2 id="1-0-学习目标"><a href="#1-0-学习目标" class="headerlink" title="1.0.学习目标"></a>1.0.学习目标</h2><p>了解微服务架构的优缺点</p><h2 id="1-1-单体架构"><a href="#1-1-单体架构" class="headerlink" title="1.1.单体架构"></a>1.1.单体架构</h2><p><strong>单体架构</strong>：将业务的所有功能集中在一个项目中开发，打成一个包部署。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713202807818.png" alt="image-20210713202807818"></p><p>单体架构的优缺点如下：</p><p><strong>优点：</strong></p><ul><li>架构简单</li><li>部署成本低</li></ul><p><strong>缺点：</strong></p><ul><li>耦合度高（维护困难、升级困难）</li></ul><h2 id="1-2-分布式架构"><a href="#1-2-分布式架构" class="headerlink" title="1.2.分布式架构"></a>1.2.分布式架构</h2><p><strong>分布式架构</strong>：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713203124797.png" alt="image-20210713203124797"></p><p>分布式架构的优缺点：</p><p><strong>优点：</strong></p><ul><li>降低服务耦合</li><li>有利于服务升级和拓展</li></ul><p><strong>缺点：</strong></p><ul><li>服务调用关系错综复杂</li></ul><p>分布式架构虽然降低了服务耦合，但是服务拆分时也有很多问题需要思考：</p><ul><li>服务拆分的粒度如何界定？</li><li>服务之间如何调用？</li><li>服务的调用关系如何管理？</li></ul><p>人们需要制定一套行之有效的标准来约束分布式架构。</p><h2 id="1-3-微服务"><a href="#1-3-微服务" class="headerlink" title="1.3.微服务"></a>1.3.微服务</h2><p>微服务的架构特征：</p><ul><li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责</li><li>自治：团队独立、技术独立、数据独立，独立部署和交付</li><li>面向服务：服务提供统一标准的接口，与语言和技术无关</li><li>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</li></ul><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713203753373.png" alt="image-20210713203753373"></p><p>微服务的上述特性其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。</p><p>因此，可以认为<strong>微服务</strong>是一种经过良好架构设计的<strong>分布式架构方案</strong> 。</p><p>但方案该怎么落地？选用什么样的技术栈？全球的互联网公司都在积极尝试自己的微服务落地方案。</p><p>其中在Java领域最引人注目的就是SpringCloud提供的方案了。</p><h2 id="1-4-SpringCloud"><a href="#1-4-SpringCloud" class="headerlink" title="1.4.SpringCloud"></a>1.4.SpringCloud</h2><p>SpringCloud是目前国内使用最广泛的微服务框架。官网地址：<a href="https://spring.io/projects/spring-cloud%E3%80%82">https://spring.io/projects/spring-cloud。</a></p><p>SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验。</p><p>其中常见的组件包括：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713204155887.png" alt="image-20210713204155887"></p><p>另外，SpringCloud底层是依赖于SpringBoot的，并且有版本的兼容关系，如下：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713205003790.png" alt="image-20210713205003790"></p><p>我们课堂学习的版本是 Hoxton.SR10，因此对应的SpringBoot版本是2.3.x版本。</p><h2 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5.总结"></a>1.5.总结</h2><ul><li><p>单体架构：简单方便，高度耦合，扩展性差，适合小型项目。例如：学生管理系统</p></li><li><p>分布式架构：松耦合，扩展性好，但架构复杂，难度大。适合大型互联网项目，例如：京东、淘宝</p></li><li><p>微服务：一种良好的分布式架构方案</p><p>①优点：拆分粒度更小、服务更独立、耦合度更低</p><p>②缺点：架构非常复杂，运维、监控、部署难度提高</p></li><li><p>SpringCloud是微服务架构的一站式解决方案，集成了各种优秀微服务功能组件</p></li></ul><h1 id="2-服务拆分和远程调用"><a href="#2-服务拆分和远程调用" class="headerlink" title="2.服务拆分和远程调用"></a>2.服务拆分和远程调用</h1><p>任何分布式架构都离不开服务的拆分，微服务也是一样。</p><h2 id="2-1-服务拆分原则"><a href="#2-1-服务拆分原则" class="headerlink" title="2.1.服务拆分原则"></a>2.1.服务拆分原则</h2><p>这里我总结了微服务拆分时的几个原则：</p><ul><li>不同微服务，不要重复开发相同业务</li><li>微服务数据独立，不要访问其它微服务的数据库</li><li>微服务可以将自己的业务暴露为接口，供其它微服务调用</li></ul><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713210800950.png" alt="image-20210713210800950"></p><h2 id="2-2-服务拆分示例"><a href="#2-2-服务拆分示例" class="headerlink" title="2.2.服务拆分示例"></a>2.2.服务拆分示例</h2><p>以课前资料中的微服务cloud-demo为例，其结构如下：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713211009593.png" alt="image-20210713211009593"></p><p>cloud-demo：父工程，管理依赖</p><ul><li>order-service：订单微服务，负责订单相关业务</li><li>user-service：用户微服务，负责用户相关业务</li></ul><p>要求：</p><ul><li>订单微服务和用户微服务都必须有各自的数据库，相互独立</li><li>订单服务和用户服务都对外暴露Restful的接口</li><li>订单服务如果需要查询用户信息，只能调用用户服务的Restful接口，不能查询用户数据库</li></ul><h3 id="2-2-1-导入Sql语句"><a href="#2-2-1-导入Sql语句" class="headerlink" title="2.2.1.导入Sql语句"></a>2.2.1.导入Sql语句</h3><p>首先，将课前资料提供的<code>cloud-order.sql</code>和<code>cloud-user.sql</code>导入到mysql中：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713211417049.png" alt="image-20210713211417049"></p><p>cloud-user表中初始数据如下：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713211550169.png" alt="image-20210713211550169"></p><p>cloud-order表中初始数据如下：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713211657319.png" alt="image-20210713211657319"></p><p>cloud-order表中持有cloud-user表中的id字段。</p><h3 id="2-2-2-导入demo工程"><a href="#2-2-2-导入demo工程" class="headerlink" title="2.2.2.导入demo工程"></a>2.2.2.导入demo工程</h3><p>用IDEA导入课前资料提供的Demo：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713211814094.png" alt="image-20210713211814094"></p><p>项目结构如下：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713212656887.png" alt="image-20210713212656887"></p><p>导入后，会在IDEA右下角出现弹窗：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713212349272.png" alt="image-20210713212349272"></p><p>点击弹窗，然后按下图选择：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713212336185.png" alt="image-20210713212336185"></p><p>会出现这样的菜单：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713212513324.png" alt="image-20210713212513324"></p><p>配置下项目使用的JDK：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713220736408.png" alt="image-20210713220736408"></p><h2 id="2-3-实现远程调用案例"><a href="#2-3-实现远程调用案例" class="headerlink" title="2.3.实现远程调用案例"></a>2.3.实现远程调用案例</h2><p>在order-service服务中，有一个根据id查询订单的接口：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713212749575.png" alt="image-20210713212749575"></p><p>根据id查询订单，返回值是Order对象，如图：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713212901725.png" alt="image-20210713212901725"></p><p>其中的user为null</p><p>在user-service中有一个根据id查询用户的接口：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713213146089.png" alt="image-20210713213146089"></p><p>查询的结果如图：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713213213075.png" alt="image-20210713213213075"></p><h3 id="2-3-1-案例需求："><a href="#2-3-1-案例需求：" class="headerlink" title="2.3.1.案例需求："></a>2.3.1.案例需求：</h3><p>修改order-service中的根据id查询订单业务，要求在查询订单的同时，根据订单中包含的userId查询出用户信息，一起返回。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713213312278.png" alt="image-20210713213312278"></p><p>因此，我们需要在order-service中 向user-service发起一个http的请求，调用<a href="http://localhost:8081/user/%7BuserId%7D%E8%BF%99%E4%B8%AA%E6%8E%A5%E5%8F%A3%E3%80%82">http://localhost:8081/user/{userId}这个接口。</a></p><p>大概的步骤是这样的：</p><ul><li>注册一个RestTemplate的实例到Spring容器</li><li>修改order-service服务中的OrderService类中的queryOrderById方法，根据Order对象中的userId查询User</li><li>将查询的User填充到Order对象，一起返回</li></ul><h3 id="2-3-2-注册RestTemplate"><a href="#2-3-2-注册RestTemplate" class="headerlink" title="2.3.2.注册RestTemplate"></a>2.3.2.注册RestTemplate</h3><p>首先，我们在order-service服务中的OrderApplication启动类中，注册RestTemplate实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.order;<br><br><span class="hljs-keyword">import</span> org.mybatis.spring.annotation.MapperScan;<br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.web.client.RestTemplate;<br><br><span class="hljs-meta">@MapperScan(&quot;cn.itcast.order.mapper&quot;)</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(OrderApplication.class, args);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title function_">restTemplate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-3-实现远程调用"><a href="#2-3-3-实现远程调用" class="headerlink" title="2.3.3.实现远程调用"></a>2.3.3.实现远程调用</h3><p>修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713213959569.png" alt="image-20210713213959569"></p><h2 id="2-4-提供者与消费者"><a href="#2-4-提供者与消费者" class="headerlink" title="2.4.提供者与消费者"></a>2.4.提供者与消费者</h2><p>在服务调用关系中，会有两个不同的角色：</p><p><strong>服务提供者</strong>：一次业务中，被其它微服务调用的服务。（提供接口给其它微服务）</p><p><strong>服务消费者</strong>：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口）</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713214404481.png" alt="image-20210713214404481"></p><p>但是，服务提供者与服务消费者的角色并不是绝对的，而是相对于业务而言。</p><p>如果服务A调用了服务B，而服务B又调用了服务C，服务B的角色是什么？</p><ul><li>对于A调用B的业务而言：A是服务消费者，B是服务提供者</li><li>对于B调用C的业务而言：B是服务消费者，C是服务提供者</li></ul><p>因此，服务B既可以是服务提供者，也可以是服务消费者。</p><h1 id="3-Eureka注册中心"><a href="#3-Eureka注册中心" class="headerlink" title="3.Eureka注册中心"></a>3.Eureka注册中心</h1><p>假如我们的服务提供者user-service部署了多个实例，如图：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713214925388.png" alt="image-20210713214925388"></p><p>大家思考几个问题：</p><ul><li>order-service在发起远程调用的时候，该如何得知user-service实例的ip地址和端口？</li><li>有多个user-service实例地址，order-service调用时该如何选择？</li><li>order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</li></ul><h2 id="3-1-Eureka的结构和作用"><a href="#3-1-Eureka的结构和作用" class="headerlink" title="3.1.Eureka的结构和作用"></a>3.1.Eureka的结构和作用</h2><p>这些问题都需要利用SpringCloud中的注册中心来解决，其中最广为人知的注册中心就是Eureka，其结构如下：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713220104956.png" alt="image-20210713220104956"></p><p>回答之前的各个问题。</p><p>问题1：order-service如何得知user-service实例地址？</p><p>获取地址信息的流程如下：</p><ul><li>user-service服务实例启动后，将自己的信息注册到eureka-server（Eureka服务端）。这个叫服务注册</li><li>eureka-server保存服务名称到服务实例地址列表的映射关系</li><li>order-service根据服务名称，拉取实例地址列表。这个叫服务发现或服务拉取</li></ul><p>问题2：order-service如何从多个user-service实例中选择具体的实例？</p><ul><li>order-service从实例列表中利用负载均衡算法选中一个实例地址</li><li>向该实例地址发起远程调用</li></ul><p>问题3：order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</p><ul><li>user-service会每隔一段时间（默认30秒）向eureka-server发起请求，报告自己状态，称为心跳</li><li>当超过一定时间没有发送心跳时，eureka-server会认为微服务实例故障，将该实例从服务列表中剔除</li><li>order-service拉取服务时，就能将故障实例排除了</li></ul><blockquote><p>注意：一个微服务，既可以是服务提供者，又可以是服务消费者，因此eureka将服务注册、服务发现等功能统一封装到了eureka-client端</p></blockquote><p>因此，接下来我们动手实践的步骤包括：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713220509769.png" alt="image-20210713220509769"></p><h2 id="3-2-搭建eureka-server"><a href="#3-2-搭建eureka-server" class="headerlink" title="3.2.搭建eureka-server"></a>3.2.搭建eureka-server</h2><p>首先大家注册中心服务端：eureka-server，这必须是一个独立的微服务</p><h3 id="3-2-1-创建eureka-server服务"><a href="#3-2-1-创建eureka-server服务" class="headerlink" title="3.2.1.创建eureka-server服务"></a>3.2.1.创建eureka-server服务</h3><p>在cloud-demo父工程下，创建一个子模块：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713220605881.png" alt="image-20210713220605881"></p><p>填写模块信息：</p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713220857396.png" alt="image-20210713220857396" style="zoom:50%;" /><p>然后填写服务信息：</p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713221339022.png" alt="image-20210713221339022" style="zoom:50%;" /><h3 id="3-2-2-引入eureka依赖"><a href="#3-2-2-引入eureka依赖" class="headerlink" title="3.2.2.引入eureka依赖"></a>3.2.2.引入eureka依赖</h3><p>引入SpringCloud为eureka提供的starter依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-2-3-编写启动类"><a href="#3-2-3-编写启动类" class="headerlink" title="3.2.3.编写启动类"></a>3.2.3.编写启动类</h3><p>给eureka-server服务编写一个启动类，一定要添加一个@EnableEurekaServer注解，开启eureka的注册中心功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.eureka;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableEurekaServer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EurekaApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(EurekaApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-4-编写配置文件"><a href="#3-2-4-编写配置文件" class="headerlink" title="3.2.4.编写配置文件"></a>3.2.4.编写配置文件</h3><p>编写一个application.yml文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">10086</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-server</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span> <br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka</span><br></code></pre></td></tr></table></figure><h3 id="3-2-5-启动服务"><a href="#3-2-5-启动服务" class="headerlink" title="3.2.5.启动服务"></a>3.2.5.启动服务</h3><p>启动微服务，然后在浏览器访问：<a href="http://127.0.0.1:10086/">http://127.0.0.1:10086</a></p><p>看到下面结果应该是成功了：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713222157190.png" alt="image-20210713222157190"></p><h2 id="3-3-服务注册"><a href="#3-3-服务注册" class="headerlink" title="3.3.服务注册"></a>3.3.服务注册</h2><p>下面，我们将user-service注册到eureka-server中去。</p><h3 id="1）引入依赖"><a href="#1）引入依赖" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>在user-service的pom文件中，引入下面的eureka-client依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2）配置文件"><a href="#2）配置文件" class="headerlink" title="2）配置文件"></a>2）配置文件</h3><p>在user-service中，修改application.yml文件，添加服务名称、eureka地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">userservice</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka</span><br></code></pre></td></tr></table></figure><h3 id="3）启动多个user-service实例"><a href="#3）启动多个user-service实例" class="headerlink" title="3）启动多个user-service实例"></a>3）启动多个user-service实例</h3><p>为了演示一个服务有多个实例的场景，我们添加一个SpringBoot的启动配置，再启动一个user-service。</p><p>首先，复制原来的user-service启动配置：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713222656562.png" alt="image-20210713222656562"></p><p>然后，在弹出的窗口中，填写信息：</p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713222757702.png" alt="image-20210713222757702" style="zoom:50%;" /><p>现在，SpringBoot窗口会出现两个user-service启动配置：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713222841951.png" alt="image-20210713222841951"></p><p>不过，第一个是8081端口，第二个是8082端口。</p><p>启动两个user-service实例：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713223041491.png" alt="image-20210713223041491"></p><p>查看eureka-server管理页面：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713223150650.png" alt="image-20210713223150650"></p><h2 id="3-4-服务发现"><a href="#3-4-服务发现" class="headerlink" title="3.4.服务发现"></a>3.4.服务发现</h2><p>下面，我们将order-service的逻辑修改：向eureka-server拉取user-service的信息，实现服务发现。</p><h3 id="1）引入依赖-1"><a href="#1）引入依赖-1" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>之前说过，服务发现、服务注册统一都封装在eureka-client依赖，因此这一步与服务注册时一致。</p><p>在order-service的pom文件中，引入下面的eureka-client依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2）配置文件-1"><a href="#2）配置文件-1" class="headerlink" title="2）配置文件"></a>2）配置文件</h3><p>服务发现也需要知道eureka地址，因此第二步与服务注册一致，都是配置eureka信息：</p><p>在order-service中，修改application.yml文件，添加服务名称、eureka地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">orderservice</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka</span><br></code></pre></td></tr></table></figure><h3 id="3）服务拉取和负载均衡"><a href="#3）服务拉取和负载均衡" class="headerlink" title="3）服务拉取和负载均衡"></a>3）服务拉取和负载均衡</h3><p>最后，我们要去eureka-server中拉取user-service服务的实例列表，并且实现负载均衡。</p><p>不过这些动作不用我们去做，只需要添加一些注解即可。</p><p>在order-service的OrderApplication中，给RestTemplate这个Bean添加一个@LoadBalanced注解：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713224049419.png" alt="image-20210713224049419"></p><p>修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法。修改访问的url路径，用服务名代替ip、端口：</p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713224245731.png" alt="image-20210713224245731" style="zoom:50%;" /><p>spring会自动帮助我们从eureka-server端，根据userservice这个服务名称，获取实例列表，而后完成负载均衡。</p><h1 id="4-Ribbon负载均衡"><a href="#4-Ribbon负载均衡" class="headerlink" title="4.Ribbon负载均衡"></a>4.Ribbon负载均衡</h1><p>上一节中，我们添加了@LoadBalanced注解，即可实现负载均衡功能，这是什么原理呢？</p><h2 id="4-1-负载均衡原理"><a href="#4-1-负载均衡原理" class="headerlink" title="4.1.负载均衡原理"></a>4.1.负载均衡原理</h2><p>SpringCloud底层其实是利用了一个名为Ribbon的组件，来实现负载均衡功能的。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713224517686.png" alt="image-20210713224517686"></p><p>那么我们发出的请求明明是<a href="http://userservice/user/1%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8F%98%E6%88%90%E4%BA%86http://localhost:8081%E7%9A%84%E5%91%A2%EF%BC%9F">http://userservice/user/1，怎么变成了http://localhost:8081的呢？</a></p><h2 id="4-2-源码跟踪"><a href="#4-2-源码跟踪" class="headerlink" title="4.2.源码跟踪"></a>4.2.源码跟踪</h2><p>为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。</p><p>显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是<code>LoadBalancerInterceptor</code>，这个类会在对RestTemplate的请求进行拦截，然后从Eureka根据服务id获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务id。</p><p>我们进行源码跟踪：</p><h3 id="1）LoadBalancerIntercepor"><a href="#1）LoadBalancerIntercepor" class="headerlink" title="1）LoadBalancerIntercepor"></a>1）LoadBalancerIntercepor</h3><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/1525620483637.png" alt="1525620483637"></p><p>可以看到这里的intercept方法，拦截了用户的HttpRequest请求，然后做了几件事：</p><ul><li><code>request.getURI()</code>：获取请求uri，本例中就是 <a href="http://user-service/user/8">http://user-service/user/8</a></li><li><code>originalUri.getHost()</code>：获取uri路径的主机名，其实就是服务id，<code>user-service</code></li><li><code>this.loadBalancer.execute()</code>：处理服务id，和用户请求。</li></ul><p>这里的<code>this.loadBalancer</code>是<code>LoadBalancerClient</code>类型，我们继续跟入。</p><h3 id="2）LoadBalancerClient"><a href="#2）LoadBalancerClient" class="headerlink" title="2）LoadBalancerClient"></a>2）LoadBalancerClient</h3><p>继续跟入execute方法：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/1525620787090.png" alt="1525620787090"></p><p>代码是这样的：</p><ul><li>getLoadBalancer(serviceId)：根据服务id获取ILoadBalancer，而ILoadBalancer会拿着服务id去eureka中获取服务列表并保存起来。</li><li>getServer(loadBalancer)：利用内置的负载均衡算法，从服务列表中选择一个。本例中，可以看到获取了8082端口的服务</li></ul><p>放行后，再次访问并跟踪，发现获取的是8081：</p><p> <img src="D:/workspace/java学习/17、微服务开发框架SpringCloud+RabbitMQ+Docker+Redis+搜索+分布式史上最全面的微服务全技术栈课程/day01-SpringCloud01/讲义/assets/1525620835911.png" alt="1525620835911"></p><p>果然实现了负载均衡。</p><h3 id="3）负载均衡策略IRule"><a href="#3）负载均衡策略IRule" class="headerlink" title="3）负载均衡策略IRule"></a>3）负载均衡策略IRule</h3><p>在刚才的代码中，可以看到获取服务使通过一个<code>getServer</code>方法来做负载均衡:</p><p> <img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/1525620835911.png" alt="1525620835911"></p><p>我们继续跟入：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/1544361421671.png" alt="1544361421671"></p><p>继续跟踪源码chooseServer方法，发现这么一段代码：</p><p> <img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/1525622652849.png" alt="1525622652849"></p><p>我们看看这个rule是谁：</p><p> <img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/1525622699666.png" alt="1525622699666"></p><p>这里的rule默认值是一个<code>RoundRobinRule</code>，看类的介绍：</p><p> <img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/1525622754316.png" alt="1525622754316"></p><p>这不就是轮询的意思嘛。</p><p>到这里，整个负载均衡的流程我们就清楚了。</p><h3 id="4）总结"><a href="#4）总结" class="headerlink" title="4）总结"></a>4）总结</h3><p>SpringCloudRibbon的底层采用了一个拦截器，拦截了RestTemplate发出的请求，对地址做了修改。用一幅图来总结一下：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713224724673.png" alt="image-20210713224724673"></p><p>基本流程如下：</p><ul><li>拦截我们的RestTemplate请求<a href="http://userservice/user/1">http://userservice/user/1</a></li><li>RibbonLoadBalancerClient会从请求url中获取服务名称，也就是user-service</li><li>DynamicServerListLoadBalancer根据user-service到eureka拉取服务列表</li><li>eureka返回列表，localhost:8081、localhost:8082</li><li>IRule利用内置负载均衡规则，从列表中选择一个，例如localhost:8081</li><li>RibbonLoadBalancerClient修改请求地址，用localhost:8081替代userservice，得到<a href="http://localhost:8081/user/1%EF%BC%8C%E5%8F%91%E8%B5%B7%E7%9C%9F%E5%AE%9E%E8%AF%B7%E6%B1%82">http://localhost:8081/user/1，发起真实请求</a></li></ul><h2 id="4-3-负载均衡策略"><a href="#4-3-负载均衡策略" class="headerlink" title="4.3.负载均衡策略"></a>4.3.负载均衡策略</h2><h3 id="4-3-1-负载均衡策略"><a href="#4-3-1-负载均衡策略" class="headerlink" title="4.3.1.负载均衡策略"></a>4.3.1.负载均衡策略</h3><p>负载均衡的规则都定义在IRule接口中，而IRule有很多不同的实现类：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713225653000.png" alt="image-20210713225653000"></p><p>不同规则的含义如下：</p><table><thead><tr><th><strong>内置负载均衡规则类</strong></th><th><strong>规则描述</strong></th></tr></thead><tbody><tr><td>RoundRobinRule</td><td>简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td></tr><tr><td>AvailabilityFilteringRule</td><td>对以下两种服务器进行忽略：   （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。  （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的<clientName>.<clientConfigNameSpace>.ActiveConnectionsLimit属性进行配置。</td></tr><tr><td>WeightedResponseTimeRule</td><td>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td></tr><tr><td><strong>ZoneAvoidanceRule</strong></td><td>以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</td></tr><tr><td>BestAvailableRule</td><td>忽略那些短路的服务器，并选择并发数较低的服务器。</td></tr><tr><td>RandomRule</td><td>随机选择一个可用的服务器。</td></tr><tr><td>RetryRule</td><td>重试机制的选择逻辑</td></tr></tbody></table><p>默认的实现就是ZoneAvoidanceRule，是一种轮询方案</p><h3 id="4-3-2-自定义负载均衡策略"><a href="#4-3-2-自定义负载均衡策略" class="headerlink" title="4.3.2.自定义负载均衡策略"></a>4.3.2.自定义负载均衡策略</h3><p>通过定义IRule实现可以修改负载均衡规则，有两种方式：</p><ol><li>代码方式：在order-service中的OrderApplication类中，定义一个新的IRule：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> IRule <span class="hljs-title function_">randomRule</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomRule</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">userservice:</span> <span class="hljs-comment"># 给某个微服务配置负载均衡规则，这里是userservice服务</span><br>  <span class="hljs-attr">ribbon:</span><br>    <span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.netflix.loadbalancer.RandomRule</span> <span class="hljs-comment"># 负载均衡规则 </span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>，一般用默认的负载均衡规则，不做修改。</p></blockquote><h2 id="4-4-饥饿加载"><a href="#4-4-饥饿加载" class="headerlink" title="4.4.饥饿加载"></a>4.4.饥饿加载</h2><p>Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。</p><p>而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">ribbon:</span><br>  <span class="hljs-attr">eager-load:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">clients:</span> <span class="hljs-string">userservice</span><br></code></pre></td></tr></table></figure><h1 id="5-Nacos注册中心"><a href="#5-Nacos注册中心" class="headerlink" title="5.Nacos注册中心"></a>5.Nacos注册中心</h1><p>国内公司一般都推崇阿里巴巴的技术，比如注册中心，SpringCloudAlibaba也推出了一个名为Nacos的注册中心。</p><h2 id="5-1-认识和安装Nacos"><a href="#5-1-认识和安装Nacos" class="headerlink" title="5.1.认识和安装Nacos"></a>5.1.认识和安装Nacos</h2><p><a href="https://nacos.io/">Nacos</a>是阿里巴巴的产品，现在是<a href="https://spring.io/projects/spring-cloud">SpringCloud</a>中的一个组件。相比<a href="https://github.com/Netflix/eureka">Eureka</a>功能更加丰富，在国内受欢迎程度较高。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713230444308.png" alt="image-20210713230444308"></p><p>安装方式可以参考课前资料《Nacos安装指南.md》</p><h2 id="5-2-服务注册到nacos"><a href="#5-2-服务注册到nacos" class="headerlink" title="5.2.服务注册到nacos"></a>5.2.服务注册到nacos</h2><p>Nacos是SpringCloudAlibaba的组件，而SpringCloudAlibaba也遵循SpringCloud中定义的服务注册、服务发现规范。因此使用Nacos和使用Eureka对于微服务来说，并没有太大区别。</p><p>主要差异在于：</p><ul><li>依赖不同</li><li>服务地址不同</li></ul><h3 id="1）引入依赖-2"><a href="#1）引入依赖-2" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>在cloud-demo父工程的pom文件中的<code>&lt;dependencyManagement&gt;</code>中引入SpringCloudAlibaba的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.6.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后在user-service和order-service中的pom文件中引入nacos-discovery依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：不要忘了注释掉eureka的依赖。</p></blockquote><h3 id="2）配置nacos地址"><a href="#2）配置nacos地址" class="headerlink" title="2）配置nacos地址"></a>2）配置nacos地址</h3><p>在user-service和order-service的application.yml中添加nacos地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：不要忘了注释掉eureka的地址</p></blockquote><h3 id="3）重启"><a href="#3）重启" class="headerlink" title="3）重启"></a>3）重启</h3><p>重启微服务后，登录nacos管理页面，可以看到微服务信息：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713231439607.png" alt="image-20210713231439607"></p><h2 id="5-3-服务分级存储模型"><a href="#5-3-服务分级存储模型" class="headerlink" title="5.3.服务分级存储模型"></a>5.3.服务分级存储模型</h2><p>一个<strong>服务</strong>可以有多个<strong>实例</strong>，例如我们的user-service，可以有:</p><ul><li>127.0.0.1:8081</li><li>127.0.0.1:8082</li><li>127.0.0.1:8083</li></ul><p>假如这些实例分布于全国各地的不同机房，例如：</p><ul><li>127.0.0.1:8081，在上海机房</li><li>127.0.0.1:8082，在上海机房</li><li>127.0.0.1:8083，在杭州机房</li></ul><p>Nacos就将同一机房内的实例 划分为一个<strong>集群</strong>。</p><p>也就是说，user-service是服务，一个服务可以包含多个集群，如杭州、上海，每个集群下可以有多个实例，形成分级模型，如图：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713232522531.png" alt="image-20210713232522531"></p><p>微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群。例如：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713232658928.png" alt="image-20210713232658928"></p><p>杭州机房内的order-service应该优先访问同机房的user-service。</p><h3 id="5-3-1-给user-service配置集群"><a href="#5-3-1-给user-service配置集群" class="headerlink" title="5.3.1.给user-service配置集群"></a>5.3.1.给user-service配置集群</h3><p>修改user-service的application.yml文件，添加集群配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">HZ</span> <span class="hljs-comment"># 集群名称</span><br></code></pre></td></tr></table></figure><p>重启两个user-service实例后，我们可以在nacos控制台看到下面结果：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713232916215.png" alt="image-20210713232916215"></p><p>我们再次复制一个user-service启动配置，添加属性：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">-Dserver.port=8083 -Dspring.cloud.nacos.discovery.cluster-name=SH<br></code></pre></td></tr></table></figure><p>配置如图所示：</p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713233528982.png" alt="image-20210713233528982" style="zoom:67%;" /><p>启动UserApplication3后再次查看nacos控制台：</p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713233727923.png" alt="image-20210713233727923" style="zoom:67%;" /><h3 id="5-3-2-同集群优先的负载均衡"><a href="#5-3-2-同集群优先的负载均衡" class="headerlink" title="5.3.2.同集群优先的负载均衡"></a>5.3.2.同集群优先的负载均衡</h3><p>默认的<code>ZoneAvoidanceRule</code>并不能实现根据同集群优先来实现负载均衡。</p><p>因此Nacos中提供了一个<code>NacosRule</code>的实现，可以优先从同集群中挑选实例。</p><p>1）给order-service配置集群信息</p><p>修改order-service的application.yml文件，添加集群配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">spring:<br>  cloud:<br>    nacos:<br>      server-addr: localhost:8848<br>      discovery:<br>        cluster-name: HZ <span class="hljs-comment"># 集群名称</span><br></code></pre></td></tr></table></figure><p>2）修改负载均衡规则</p><p>修改order-service的application.yml文件，修改负载均衡规则：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">userservice:</span><br>  <span class="hljs-attr">ribbon:</span><br>    <span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class="hljs-comment"># 负载均衡规则 </span><br></code></pre></td></tr></table></figure><h2 id="5-4-权重配置"><a href="#5-4-权重配置" class="headerlink" title="5.4.权重配置"></a>5.4.权重配置</h2><p>实际部署中会出现这样的场景：</p><p>服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。</p><p>但默认情况下NacosRule是同集群内随机挑选，不会考虑机器的性能问题。</p><p>因此，Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高。</p><p>在nacos控制台，找到user-service的实例列表，点击编辑，即可修改权重：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713235133225.png" alt="image-20210713235133225"></p><p>在弹出的编辑窗口，修改权重：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210713235235219.png" alt="image-20210713235235219"></p><blockquote><p><strong>注意</strong>：如果权重修改为0，则该实例永远不会被访问</p></blockquote><h2 id="5-5-环境隔离"><a href="#5-5-环境隔离" class="headerlink" title="5.5.环境隔离"></a>5.5.环境隔离</h2><p>Nacos提供了namespace来实现环境隔离功能。</p><ul><li>nacos中可以有多个namespace</li><li>namespace下可以有group、service等</li><li>不同namespace之间相互隔离，例如不同namespace的服务互相不可见</li></ul><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714000101516.png" alt="image-20210714000101516" style="zoom:67%;" /><h3 id="5-5-1-创建namespace"><a href="#5-5-1-创建namespace" class="headerlink" title="5.5.1.创建namespace"></a>5.5.1.创建namespace</h3><p>默认情况下，所有service、data、group都在同一个namespace，名为public：</p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714000414781.png" alt="image-20210714000414781" style="zoom:50%;" /><p>我们可以点击页面新增按钮，添加一个namespace：</p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714000440143.png" alt="image-20210714000440143" style="zoom: 67%;" /><p>然后，填写表单：</p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714000505928.png" alt="image-20210714000505928" style="zoom:67%;" /><p>就能在页面看到一个新的namespace：</p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714000522913.png" alt="image-20210714000522913" style="zoom:67%;" /><h3 id="5-5-2-给微服务配置namespace"><a href="#5-5-2-给微服务配置namespace" class="headerlink" title="5.5.2.给微服务配置namespace"></a>5.5.2.给微服务配置namespace</h3><p>给微服务配置namespace只能通过修改配置来实现。</p><p>例如，修改order-service的application.yml文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">HZ</span><br>        <span class="hljs-attr">namespace:</span> <span class="hljs-string">492a7d5d-237b-46a1-a99a-fa8e98e4b0f9</span> <span class="hljs-comment"># 命名空间，填ID</span><br></code></pre></td></tr></table></figure><p>重启order-service后，访问控制台，可以看到下面的结果：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714000830703.png" alt="image-20210714000830703"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714000837140.png" alt="image-20210714000837140"></p><p>此时访问order-service，因为namespace不同，会导致找不到userservice，控制台会报错：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714000941256.png" alt="image-20210714000941256"></p><h2 id="5-6-Nacos与Eureka的区别"><a href="#5-6-Nacos与Eureka的区别" class="headerlink" title="5.6.Nacos与Eureka的区别"></a>5.6.Nacos与Eureka的区别</h2><p>Nacos的服务实例分为两种l类型：</p><ul><li><p>临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。</p></li><li><p>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</p></li></ul><p>配置一个服务实例为永久实例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">ephemeral:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 设置为非临时实例</span><br></code></pre></td></tr></table></figure><p>Nacos和Eureka整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714001728017.png" alt="image-20210714001728017"></p><ul><li><p>Nacos与eureka的共同点</p><ul><li>都支持服务注册和服务拉取</li><li>都支持服务提供者心跳方式做健康检测</li></ul></li><li><p>Nacos与Eureka的区别</p><ul><li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li><li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li><li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li><li>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</li></ul></li></ul><h1 id="SpringCloud实用篇02"><a href="#SpringCloud实用篇02" class="headerlink" title="SpringCloud实用篇02"></a>SpringCloud实用篇02</h1><h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><h1 id="1-Nacos配置管理"><a href="#1-Nacos配置管理" class="headerlink" title="1.Nacos配置管理"></a>1.Nacos配置管理</h1><p>Nacos除了可以做注册中心，同样可以做配置管理来使用。</p><h2 id="1-1-统一配置管理"><a href="#1-1-统一配置管理" class="headerlink" title="1.1.统一配置管理"></a>1.1.统一配置管理</h2><p>当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。我们需要一种统一配置管理方案，可以集中管理所有实例的配置。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714164426792.png" alt="image-20210714164426792"></p><p>Nacos一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新。</p><h3 id="1-1-1-在nacos中添加配置文件"><a href="#1-1-1-在nacos中添加配置文件" class="headerlink" title="1.1.1.在nacos中添加配置文件"></a>1.1.1.在nacos中添加配置文件</h3><p>如何在nacos中管理配置呢？</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714164742924.png" alt="image-20210714164742924"></p><p>然后在弹出的表单中，填写配置信息：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714164856664.png" alt="image-20210714164856664"></p><blockquote><p>注意：项目的核心配置，需要热更新的配置才有放到nacos管理的必要。基本不会变更的一些配置还是保存在微服务本地比较好。</p></blockquote><h3 id="1-1-2-从微服务拉取配置"><a href="#1-1-2-从微服务拉取配置" class="headerlink" title="1.1.2.从微服务拉取配置"></a>1.1.2.从微服务拉取配置</h3><p>微服务要拉取nacos中管理的配置，并且与本地的application.yml配置合并，才能完成项目启动。</p><p>但如果尚未读取application.yml，又如何得知nacos地址呢？</p><p>因此spring引入了一种新的配置文件：bootstrap.yaml文件，会在application.yml之前被读取，流程如下：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/L0iFYNF.png" alt="img"></p><p>1）引入nacos-config依赖</p><p>首先，在user-service服务中，引入nacos-config的客户端依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--nacos配置管理依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2）添加bootstrap.yaml</p><p>然后，在user-service中添加一个bootstrap.yaml文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">userservice</span> <span class="hljs-comment"># 服务名称</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span> <span class="hljs-comment">#开发环境，这里是dev </span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment"># Nacos地址</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment"># 文件后缀名</span><br></code></pre></td></tr></table></figure><p>这里会根据spring.cloud.nacos.server-addr获取nacos地址，再根据</p><p><code>$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</code>作为文件id，来读取配置。</p><p>本例中，就是去读取<code>userservice-dev.yaml</code>：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714170845901.png" alt="image-20210714170845901"></p><p>3）读取nacos配置</p><p>在user-service中的UserController中添加业务逻辑，读取pattern.dateformat配置：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714170337448.png" alt="image-20210714170337448"></p><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.user.web;<br><br><span class="hljs-keyword">import</span> cn.itcast.user.pojo.User;<br><span class="hljs-keyword">import</span> cn.itcast.user.service.UserService;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.*;<br><br><span class="hljs-keyword">import</span> java.time.LocalDateTime;<br><span class="hljs-keyword">import</span> java.time.format.DateTimeFormatter;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;pattern.dateformat&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String dateformat;<br>    <br>    <span class="hljs-meta">@GetMapping(&quot;now&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">now</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));<br>    &#125;<br>    <span class="hljs-comment">// ...略</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在页面访问，可以看到效果：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714170449612.png" alt="image-20210714170449612"></p><h2 id="1-2-配置热更新"><a href="#1-2-配置热更新" class="headerlink" title="1.2.配置热更新"></a>1.2.配置热更新</h2><p>我们最终的目的，是修改nacos中的配置后，微服务中无需重启即可让配置生效，也就是<strong>配置热更新</strong>。</p><p>要实现配置热更新，可以使用两种方式：</p><h3 id="1-2-1-方式一"><a href="#1-2-1-方式一" class="headerlink" title="1.2.1.方式一"></a>1.2.1.方式一</h3><p>在@Value注入的变量所在类上添加注解@RefreshScope：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714171036335.png" alt="image-20210714171036335"></p><h3 id="1-2-2-方式二"><a href="#1-2-2-方式二" class="headerlink" title="1.2.2.方式二"></a>1.2.2.方式二</h3><p>使用@ConfigurationProperties注解代替@Value注解。</p><p>在user-service服务中，添加一个类，读取patterrn.dateformat属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.user.config;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;pattern&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PatternProperties</span> &#123;<br>    <span class="hljs-keyword">private</span> String dateformat;<br>&#125;<br></code></pre></td></tr></table></figure><p>在UserController中使用这个类代替@Value：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714171316124.png" alt="image-20210714171316124"></p><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.user.web;<br><br><span class="hljs-keyword">import</span> cn.itcast.user.config.PatternProperties;<br><span class="hljs-keyword">import</span> cn.itcast.user.pojo.User;<br><span class="hljs-keyword">import</span> cn.itcast.user.service.UserService;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-keyword">import</span> java.time.LocalDateTime;<br><span class="hljs-keyword">import</span> java.time.format.DateTimeFormatter;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> PatternProperties patternProperties;<br><br>    <span class="hljs-meta">@GetMapping(&quot;now&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">now</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(patternProperties.getDateformat()));<br>    &#125;<br><br>    <span class="hljs-comment">// 略</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-3-配置共享"><a href="#1-3-配置共享" class="headerlink" title="1.3.配置共享"></a>1.3.配置共享</h2><p>其实微服务启动时，会去nacos读取多个配置文件，例如：</p><ul><li><p><code>[spring.application.name]-[spring.profiles.active].yaml</code>，例如：userservice-dev.yaml</p></li><li><p><code>[spring.application.name].yaml</code>，例如：userservice.yaml</p></li></ul><p>而<code>[spring.application.name].yaml</code>不包含环境，因此可以被多个环境共享。</p><p>下面我们通过案例来测试配置共享</p><h3 id="1）添加一个环境共享配置"><a href="#1）添加一个环境共享配置" class="headerlink" title="1）添加一个环境共享配置"></a>1）添加一个环境共享配置</h3><p>我们在nacos中添加一个userservice.yaml文件：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714173233650.png" alt="image-20210714173233650"></p><h3 id="2）在user-service中读取共享配置"><a href="#2）在user-service中读取共享配置" class="headerlink" title="2）在user-service中读取共享配置"></a>2）在user-service中读取共享配置</h3><p>在user-service服务中，修改PatternProperties类，读取新添加的属性：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714173324231.png" alt="image-20210714173324231"></p><p>在user-service服务中，修改UserController，添加一个方法：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714173721309.png" alt="image-20210714173721309"></p><h3 id="3）运行两个UserApplication，使用不同的profile"><a href="#3）运行两个UserApplication，使用不同的profile" class="headerlink" title="3）运行两个UserApplication，使用不同的profile"></a>3）运行两个UserApplication，使用不同的profile</h3><p>修改UserApplication2这个启动项，改变其profile值：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714173538538.png" alt="image-20210714173538538"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714173519963.png" alt="image-20210714173519963"></p><p>这样，UserApplication(8081)使用的profile是dev，UserApplication2(8082)使用的profile是test。</p><p>启动UserApplication和UserApplication2</p><p>访问<a href="http://localhost:8081/user/prop%EF%BC%8C%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:8081/user/prop，结果：</a></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714174313344.png" alt="image-20210714174313344"></p><p>访问<a href="http://localhost:8082/user/prop%EF%BC%8C%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:8082/user/prop，结果：</a></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714174424818.png" alt="image-20210714174424818"></p><p>可以看出来，不管是dev，还是test环境，都读取到了envSharedValue这个属性的值。</p><h3 id="4）配置共享的优先级"><a href="#4）配置共享的优先级" class="headerlink" title="4）配置共享的优先级"></a>4）配置共享的优先级</h3><p>当nacos、服务本地同时出现相同属性时，优先级有高低之分：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714174623557.png" alt="image-20210714174623557"></p><h2 id="1-4-搭建Nacos集群"><a href="#1-4-搭建Nacos集群" class="headerlink" title="1.4.搭建Nacos集群"></a>1.4.搭建Nacos集群</h2><p>Nacos生产环境下一定要部署为集群状态，部署方式参考课前资料中的文档：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714174728042.png" alt="image-20210714174728042"></p><h1 id="2-Feign远程调用"><a href="#2-Feign远程调用" class="headerlink" title="2.Feign远程调用"></a>2.Feign远程调用</h1><p>先来看我们以前利用RestTemplate发起远程调用的代码：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714174814204.png" alt="image-20210714174814204"></p><p>存在下面的问题：</p><p>•代码可读性差，编程体验不统一</p><p>•参数复杂URL难以维护</p><p>Feign是一个声明式的http客户端，官方地址：<a href="https://github.com/OpenFeign/feign">https://github.com/OpenFeign/feign</a></p><p>其作用就是帮助我们优雅的实现http请求的发送，解决上面提到的问题。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714174918088.png" alt="image-20210714174918088"></p><h2 id="2-1-Feign替代RestTemplate"><a href="#2-1-Feign替代RestTemplate" class="headerlink" title="2.1.Feign替代RestTemplate"></a>2.1.Feign替代RestTemplate</h2><p>Fegin的使用步骤如下：</p><h3 id="1）引入依赖-3"><a href="#1）引入依赖-3" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>我们在order-service服务的pom文件中引入feign的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2）添加注解"><a href="#2）添加注解" class="headerlink" title="2）添加注解"></a>2）添加注解</h3><p>在order-service的启动类添加注解开启Feign的功能：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714175102524.png" alt="image-20210714175102524"></p><h3 id="3）编写Feign的客户端"><a href="#3）编写Feign的客户端" class="headerlink" title="3）编写Feign的客户端"></a>3）编写Feign的客户端</h3><p>在order-service中新建一个接口，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.order.client;<br><br><span class="hljs-keyword">import</span> cn.itcast.order.pojo.User;<br><span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.FeignClient;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;<br><br><span class="hljs-meta">@FeignClient(&quot;userservice&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserClient</span> &#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span><br>    User <span class="hljs-title function_">findById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个客户端主要是基于SpringMVC的注解来声明远程调用的信息，比如：</p><ul><li>服务名称：userservice</li><li>请求方式：GET</li><li>请求路径：/user/{id}</li><li>请求参数：Long id</li><li>返回值类型：User</li></ul><p>这样，Feign就可以帮助我们发送http请求，无需自己使用RestTemplate来发送了。</p><h3 id="4）测试"><a href="#4）测试" class="headerlink" title="4）测试"></a>4）测试</h3><p>修改order-service中的OrderService类中的queryOrderById方法，使用Feign客户端代替RestTemplate：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714175415087.png" alt="image-20210714175415087"></p><p>是不是看起来优雅多了。</p><h3 id="5）总结"><a href="#5）总结" class="headerlink" title="5）总结"></a>5）总结</h3><p>使用Feign的步骤：</p><p>① 引入依赖</p><p>② 添加@EnableFeignClients注解</p><p>③ 编写FeignClient接口</p><p>④ 使用FeignClient中定义的方法代替RestTemplate</p><h2 id="2-2-自定义配置"><a href="#2-2-自定义配置" class="headerlink" title="2.2.自定义配置"></a>2.2.自定义配置</h2><p>Feign可以支持很多的自定义配置，如下表所示：</p><table><thead><tr><th>类型</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td><strong>feign.Logger.Level</strong></td><td>修改日志级别</td><td>包含四种不同的级别：NONE、BASIC、HEADERS、FULL</td></tr><tr><td>feign.codec.Decoder</td><td>响应结果的解析器</td><td>http远程调用的结果做解析，例如解析json字符串为java对象</td></tr><tr><td>feign.codec.Encoder</td><td>请求参数编码</td><td>将请求参数编码，便于通过http请求发送</td></tr><tr><td>feign. Contract</td><td>支持的注解格式</td><td>默认是SpringMVC的注解</td></tr><tr><td>feign. Retryer</td><td>失败重试机制</td><td>请求失败的重试机制，默认是没有，不过会使用Ribbon的重试</td></tr></tbody></table><p>一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的@Bean覆盖默认Bean即可。</p><p>下面以日志为例来演示如何自定义配置。</p><h3 id="2-2-1-配置文件方式"><a href="#2-2-1-配置文件方式" class="headerlink" title="2.2.1.配置文件方式"></a>2.2.1.配置文件方式</h3><p>基于配置文件修改feign的日志级别可以针对单个服务：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span>  <br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span> <br>      <span class="hljs-attr">userservice:</span> <span class="hljs-comment"># 针对某个微服务的配置</span><br>        <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">FULL</span> <span class="hljs-comment">#  日志级别 </span><br></code></pre></td></tr></table></figure><p>也可以针对所有服务：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span>  <br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span> <br>      <span class="hljs-attr">default:</span> <span class="hljs-comment"># 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置</span><br>        <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">FULL</span> <span class="hljs-comment">#  日志级别 </span><br></code></pre></td></tr></table></figure><p>而日志的级别分为四种：</p><ul><li>NONE：不记录任何日志信息，这是默认值。</li><li>BASIC：仅记录请求的方法，URL以及响应状态码和执行时间</li><li>HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</li><li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。</li></ul><h3 id="2-2-2-Java代码方式"><a href="#2-2-2-Java代码方式" class="headerlink" title="2.2.2.Java代码方式"></a>2.2.2.Java代码方式</h3><p>也可以基于Java代码来修改日志级别，先声明一个类，然后声明一个Logger.Level的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultFeignConfiguration</span>  &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Logger.Level <span class="hljs-title function_">feignLogLevel</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> Logger.Level.BASIC; <span class="hljs-comment">// 日志级别为BASIC</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要<strong>全局生效</strong>，将其放到启动类的@EnableFeignClients这个注解中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration .class)</span> <br></code></pre></td></tr></table></figure><p>如果是<strong>局部生效</strong>，则把它放到对应的@FeignClient这个注解中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(value = &quot;userservice&quot;, configuration = DefaultFeignConfiguration .class)</span> <br></code></pre></td></tr></table></figure><h2 id="2-3-Feign使用优化"><a href="#2-3-Feign使用优化" class="headerlink" title="2.3.Feign使用优化"></a>2.3.Feign使用优化</h2><p>Feign底层发起http请求，依赖于其它的框架。其底层客户端实现包括：</p><p>•URLConnection：默认实现，不支持连接池</p><p>•Apache HttpClient ：支持连接池</p><p>•OKHttp：支持连接池</p><p>因此提高Feign的性能主要手段就是使用<strong>连接池</strong>代替默认的URLConnection。</p><p>这里我们用Apache的HttpClient来演示。</p><p>1）引入依赖</p><p>在order-service的pom文件中引入Apache的HttpClient依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--httpClient的依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.github.openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>feign-httpclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2）配置连接池</p><p>在order-service的application.yml中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">default:</span> <span class="hljs-comment"># default全局的配置</span><br>        <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">BASIC</span> <span class="hljs-comment"># 日志级别，BASIC就是基本的请求和响应信息</span><br>  <span class="hljs-attr">httpclient:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启feign对HttpClient的支持</span><br>    <span class="hljs-attr">max-connections:</span> <span class="hljs-number">200</span> <span class="hljs-comment"># 最大的连接数</span><br>    <span class="hljs-attr">max-connections-per-route:</span> <span class="hljs-number">50</span> <span class="hljs-comment"># 每个路径的最大连接数</span><br></code></pre></td></tr></table></figure><p>接下来，在FeignClientFactoryBean中的loadBalance方法中打断点：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714185925910.png" alt="image-20210714185925910"></p><p>Debug方式启动order-service服务，可以看到这里的client，底层就是Apache HttpClient：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714190041542.png" alt="image-20210714190041542"></p><p>总结，Feign的优化：</p><p>1.日志级别尽量用basic</p><p>2.使用HttpClient或OKHttp代替URLConnection</p><p>①  引入feign-httpClient依赖</p><p>②  配置文件开启httpClient功能，设置连接池参数</p><h2 id="2-4-最佳实践"><a href="#2-4-最佳实践" class="headerlink" title="2.4.最佳实践"></a>2.4.最佳实践</h2><p>所谓最近实践，就是使用过程中总结的经验，最好的一种使用方式。</p><p>自习观察可以发现，Feign的客户端与服务提供者的controller代码非常相似：</p><p>feign客户端：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714190542730.png" alt="image-20210714190542730"></p><p>UserController：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714190528450.png" alt="image-20210714190528450"></p><p>有没有一种办法简化这种重复的代码编写呢？</p><h3 id="2-4-1-继承方式"><a href="#2-4-1-继承方式" class="headerlink" title="2.4.1.继承方式"></a>2.4.1.继承方式</h3><p>一样的代码可以通过继承来共享：</p><p>1）定义一个API接口，利用定义方法，并基于SpringMVC注解做声明。</p><p>2）Feign客户端和Controller都集成改接口</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714190640857.png" alt="image-20210714190640857"></p><p>优点：</p><ul><li>简单</li><li>实现了代码共享</li></ul><p>缺点：</p><ul><li><p>服务提供方、服务消费方紧耦合</p></li><li><p>参数列表中的注解映射并不会继承，因此Controller中必须再次声明方法、参数列表、注解</p></li></ul><h3 id="2-4-2-抽取方式"><a href="#2-4-2-抽取方式" class="headerlink" title="2.4.2.抽取方式"></a>2.4.2.抽取方式</h3><p>将Feign的Client抽取为独立模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用。</p><p>例如，将UserClient、User、Feign的默认配置都抽取到一个feign-api包中，所有微服务引用该依赖包，即可直接使用。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714214041796.png" alt="image-20210714214041796"></p><h3 id="2-4-3-实现基于抽取的最佳实践"><a href="#2-4-3-实现基于抽取的最佳实践" class="headerlink" title="2.4.3.实现基于抽取的最佳实践"></a>2.4.3.实现基于抽取的最佳实践</h3><h4 id="1）抽取"><a href="#1）抽取" class="headerlink" title="1）抽取"></a>1）抽取</h4><p>首先创建一个module，命名为feign-api：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714204557771.png" alt="image-20210714204557771"></p><p>项目结构：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714204656214.png" alt="image-20210714204656214"></p><p>在feign-api中然后引入feign的starter依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后，order-service中编写的UserClient、User、DefaultFeignConfiguration都复制到feign-api项目中</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714205221970.png" alt="image-20210714205221970"></p><h4 id="2）在order-service中使用feign-api"><a href="#2）在order-service中使用feign-api" class="headerlink" title="2）在order-service中使用feign-api"></a>2）在order-service中使用feign-api</h4><p>首先，删除order-service中的UserClient、User、DefaultFeignConfiguration等类或接口。</p><p>在order-service的pom文件中中引入feign-api的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.itcast.demo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>feign-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>修改order-service中的所有与上述三个组件有关的导包部分，改成导入feign-api中的包</p><h4 id="3）重启测试"><a href="#3）重启测试" class="headerlink" title="3）重启测试"></a>3）重启测试</h4><p>重启后，发现服务报错了：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714205623048.png" alt="image-20210714205623048"></p><p>这是因为UserClient现在在cn.itcast.feign.clients包下，</p><p>而order-service的@EnableFeignClients注解是在cn.itcast.order包下，不在同一个包，无法扫描到UserClient。</p><h4 id="4）解决扫描包问题"><a href="#4）解决扫描包问题" class="headerlink" title="4）解决扫描包问题"></a>4）解决扫描包问题</h4><p>方式一：</p><p>指定Feign应该扫描的包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableFeignClients(basePackages = &quot;cn.itcast.feign.clients&quot;)</span><br></code></pre></td></tr></table></figure><p>方式二：</p><p>指定需要加载的Client接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableFeignClients(clients = &#123;UserClient.class&#125;)</span><br></code></pre></td></tr></table></figure><h1 id="3-Gateway服务网关"><a href="#3-Gateway服务网关" class="headerlink" title="3.Gateway服务网关"></a>3.Gateway服务网关</h1><p>Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。</p><h2 id="3-1-为什么需要网关"><a href="#3-1-为什么需要网关" class="headerlink" title="3.1.为什么需要网关"></a>3.1.为什么需要网关</h2><p>Gateway网关是我们服务的守门神，所有微服务的统一入口。</p><p>网关的<strong>核心功能特性</strong>：</p><ul><li>请求路由</li><li>权限控制</li><li>限流</li></ul><p>架构图：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714210131152.png" alt="image-20210714210131152"></p><p><strong>权限控制</strong>：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</p><p><strong>路由和负载均衡</strong>：一切请求都必须先经过gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。</p><p><strong>限流</strong>：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</p><p>在SpringCloud中网关的实现包括两种：</p><ul><li>gateway</li><li>zuul</li></ul><p>Zuul是基于Servlet的实现，属于阻塞式编程。而SpringCloudGateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</p><h2 id="3-2-gateway快速入门"><a href="#3-2-gateway快速入门" class="headerlink" title="3.2.gateway快速入门"></a>3.2.gateway快速入门</h2><p>下面，我们就演示下网关的基本路由功能。基本步骤如下：</p><ol><li>创建SpringBoot工程gateway，引入网关依赖</li><li>编写启动类</li><li>编写基础配置和路由规则</li><li>启动网关服务进行测试</li></ol><h3 id="1）创建gateway服务，引入依赖"><a href="#1）创建gateway服务，引入依赖" class="headerlink" title="1）创建gateway服务，引入依赖"></a>1）创建gateway服务，引入依赖</h3><p>创建服务：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714210919458.png" alt="image-20210714210919458"></p><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--网关--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--nacos服务发现依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2）编写启动类"><a href="#2）编写启动类" class="headerlink" title="2）编写启动类"></a>2）编写启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.gateway;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GatewayApplication</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>SpringApplication.run(GatewayApplication.class, args);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3）编写基础配置和路由规则"><a href="#3）编写基础配置和路由规则" class="headerlink" title="3）编写基础配置和路由规则"></a>3）编写基础配置和路由规则</h3><p>创建application.yml文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">10010</span> <span class="hljs-comment"># 网关端口</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">gateway</span> <span class="hljs-comment"># 服务名称</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment"># nacos地址</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span> <span class="hljs-comment"># 网关路由配置</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user-service</span> <span class="hljs-comment"># 路由id，自定义，只要唯一即可</span><br>          <span class="hljs-comment"># uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://userservice</span> <span class="hljs-comment"># 路由的目标地址 lb就是负载均衡，后面跟服务名称</span><br>          <span class="hljs-attr">predicates:</span> <span class="hljs-comment"># 路由断言，也就是判断请求是否符合路由规则的条件</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**</span> <span class="hljs-comment"># 这个是按照路径匹配，只要以/user/开头就符合要求</span><br></code></pre></td></tr></table></figure><p>我们将符合<code>Path</code> 规则的一切请求，都代理到 <code>uri</code>参数指定的地址。</p><p>本例中，我们将 <code>/user/**</code>开头的请求，代理到<code>lb://userservice</code>，lb是负载均衡，根据服务名拉取服务列表，实现负载均衡。</p><h3 id="4）重启测试"><a href="#4）重启测试" class="headerlink" title="4）重启测试"></a>4）重启测试</h3><p>重启网关，访问<a href="http://localhost:10010/user/1%E6%97%B6%EF%BC%8C%E7%AC%A6%E5%90%88%60/user/**%60%E8%A7%84%E5%88%99%EF%BC%8C%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%88%B0uri%EF%BC%9Ahttp://userservice/user/1%EF%BC%8C%E5%BE%97%E5%88%B0%E4%BA%86%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:10010/user/1时，符合`/user/**`规则，请求转发到uri：http://userservice/user/1，得到了结果：</a></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714211908341.png" alt="image-20210714211908341"></p><h3 id="5）网关路由的流程图"><a href="#5）网关路由的流程图" class="headerlink" title="5）网关路由的流程图"></a>5）网关路由的流程图</h3><p>整个访问的流程如下：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714211742956.png" alt="image-20210714211742956"></p><p>总结：</p><p>网关搭建步骤：</p><ol><li><p>创建项目，引入nacos服务发现和gateway依赖</p></li><li><p>配置application.yml，包括服务基本信息、nacos地址、路由</p></li></ol><p>路由配置包括：</p><ol><li><p>路由id：路由的唯一标示</p></li><li><p>路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡</p></li><li><p>路由断言（predicates）：判断路由的规则，</p></li><li><p>路由过滤器（filters）：对请求或响应做处理</p></li></ol><p>接下来，就重点来学习路由断言和路由过滤器的详细知识</p><h2 id="3-3-断言工厂"><a href="#3-3-断言工厂" class="headerlink" title="3.3.断言工厂"></a>3.3.断言工厂</h2><p>我们在配置文件中写的断言规则只是字符串，这些字符串会被Predicate Factory读取并处理，转变为路由判断的条件</p><p>例如Path=/user/**是按照路径匹配，这个规则是由</p><p><code>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory</code>类来</p><p>处理的，像这样的断言工厂在SpringCloudGateway还有十几个:</p><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>After</td><td>是某个时间点后的请求</td><td>-  After=2037-01-20T17:42:47.789-07:00[America/Denver]</td></tr><tr><td>Before</td><td>是某个时间点之前的请求</td><td>-  Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</td></tr><tr><td>Between</td><td>是某两个时间点之前的请求</td><td>-  Between=2037-01-20T17:42:47.789-07:00[America/Denver],  2037-01-21T17:42:47.789-07:00[America/Denver]</td></tr><tr><td>Cookie</td><td>请求必须包含某些cookie</td><td>- Cookie=chocolate, ch.p</td></tr><tr><td>Header</td><td>请求必须包含某些header</td><td>- Header=X-Request-Id, \d+</td></tr><tr><td>Host</td><td>请求必须是访问某个host（域名）</td><td>-  Host=<strong>.somehost.org,</strong>.anotherhost.org</td></tr><tr><td>Method</td><td>请求方式必须是指定方式</td><td>- Method=GET,POST</td></tr><tr><td>Path</td><td>请求路径必须符合指定规则</td><td>- Path=/red/{segment},/blue/**</td></tr><tr><td>Query</td><td>请求参数必须包含指定参数</td><td>- Query=name, Jack或者-  Query=name</td></tr><tr><td>RemoteAddr</td><td>请求者的ip必须是指定范围</td><td>- RemoteAddr=192.168.1.1/24</td></tr><tr><td>Weight</td><td>权重处理</td><td></td></tr></tbody></table><p>我们只需要掌握Path这种路由工程就可以了。</p><h2 id="3-4-过滤器工厂"><a href="#3-4-过滤器工厂" class="headerlink" title="3.4.过滤器工厂"></a>3.4.过滤器工厂</h2><p>GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714212312871.png" alt="image-20210714212312871"></p><h3 id="3-4-1-路由过滤器的种类"><a href="#3-4-1-路由过滤器的种类" class="headerlink" title="3.4.1.路由过滤器的种类"></a>3.4.1.路由过滤器的种类</h3><p>Spring提供了31种不同的路由过滤器工厂。例如：</p><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>AddRequestHeader</td><td>给当前请求添加一个请求头</td></tr><tr><td>RemoveRequestHeader</td><td>移除请求中的一个请求头</td></tr><tr><td>AddResponseHeader</td><td>给响应结果中添加一个响应头</td></tr><tr><td>RemoveResponseHeader</td><td>从响应结果中移除有一个响应头</td></tr><tr><td>RequestRateLimiter</td><td>限制请求的流量</td></tr></tbody></table><h3 id="3-4-2-请求头过滤器"><a href="#3-4-2-请求头过滤器" class="headerlink" title="3.4.2.请求头过滤器"></a>3.4.2.请求头过滤器</h3><p>下面我们以AddRequestHeader 为例来讲解。</p><blockquote><p><strong>需求</strong>：给所有进入userservice的请求添加一个请求头：Truth=itcast is freaking awesome!</p></blockquote><p>只需要修改gateway服务的application.yml文件，添加路由过滤即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user-service</span> <br>        <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://userservice</span> <br>        <span class="hljs-attr">predicates:</span> <br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**</span> <br>        <span class="hljs-attr">filters:</span> <span class="hljs-comment"># 过滤器</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=Truth,</span> <span class="hljs-string">Itcast</span> <span class="hljs-string">is</span> <span class="hljs-string">freaking</span> <span class="hljs-string">awesome!</span> <span class="hljs-comment"># 添加请求头</span><br></code></pre></td></tr></table></figure><p>当前过滤器写在userservice路由下，因此仅仅对访问userservice的请求有效。</p><h3 id="3-4-3-默认过滤器"><a href="#3-4-3-默认过滤器" class="headerlink" title="3.4.3.默认过滤器"></a>3.4.3.默认过滤器</h3><p>如果要对所有的路由都生效，则可以将过滤器工厂写到default下。格式如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user-service</span> <br>        <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://userservice</span> <br>        <span class="hljs-attr">predicates:</span> <br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**</span><br>      <span class="hljs-attr">default-filters:</span> <span class="hljs-comment"># 默认过滤项</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=Truth,</span> <span class="hljs-string">Itcast</span> <span class="hljs-string">is</span> <span class="hljs-string">freaking</span> <span class="hljs-string">awesome!</span> <br></code></pre></td></tr></table></figure><h3 id="3-4-4-总结"><a href="#3-4-4-总结" class="headerlink" title="3.4.4.总结"></a>3.4.4.总结</h3><p>过滤器的作用是什么？</p><p>① 对路由的请求或响应做加工处理，比如添加请求头</p><p>② 配置在路由下的过滤器只对当前路由的请求生效</p><p>defaultFilters的作用是什么？</p><p>① 对所有路由都生效的过滤器</p><h2 id="3-5-全局过滤器"><a href="#3-5-全局过滤器" class="headerlink" title="3.5.全局过滤器"></a>3.5.全局过滤器</h2><p>上一节学习的过滤器，网关提供了31种，但每一种过滤器的作用都是固定的。如果我们希望拦截请求，做自己的业务逻辑则没办法实现。</p><h3 id="3-5-1-全局过滤器作用"><a href="#3-5-1-全局过滤器作用" class="headerlink" title="3.5.1.全局过滤器作用"></a>3.5.1.全局过滤器作用</h3><p>全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样。区别在于GatewayFilter通过配置定义，处理逻辑是固定的；而GlobalFilter的逻辑需要自己写代码实现。</p><p>定义方式是实现GlobalFilter接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">GlobalFilter</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  处理当前请求，有必要的话通过&#123;<span class="hljs-doctag">@link</span> GatewayFilterChain&#125;将请求交给下一个过滤器处理</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> exchange 请求上下文，里面可以获取Request、Response等信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> chain 用来把请求委托给下一个过滤器 </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> Mono&lt;Void&gt;&#125; 返回标示当前过滤器业务结束</span><br><span class="hljs-comment">     */</span><br>    Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在filter中编写自定义逻辑，可以实现下列功能：</p><ul><li>登录状态判断</li><li>权限校验</li><li>请求限流等</li></ul><h3 id="3-5-2-自定义全局过滤器"><a href="#3-5-2-自定义全局过滤器" class="headerlink" title="3.5.2.自定义全局过滤器"></a>3.5.2.自定义全局过滤器</h3><p>需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：</p><ul><li><p>参数中是否有authorization，</p></li><li><p>authorization参数值是否为admin</p></li></ul><p>如果同时满足则放行，否则拦截</p><p>实现：</p><p>在gateway中定义一个过滤器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.gateway.filters;<br><br><span class="hljs-keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;<br><span class="hljs-keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;<br><span class="hljs-keyword">import</span> org.springframework.core.annotation.Order;<br><span class="hljs-keyword">import</span> org.springframework.http.HttpStatus;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.springframework.web.server.ServerWebExchange;<br><span class="hljs-keyword">import</span> reactor.core.publisher.Mono;<br><br><span class="hljs-meta">@Order(-1)</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthorizeFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GlobalFilter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;<br>        <span class="hljs-comment">// 1.获取请求参数</span><br>        MultiValueMap&lt;String, String&gt; params = exchange.getRequest().getQueryParams();<br>        <span class="hljs-comment">// 2.获取authorization参数</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">auth</span> <span class="hljs-operator">=</span> params.getFirst(<span class="hljs-string">&quot;authorization&quot;</span>);<br>        <span class="hljs-comment">// 3.校验</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;admin&quot;</span>.equals(auth)) &#123;<br>            <span class="hljs-comment">// 放行</span><br>            <span class="hljs-keyword">return</span> chain.filter(exchange);<br>        &#125;<br>        <span class="hljs-comment">// 4.拦截</span><br>        <span class="hljs-comment">// 4.1.禁止访问，设置状态码</span><br>        exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);<br>        <span class="hljs-comment">// 4.2.结束处理</span><br>        <span class="hljs-keyword">return</span> exchange.getResponse().setComplete();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-3-过滤器执行顺序"><a href="#3-5-3-过滤器执行顺序" class="headerlink" title="3.5.3.过滤器执行顺序"></a>3.5.3.过滤器执行顺序</h3><p>请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter</p><p>请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714214228409.png" alt="image-20210714214228409"></p><p>排序的规则是什么呢？</p><ul><li>每一个过滤器都必须指定一个int类型的order值，<strong>order值越小，优先级越高，执行顺序越靠前</strong>。</li><li>GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定</li><li>路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增。</li><li>当过滤器的order值一样时，会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行。</li></ul><p>详细内容，可以查看源码：</p><p><code>org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator#getFilters()</code>方法是先加载defaultFilters，然后再加载某个route的filters，然后合并。</p><p><code>org.springframework.cloud.gateway.handler.FilteringWebHandler#handle()</code>方法会加载全局过滤器，与前面的过滤器合并后根据order排序，组织过滤器链</p><h2 id="3-6-跨域问题"><a href="#3-6-跨域问题" class="headerlink" title="3.6.跨域问题"></a>3.6.跨域问题</h2><h3 id="3-6-1-什么是跨域问题"><a href="#3-6-1-什么是跨域问题" class="headerlink" title="3.6.1.什么是跨域问题"></a>3.6.1.什么是跨域问题</h3><p>跨域：域名不一致就是跨域，主要包括：</p><ul><li><p>域名不同： <a href="http://www.taobao.com/">www.taobao.com</a> 和 <a href="http://www.taobao.org/">www.taobao.org</a> 和 <a href="http://www.jd.com/">www.jd.com</a> 和 miaosha.jd.com</p></li><li><p>域名相同，端口不同：localhost:8080和localhost8081</p></li></ul><p>跨域问题：浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题</p><p>解决方案：CORS，这个以前应该学习过，这里不再赘述了。不知道的小伙伴可以查看<a href="https://www.ruanyifeng.com/blog/2016/04/cors.html">https://www.ruanyifeng.com/blog/2016/04/cors.html</a></p><h3 id="3-6-2-模拟跨域问题"><a href="#3-6-2-模拟跨域问题" class="headerlink" title="3.6.2.模拟跨域问题"></a>3.6.2.模拟跨域问题</h3><p>找到课前资料的页面文件：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714215713563.png" alt="image-20210714215713563"></p><p>放入tomcat或者nginx这样的web服务器中，启动并访问。</p><p>可以在浏览器控制台看到下面的错误：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20210714215832675.png" alt="image-20210714215832675"></p><p>从localhost:8090访问localhost:10010，端口不同，显然是跨域的请求。</p><h3 id="3-6-3-解决跨域问题"><a href="#3-6-3-解决跨域问题" class="headerlink" title="3.6.3.解决跨域问题"></a>3.6.3.解决跨域问题</h3><p>在gateway服务的application.yml文件中，添加下面的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-comment"># 。。。</span><br>      <span class="hljs-attr">globalcors:</span> <span class="hljs-comment"># 全局的跨域处理</span><br>        <span class="hljs-attr">add-to-simple-url-handler-mapping:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 解决options请求被拦截问题</span><br>        <span class="hljs-attr">corsConfigurations:</span><br>          <span class="hljs-string">&#x27;[/**]&#x27;</span><span class="hljs-string">:</span><br>            <span class="hljs-attr">allowedOrigins:</span> <span class="hljs-comment"># 允许哪些网站的跨域请求 </span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;http://localhost:8090&quot;</span><br>            <span class="hljs-attr">allowedMethods:</span> <span class="hljs-comment"># 允许的跨域ajax的请求方式</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;GET&quot;</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;POST&quot;</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;DELETE&quot;</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;PUT&quot;</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;OPTIONS&quot;</span><br>            <span class="hljs-attr">allowedHeaders:</span> <span class="hljs-string">&quot;*&quot;</span> <span class="hljs-comment"># 允许在请求中携带的头信息</span><br>            <span class="hljs-attr">allowCredentials:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否允许携带cookie</span><br>            <span class="hljs-attr">maxAge:</span> <span class="hljs-number">360000</span> <span class="hljs-comment"># 这次跨域检测的有效期</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JAVA学习</category>
      
      <category>springCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法</title>
    <link href="/2023/03/22/%E7%AE%97%E6%B3%95/"/>
    <url>/2023/03/22/%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><a href="https://programmercarl.com/">来源</a></p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="1、二分查找"><a href="#1、二分查找" class="headerlink" title="1、二分查找"></a>1、二分查找</h2><h3 id="704、二分查找"><a href="#704、二分查找" class="headerlink" title="704、二分查找"></a>704、二分查找</h3><ul><li>35.搜索插入位置</li><li>34.在排序数组中查找元素的第一个和最后一个位置</li><li>367.有效的完全平方数</li></ul><p><strong>前提是数组为有序数组</strong>，同时题目还强调<strong>数组中无重复元素</strong>，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件。</p><p><a href="https://leetcode.cn/problems/binary-search/">leetcodw链接</a></p><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>示例 1:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: nums = [-1,0,3,5,9,12], target = 9     <br>输出: 4       <br>解释: 9 出现在 nums 中并且下标为 4     <br></code></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: nums = [-1,0,3,5,9,12], target = 2     <br>输出: -1        <br>解释: 2 不存在 nums 中因此返回 -1        <br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>你可以假设 nums 中的所有元素是不重复的。</li><li>n 将在 [1, 10000]之间。</li><li>nums 的每个元素都将在 [-9999, 9999]之间</li></ul><p><strong>第一种写法</strong>，我们定义 target 是在一个在左闭右闭的区间里，<strong>也就是[left, right] （这个很重要非常重要）</strong>。</p><p>区间的定义这就决定了二分法的代码应该如何写，<strong>因为定义target在[left, right]区间，所以有如下两点：</strong></p><ul><li>while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;=。</li><li>if (nums[middle] &gt; target) ，right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1。</li></ul><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230322103854002.png" alt="image-20230322103854002" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-comment">// 避免当 target 小于nums[0] nums[nums.length - 1]时多次循环运算</span><br>        <span class="hljs-keyword">if</span> (target &lt; nums[<span class="hljs-number">0</span>] || target &gt; nums[nums.length - <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + ((right - left) &gt;&gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (nums[mid] == target)<br>                <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br>                right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第二种写法</strong>，如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。</p><p>有如下两点：</p><ul><li>while (left &lt; right)，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的</li><li>if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li></ul><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230322104057766.png" alt="image-20230322104057766" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + ((right - left) &gt;&gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (nums[mid] == target)<br>                <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br>                right = mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35.搜索插入位置"></a>35.搜索插入位置</h3><p><a href="https://leetcode.cn/problems/search-insert-position/">力扣题目链接</a></p><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p>示例 1:</p><ul><li>输入: [1,3,5,6], 5</li><li>输出: 2</li></ul><p>示例 2:</p><ul><li>输入: [1,3,5,6], 2</li><li>输出: 1</li></ul><p>示例 3:</p><ul><li>输入: [1,3,5,6], 7</li><li>输出: 4</li></ul><p>示例 4:</p><ul><li>输入: [1,3,5,6], 0</li><li>输出: 0</li></ul><p>思路</p><p>这道题目不难，但是为什么通过率相对来说并不高呢，我理解是大家对边界处理的判断有所失误导致的。</p><p>这道题目，要在数组中插入目标值，无非是这四种情况。</p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/20201216232148471.png" alt="35_搜索插入位置3" style="zoom:50%;" /><ul><li><p>目标值在数组所有元素之前</p></li><li><p>目标值等于数组中某一个元素</p></li><li><p>目标值插入数组中的位置</p></li><li><p>目标值在数组所有元素之后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchInsert</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br><br>        <span class="hljs-comment">// 定义target在左闭右闭的区间，[low, high]</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">high</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (low &lt;= high) &#123; <span class="hljs-comment">// 当low==high，区间[low, high]依然有效</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> low + (high - low) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 防止溢出</span><br>            <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>                high = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// target 在左区间，所以[low, mid - 1]</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                low = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// target 在右区间，所以[mid + 1, high]</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 1. 目标值等于数组中某一个元素  return mid;</span><br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 2.目标值在数组所有元素之前 3.目标值插入数组中 4.目标值在数组所有元素之后 return right + 1;</span><br>        <span class="hljs-keyword">return</span> high + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//第二种二分法：左闭右开</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchInsert</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123; <span class="hljs-comment">//左闭右开 [left, right)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> left + ((right - left) &gt;&gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (nums[middle] &gt; target) &#123;<br>            right = middle; <span class="hljs-comment">// target 在左区间，在[left, middle)中</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] &lt; target) &#123;<br>            left = middle + <span class="hljs-number">1</span>; <span class="hljs-comment">// target 在右区间，在 [middle+1, right)中</span><br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// nums[middle] == target</span><br>            <span class="hljs-keyword">return</span> middle; <span class="hljs-comment">// 数组中找到目标值的情况，直接返回下标</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 目标值在数组所有元素之前 [0,0)</span><br>    <span class="hljs-comment">// 目标值插入数组中的位置 [left, right) ，return right 即可</span><br>    <span class="hljs-comment">// 目标值在数组所有元素之后的情况 [left, right)，因为是右开区间，所以 return right</span><br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h3><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">力扣链接(opens new window)</a></p><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>进阶：你可以设计并实现时间复杂度为 $O(\log n)$ 的算法解决此问题吗？</p><p>示例 1：</p><ul><li>输入：nums = [5,7,7,8,8,10], target = 8</li><li>输出：[3,4]</li></ul><p>示例 2：</p><ul><li>输入：nums = [5,7,7,8,8,10], target = 6</li><li>输出：[-1,-1]</li></ul><p>示例 3：</p><ul><li>输入：nums = [], target = 0</li><li>输出：[-1,-1]</li></ul><p> 在排序数组中查找元素的第一个和最后一个位置.html#思路</p><p>这道题目如果基础不是很好，不建议大家看简短的代码，简短的代码隐藏了太多逻辑，结果就是稀里糊涂把题AC了，但是没有想清楚具体细节！</p><p>寻找target在数组里的左右边界，有如下三种情况：</p><ul><li>情况一：target 在数组范围的右边或者左边，例如数组{3, 4, 5}，target为2或者数组{3, 4, 5},target为6，此时应该返回{-1, -1}</li><li>情况二：target 在数组范围中，且数组中不存在target，例如数组{3,6,7},target为5，此时应该返回{-1, -1}</li><li>情况三：target 在数组范围中，且数组中存在target，例如数组{3,6,7},target为6，此时应该返回{1, 1}</li></ul><p>这三种情况都考虑到，说明就想的很清楚了。</p><p>接下来，在去寻找左边界，和右边界了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] searchRange(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>            <span class="hljs-comment">//3种情况  nums[1 2 3 3 4 5 6] target 3</span><br>            <span class="hljs-comment">//        nums[4 5 6] target 3,7</span><br>            <span class="hljs-comment">//        nums[4 5 7] target 6</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">rightBorder</span> <span class="hljs-operator">=</span> searchRight(nums, target);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">leftBorder</span> <span class="hljs-operator">=</span> searchLeft(nums, target);<br>            <span class="hljs-comment">//nums[4 5 6] target 3,7</span><br>            <span class="hljs-keyword">if</span> (rightBorder == -<span class="hljs-number">2</span> || leftBorder == -<span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>            &#125;<br>            <span class="hljs-comment">//nums[1 2 3 3 4 5 6] target 3</span><br>            <span class="hljs-keyword">if</span> (rightBorder - leftBorder &gt; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;leftBorder + <span class="hljs-number">1</span>, rightBorder - <span class="hljs-number">1</span>&#125;;<br>            &#125;<br>            <span class="hljs-comment">//nums[4 5 7] target 6</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>        &#125;<br><br>        <span class="hljs-comment">//寻找左边界</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchLeft</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">leftBoader</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (target &gt; nums[middle]) &#123;<br>                    left = middle + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//左边界时，右指针取值，最后多减了一次</span><br>                    right = middle - <span class="hljs-number">1</span>;<br>                    leftBoader = right;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> leftBoader;<br>        &#125;<br><br>        <span class="hljs-comment">//寻找右边界</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchRight</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rightBoader</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (target &gt;= nums[middle]) &#123;<br>                    <span class="hljs-comment">//右边界时，左指针取值，最后多加了一次</span><br>                    left = middle + <span class="hljs-number">1</span>;<br>                    rightBoader = left;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    right = middle - <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> rightBoader;<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="2、移除元素（双指针法）"><a href="#2、移除元素（双指针法）" class="headerlink" title="2、移除元素（双指针法）"></a>2、移除元素（双指针法）</h2><h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h3><p>相关题目推荐</p><ul><li>26.删除排序数组中的重复项</li><li>283.移动零</li><li>844.比较含退格的字符串</li><li>977.有序数组的平方</li></ul><p><a href="https://leetcode.cn/problems/remove-element/">力扣题目链接(opens new window)</a></p><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并<strong>原地</strong>修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。</p><p>示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p><p><strong>你不需要考虑数组中超出新长度后面的元素。</strong></p><p> <strong>思路</strong></p><p> 双指针法</p><p>双指针法（快慢指针法）： <strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p><p>定义快慢指针</p><ul><li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li><li>慢指针：指向更新 新数组下标的位置</li></ul><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/remove.gif" alt="remove"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-comment">// 快慢指针</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">slowIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">fastIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; fastIndex &lt; nums.length; fastIndex++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[fastIndex] != val) &#123;<br>                nums[slowIndex] = nums[fastIndex];<br>                slowIndex++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slowIndex;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、寻找两个正序数组的中位数（双指针法）"><a href="#4、寻找两个正序数组的中位数（双指针法）" class="headerlink" title="4、寻找两个正序数组的中位数（双指针法）"></a>4、寻找两个正序数组的中位数（双指针法）</h3><p><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">力扣</a></p><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1,3]</span>, nums2 = <span class="hljs-comment">[2]</span><br>输出：2.00000<br>解释：合并数组 = <span class="hljs-comment">[1,2,3]</span> ，中位数 2<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">2.50000</span><br>解释：合并数组 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>] ，中位数 <span class="hljs-comment">(2 + 3)</span> / <span class="hljs-number">2</span> = <span class="hljs-number">2.5</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>nums1.length == m</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m &lt;= 1000</code></li><li><code>0 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= m + n &lt;= 2000</code></li><li><code>-106 &lt;= nums1[i], nums2[i] &lt;= 106</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">P4_MedianOfTwoSortedArrays</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Solution</span> <span class="hljs-variable">solution</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">P4_MedianOfTwoSortedArrays</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">Solution</span>();<br>        <br>    &#125;<br><br>    <span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 用于区分总长度是单数还是双数</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> (nums1.length + nums2.length - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> (nums1.length + nums2.length) / <span class="hljs-number">2</span>;<br><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 用于记录左右值</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">p_left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">p_right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 用于数组指针计数</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= right; i++) &#123;<br>                p_left = p_right;<br>                <span class="hljs-comment">//两种情况1，2没记数完，比大小，某一个记数完，则加另一个</span><br>                <span class="hljs-keyword">if</span> (p2 == nums2.length || (p1 &lt; nums1.length &amp;&amp; nums1[p1] &lt;= nums2[p2])) &#123;<br>                    p_right = nums1[p1];<br>                    p1++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    p_right = nums2[p2];<br>                    p2++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (left == right) &#123;<span class="hljs-comment">//判断奇数、偶数</span><br>                p_left = p_right;<br>            &#125;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-type">float</span>) (p_left + p_right) / <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h2><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">力扣题目链接(opens new window)</a></p><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p><p>示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</p><p>示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121]</p><p><strong>双指针法</strong></p><p>数组其实是有序的， 只不过负数平方之后可能成为最大数了。</p><p>那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。</p><p>此时可以考虑双指针法了，i指向起始位置，j指向终止位置。</p><p>定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。</p><p>如果<code>A[i] * A[i] &lt; A[j] * A[j]</code> 那么<code>result[k--] = A[j] * A[j];</code> 。</p><p>如果<code>A[i] * A[i] &gt;= A[j] * A[j]</code> 那么<code>result[k--] = A[i] * A[i];</code> 。</p><p>如动画所示：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/square.gif" alt="square"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sortedSquares(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> result.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span> (nums[left] * nums[left] &gt; nums[right] * nums[right]) &#123;<br>                <span class="hljs-comment">// 正数的相对位置是不变的， 需要调整的是负数平方后的相对位置</span><br>                result[index--] = nums[left] * nums[left];<br>                ++left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                result[index--] = nums[right] * nums[right];<br>                --right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h2><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">力扣题目链接(opens new window)</a></p><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p><p>示例：</p><p>输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。</p><p>提示：</p><ul><li>1 &lt;= target &lt;= 10^9</li><li>1 &lt;= nums.length &lt;= 10^5</li><li>1 &lt;= nums[i] &lt;= 10^5</li></ul><p>#暴力解法</p><p>这道题目暴力解法当然是 两个for循环，然后不断的寻找符合条件的子序列，时间复杂度很明显是O(n^2)。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> s, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = INT32_MAX; <span class="hljs-comment">// 最终的结果</span><br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 子序列的数值之和</span><br>        <span class="hljs-type">int</span> subLength = <span class="hljs-number">0</span>; <span class="hljs-comment">// 子序列的长度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 设置子序列起点为i</span><br>            sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; nums.<span class="hljs-built_in">size</span>(); j++) &#123; <span class="hljs-comment">// 设置子序列终止位置为j</span><br>                sum += nums[j];<br>                <span class="hljs-keyword">if</span> (sum &gt;= s) &#123; <span class="hljs-comment">// 一旦发现子序列和超过了s，更新result</span><br>                    subLength = j - i + <span class="hljs-number">1</span>; <span class="hljs-comment">// 取子序列的长度</span><br>                    result = result &lt; subLength ? result : subLength;<br>                    <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 因为我们是找符合条件最短的子序列，所以一旦符合条件就break</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span><br>        <span class="hljs-keyword">return</span> result == INT32_MAX ? <span class="hljs-number">0</span> : result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(1)</li></ul><p>后面力扣更新了数据，暴力解法已经超时了。</p><p>滑动窗口</p><p>接下来就开始介绍数组操作中另一个重要的方法：<strong>滑动窗口</strong>。</p><p>所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p><p>在暴力解法中，是一个for循环滑动窗口的起始位置，一个for循环为滑动窗口的终止位置，用两个for循环 完成了一个不断搜索区间的过程。</p><p>那么滑动窗口如何用一个for循环来完成这个操作呢。</p><p>首先要思考 如果用一个for循环，那么应该表示 滑动窗口的起始位置，还是终止位置。</p><p>如果只用一个for循环来表示 滑动窗口的起始位置，那么如何遍历剩下的终止位置？</p><p>此时难免再次陷入 暴力解法的怪圈。</p><p>所以 只用一个for循环，那么这个循环的索引，一定是表示 滑动窗口的终止位置。</p><p>那么问题来了， 滑动窗口的起始位置如何移动呢？</p><p>这里还是以题目中的示例来举例，s=7， 数组是 2，3，1，2，4，3，来看一下查找的过程：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/209.gif" alt="209"></p><p>其实从动画中可以发现滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。</p><p>在本题中实现滑动窗口，主要确定如下三点：</p><ul><li>窗口内是什么？</li><li>如何移动窗口的起始位置？</li><li>如何移动窗口的结束位置？</li></ul><p>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</p><p>窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。</p><p>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。</p><p>解题的关键在于 窗口的起始位置如何移动，如图所示：<img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/20210312160441942.png" alt="leetcode_209"></p><p>可以发现<strong>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)。</strong></p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p>**一些录友会疑惑为什么时间复杂度是O(n)**。</p><p>不要以为for里放一个while就以为是O(n^2)啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是 2 × n 也就是O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-comment">// 滑动窗口</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; right &lt; nums.length; right++) &#123;<br>            sum += nums[right];<br>            <span class="hljs-keyword">while</span> (sum &gt;= s) &#123;<br>                result = Math.min(result, right - left + <span class="hljs-number">1</span>);<br>                sum -= nums[left++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result == Integer.MAX_VALUE ? <span class="hljs-number">0</span> : result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>相关题目推荐</strong></p><ul><li><a href="https://leetcode.cn/problems/fruit-into-baskets/">904.水果成篮(opens new window)</a></li><li><a href="https://leetcode.cn/problems/minimum-window-substring/">76.最小覆盖子串(opens new window)</a></li></ul><h2 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59.螺旋矩阵II"></a>59.螺旋矩阵II</h2><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">力扣题目链接(opens new window)</a></p><p>给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><p>示例:</p><p>输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]</p><p><strong>思路</strong></p><p>这道题目可以说在面试中出现频率较高的题目，<strong>本题并不涉及到什么算法，就是模拟过程，但却十分考察对代码的掌控能力。</strong></p><p>要如何画出这个螺旋排列的正方形矩阵呢？</p><p>相信很多同学刚开始做这种题目的时候，上来就是一波判断猛如虎。</p><p>结果运行的时候各种问题，然后开始各种修修补补，最后发现改了这里那里有问题，改了那里这里又跑不起来了。</p><p>而求解本题依然是要坚持循环不变量原则。</p><p>模拟顺时针画矩阵的过程:</p><ul><li>填充上行从左到右</li><li>填充右列从上到下</li><li>填充下行从右到左</li><li>填充左列从下到上</li></ul><p>由外向内一圈一圈这么画下去。</p><p>可以发现这里的边界条件非常多，在一个循环中，如此多的边界条件，如果不按照固定规则来遍历，那就是<strong>一进循环深似海，从此offer是路人</strong>。</p><p>这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开右闭的原则，这样这一圈才能按照统一的规则画下来。</p><p>那么我按照左闭右开的原则，来画一圈，大家看一下：而求解本题依然是要坚持循环不变量原则。</p><p>模拟顺时针画矩阵的过程:</p><ul><li>填充上行从左到右</li><li>填充右列从上到下</li><li>填充下行从右到左</li><li>填充左列从下到上</li></ul><p>由外向内一圈一圈这么画下去。</p><p>可以发现这里的边界条件非常多，在一个循环中，如此多的边界条件，如果不按照固定规则来遍历，那就是<strong>一进循环深似海，从此offer是路人</strong>。</p><p>这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开右闭的原则，这样这一圈才能按照统一的规则画下来。</p><p>那么我按照左闭右开的原则，来画一圈，大家看一下：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/20220922102236.png" alt="img"></p><p>这里每一种颜色，代表一条边，我们遍历的长度，可以看出每一个拐角处的处理规则，拐角处让给新的一条边来继续画。</p><p>这也是坚持了每条边左闭右开的原则。</p><p>一些同学做这道题目之所以一直写不好，代码越写越乱。</p><p>就是因为在画每一条边的时候，一会左开右闭，一会左闭右闭，一会又来左闭右开，岂能不乱。</p><p>代码如下，已经详细注释了每一步的目的，可以看出while循环里判断的情况是很多的，代码里处理的原则也是统一的左闭右开。</p><ul><li>时间复杂度 O(n^2): 模拟遍历二维矩阵的时间</li><li>空间复杂度 O(1)</li></ul><p><strong>类似题目</strong></p><ul><li>54.螺旋矩阵</li><li>剑指Offer 29.顺时针打印矩阵</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] generateMatrix(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">loop</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 控制循环次数</span><br>        <span class="hljs-type">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 每次循环的开始点(start, start)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// 定义填充数字</span><br>        <span class="hljs-type">int</span> i, j;<br><br>        <span class="hljs-keyword">while</span> (loop++ &lt; n / <span class="hljs-number">2</span>) &#123; <span class="hljs-comment">// 判断边界后，loop从1开始</span><br>            <span class="hljs-comment">// 模拟上侧从左到右</span><br>            <span class="hljs-keyword">for</span> (j = start; j &lt; n - loop; j++) &#123;<br>                res[start][j] = count++;<br>            &#125;<br><br>            <span class="hljs-comment">// 模拟右侧从上到下</span><br>            <span class="hljs-keyword">for</span> (i = start; i &lt; n - loop; i++) &#123;<br>                res[i][j] = count++;<br>            &#125;<br><br>            <span class="hljs-comment">// 模拟下侧从右到左</span><br>            <span class="hljs-keyword">for</span> (; j &gt;= loop; j--) &#123;<br>                res[i][j] = count++;<br>            &#125;<br><br>            <span class="hljs-comment">// 模拟左侧从下到上</span><br>            <span class="hljs-keyword">for</span> (; i &gt;= loop; i--) &#123;<br>                res[i][j] = count++;<br>            &#125;<br>            start++;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            res[start][start] = count;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/Arrays.png" alt="Arrays" style="zoom:200%;" /><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>什么是链表，链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。</p><p>链表的入口节点称为链表的头结点也就是head。</p><p>如图所示：<img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/20200806194529815.png" alt="链表1"></p><p><strong>单链表</strong></p><p>刚刚说的就是单链表。</p><p><strong>双链表</strong></p><p>单链表中的指针域只能指向节点的下一个节点。</p><p>双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。</p><p>双链表 既可以向前查询也可以向后查询。</p><p>如图所示：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/20200806194559317.png" alt="链表2"></p><p><strong>循环链表</strong></p><p>循环链表，顾名思义，就是链表首尾相连。</p><p>循环链表可以用来解决约瑟夫环问题。<img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/20200806194629603.png" alt="链表4"></p><p><strong>链表的定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-comment">// 结点的值</span><br>    <span class="hljs-type">int</span> val;<br><br>    <span class="hljs-comment">// 下一个结点</span><br>    ListNode next;<br><br>    <span class="hljs-comment">// 节点的构造函数(无参)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-comment">// 节点的构造函数(有一个参数)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>    &#125;<br><br>    <span class="hljs-comment">// 节点的构造函数(有两个参数)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> val, ListNode next)</span> &#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>        <span class="hljs-built_in">this</span>.next = next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>删除节点</strong></p><p>删除D节点，如图所示：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/20200806195114541-20230310121459257.png" alt="链表-删除节点"></p><p>只要将C节点的next指针 指向E节点就可以了。</p><p>那有同学说了，D节点不是依然存留在内存里么？只不过是没有在这个链表里而已。</p><p>是这样的，所以在C++里最好是再手动释放这个D节点，释放这块内存。</p><p>其他语言例如Java、Python，就有自己的内存回收机制，就不用自己手动释放了。</p><p><strong>添加节点</strong></p><p>如图所示：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806195134331-20230310121503147.png" alt="链表-添加节点"></p><p>可以看出链表的增添和删除都是O(1)操作，也不会影响到其他节点。</p><p>但是要注意，要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。</p><p><strong>性能分析</strong></p><p>再把链表的特性和数组的特性进行一个对比，如图所示：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/20200806195200276.png" alt="链表-链表与数据性能对比"></p><h1 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h1><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">力扣题目链接(opens new window)</a></p><p>题意：删除链表中等于给定值 val 的所有节点。</p><p>示例 1： 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5]</p><p>示例 2： 输入：head = [], val = 1 输出：[]</p><p>示例 3： 输入：head = [7,7,7,7], val = 7 输出：[]</p><p><strong>思路</strong></p><p>这里以链表 1 4 2 4 来举例，移除元素4。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/20210316095351161.png" alt="203_链表删除元素1"></p><p>如果使用C，C++编程语言的话，不要忘了还要从内存中删除这两个移除的节点， 清理节点内存之后如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210316095418280.png" alt="203_链表删除元素2"></p><p><strong>当然如果使用java ，python的话就不用手动管理内存了。</strong></p><p>还要说明一下，就算使用C++来做leetcode，如果移除一个节点之后，没有手动在内存中删除这个节点，leetcode依然也是可以通过的，只不过，内存使用的空间大一些而已，但建议依然要养成手动清理内存的习惯。</p><p>这种情况下的移除操作，就是让节点next指针直接指向下下一个节点就可以了，</p><p>那么因为单链表的特殊性，只能指向下一个节点，刚刚删除的是链表的中第二个，和第四个节点，那么如果删除的是头结点又该怎么办呢？</p><p>这里就涉及如下链表操作的两种方式：</p><ul><li><strong>直接使用原来的链表来进行删除操作。</strong></li><li><strong>设置一个虚拟头结点在进行删除操作。</strong></li></ul><p>来看第一种操作：直接使用原来的链表来进行移除。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/2021031609544922.png" alt="203_链表删除元素3"></p><p>移除头结点和移除其他节点的操作是不一样的，因为链表的其他节点都是通过前一个节点来移除当前节点，而头结点没有前一个节点。</p><p>所以头结点如何移除呢，其实只要将头结点向后移动一位就可以，这样就从链表中移除了一个头结点。</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210316095512470.png" alt="203_链表删除元素4"></p><p>依然别忘将原头结点从内存中删掉。 <img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/20210316095543775.png" alt="203_链表删除元素5"></p><p>这样移除了一个头结点，是不是发现，在单链表中移除头结点 和 移除其他节点的操作方式是不一样，其实在写代码的时候也会发现，需要单独写一段逻辑来处理移除头结点的情况。</p><p>那么可不可以 以一种统一的逻辑来移除 链表的节点呢。</p><p>其实<strong>可以设置一个虚拟头结点</strong>，这样原链表的所有节点就都可以按照统一的方式进行移除了。</p><p>来看看如何设置一个虚拟头。依然还是在这个链表中，移除元素1。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/20210316095619221.png" alt="203_链表删除元素6"></p><p>这里来给链表添加一个虚拟头结点为新的头结点，此时要移除这个旧头结点元素1。</p><p>这样是不是就可以使用和移除链表其他节点的方式统一了呢？</p><p>来看一下，如何移除元素1 呢，还是熟悉的方式，然后从内存中删除元素1。</p><p>最后呢在题目中，return 头结点的时候，别忘了 <code>return dummyNode-&gt;next;</code>， 这才是新的头结点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 添加虚节点方式</span><br><span class="hljs-comment"> * 时间复杂度 O(n)</span><br><span class="hljs-comment"> * 空间复杂度 O(1)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> head</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> val</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-comment">// 因为删除可能涉及到头节点，所以设置dummy节点，统一操作</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>, head);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> dummy;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (cur.val == val) &#123;<br>            pre.next = cur.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pre = cur;<br>        &#125;<br>        cur = cur.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 不添加虚拟节点方式</span><br><span class="hljs-comment"> * 时间复杂度 O(n)</span><br><span class="hljs-comment"> * 空间复杂度 O(1)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> head</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> val</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>    <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span> &amp;&amp; head.val == val) &#123;<br>        head = head.next;<br>    &#125;<br>    <span class="hljs-comment">// 已经为null，提前退出</span><br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-comment">// 已确定当前head.val != val</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head.next;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (cur.val == val) &#123;<br>            pre.next = cur.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pre = cur;<br>        &#125;<br>        cur = cur.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 不添加虚拟节点and pre Node方式</span><br><span class="hljs-comment"> * 时间复杂度 O(n)</span><br><span class="hljs-comment"> * 空间复杂度 O(1)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> head</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> val</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>    <span class="hljs-keyword">while</span>(head!=<span class="hljs-literal">null</span> &amp;&amp; head.val==val)&#123;<br>        head = head.next;<br>    &#125;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-keyword">while</span>(curr!=<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">while</span>(curr.next!=<span class="hljs-literal">null</span> &amp;&amp; curr.next.val == val)&#123;<br>            curr.next = curr.next.next;<br>        &#125;<br>        curr = curr.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JAVA学习</category>
      
      <category>算法数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java基础</title>
    <link href="/2023/03/20/JAVA%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/03/20/JAVA%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><h2 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h2><h6 id="跨平台，解释型"><a href="#跨平台，解释型" class="headerlink" title="跨平台，解释型"></a><strong>跨平台，解释型</strong></h6><p>所有变量、方法、类名：见名知义<br>类成员变量：首字母小写和驼峰原则：monthSalary<br>局部变量：首字母小写和驼峰原则<br>常量：大写字母和下划线：MAX _VALUE<br>类名：首字母大写和驼峰原则：Man,GoodMan<br>方法名：首字母小写和驼峰原则：runO,runRun(0</p><p>整数默认int类型: long a = 2L;</p><p>小数默认double：float a = 1.2F;</p><p>boolean：只能赋值true，false</p><h6 id="位运算："><a href="#位运算：" class="headerlink" title="位运算："></a><strong>位运算</strong>：</h6><p>1、&amp;和&amp;&amp;：与，短路与</p><p>2、|和||：或，短路或</p><h6 id="字符串连接符："><a href="#字符串连接符：" class="headerlink" title="字符串连接符：+"></a><strong>字符串连接符</strong>：+</h6><p>通过String，+变为字符串连接符。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220414191342707.png" alt="image-20220414191342707"></p><p>特例：整形常量为int，可自动转化为byte/short/char，前提为不越界</p><h6 id="方法：函数"><a href="#方法：函数" class="headerlink" title="方法：函数"></a><strong>方法</strong>：函数</h6><h6 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a><strong>内存管理</strong></h6><p>Java的内存管理很大程度就是：堆中对象的管理，其中包括对象空间的分配和释放。<br>对象空间的分配：使用new关键字创建对象即可<br>对象空间的释放：将对象赋值null即可。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220416144955468.png" alt="image-20220416144955468"></p><h6 id="JVM调优和Full-GC"><a href="#JVM调优和Full-GC" class="headerlink" title="JVM调优和Full GC"></a><strong>JVM调优和Full GC</strong></h6><p>在对JVM调优的过程中，很大一部分工作就是对于FuLL GC的调节。有如下原因可能</p><h6 id="导致Full-GC"><a href="#导致Full-GC" class="headerlink" title="导致Full GC:"></a><strong>导致Full GC:</strong></h6><p>1.年老代(Tenured)被写满<br>2.永久代(Perm)被写满<br>3.System.gc0\()被显式调用<br>4.上一次GC之后Heap的各域分配策略动态变化</p><h6 id="this"><a href="#this" class="headerlink" title="this"></a><strong>this</strong></h6><p>1、this()调用重载的构造方法，避免相同的初始化代码。但只能在构造方法中用，并且必须位于构造方法的第一句。</p><p>xzs();{}</p><p>xzs(int a){</p><p>this();//调用xzs();{}</p><p>this.a=a;</p><p>}</p><p>2、this不能用于static方法中。<br>3、this是作为普通方法的“隐式参数”，由系统传入到方法中。</p><h6 id="包机制package、import"><a href="#包机制package、import" class="headerlink" title="包机制package、import"></a><strong>包机制package、import</strong></h6><p>包(（package)相当于文件夹对于文件的作用。用于管理类、用于解决类的重名问题。</p><h6 id="package"><a href="#package" class="headerlink" title="package"></a><strong>package</strong></h6><p>package的使用有两个要点：<br>1.通常是类的第一句非注释性语句。<br>2.包名：域名倒着写即可，再加上模块名，便于内部管理类。com.xzs.aa</p><h6 id="导入类import"><a href="#导入类import" class="headerlink" title="导入类import"></a><strong>导入类import</strong></h6><p>如果要使用其他包的类，需使用import,从而在本类中直接通过类名来调用，否则就需要书写类的完整包名和类名。</p><p>import java.util.* //导入所有类，降低编译速度，不会降低运行速度</p><h6 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h6><p>extends</p><h6 id="组合"><a href="#组合" class="headerlink" title="组合"></a><strong>组合</strong></h6><p>在子类创建父类对象，使用父类属性</p><h6 id="super"><a href="#super" class="headerlink" title="super"></a><strong>super</strong></h6><p>调用父类方法，父类被覆盖了，但依然存在。</p><h6 id="静态代码块："><a href="#静态代码块：" class="headerlink" title="静态代码块："></a><strong>静态代码块</strong>：</h6><p>static{}；属于类，优先加载。一般用于初始化静态资源。比如扑克牌类：优先定义54张牌的静态集合。</p><h6 id="静态工具类："><a href="#静态工具类：" class="headerlink" title="静态工具类："></a><strong>静态工具类</strong>：</h6><p>使用static定义一系列方法，供大家使用，建议私有化，不用其创建对象。</p><h6 id="设计模式："><a href="#设计模式：" class="headerlink" title="设计模式："></a><strong>设计模式</strong>：</h6><p>开发中经常遇到一些问题，一个问题通常有种解法的，但其中肯定有一种解法是最优的，这个最优的解法被人总结出来了，称之为设计模式。</p><h6 id="单例模式："><a href="#单例模式：" class="headerlink" title="单例模式："></a><strong>单例模式</strong>：</h6><p>可以保证系统中，应用该模式的这个类永远只有一个实例，即一个类永远只能创建一个对象。<br>例如任务管理器对象我们只需要一个就可以解决问题了，这样可以节省内存空间。<strong>设计步骤：</strong>定义一个类，把构造器私有。定义一个静态变量存储一个对象。</p><p>`饿汉单例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleInstance</span>&#123;`<br><br>​`<span class="hljs-comment">//2、提供储存地址`</span><br><br>​`<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">SingleInstance</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SIngleInstance</span>();`<br><br>​`<span class="hljs-comment">//1、构造器私有化`</span><br><br>​`<span class="hljs-keyword">private</span> <span class="hljs-title function_">SingleInstance</span><span class="hljs-params">()</span>&#123;&#125;`<br><br>`&#125;`<br></code></pre></td></tr></table></figure><h6 id="懒汉单例"><a href="#懒汉单例" class="headerlink" title="懒汉单例"></a><strong>懒汉单例</strong></h6><p>1、定义一个类，把构造器私有。<br>2、定义一个静态变量存储一个对象。<br>3、提供一个返回单例对象的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleInstance</span>&#123;`<br><br>`<span class="hljs-comment">//2、提供储存地址`</span><br><br>`<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">SingleInstance</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br><span class="hljs-comment">//3、提供一个方法`</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleInstance <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">if</span>(instance==<span class="hljs-literal">null</span>)<br>instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingleInstance</span>();<br><span class="hljs-keyword">return</span> instance;<br>&#125;<br><br>`<span class="hljs-comment">//1、构造器私有化`</span><br><br>`<span class="hljs-keyword">private</span> <span class="hljs-title function_">SingleInstance</span><span class="hljs-params">()</span>&#123;&#125;`<br><br>`&#125;`<br></code></pre></td></tr></table></figure><h6 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a><strong>继承的特点</strong></h6><p>①子类可以继承父类的属性和行为，但是子类不能继承父类的构造器。<br>②Java是单继承模式：一个类只能继承一个直接父类。<br>③Java不支持多继承、但是支持多层继承。<br>④Java中所有的类都是Object类的子类。</p><h6 id="子类继承父类后构造器的特点："><a href="#子类继承父类后构造器的特点：" class="headerlink" title="子类继承父类后构造器的特点："></a><strong>子类继承父类后构造器的特点：</strong></h6><p>子类中所有的构造器默认都会先访问父类中无参的构造器，再执行自己。</p><h6 id="finall的作用"><a href="#finall的作用" class="headerlink" title="finall的作用"></a><strong>finall的作用</strong></h6><p>final关键字是最终的意思，可以修饰(类、方法、变量)<br>修饰类：表明该类是最终类，不能被继承。<br>修饰方法：表明该方法是最终方法，不能被重写。<br>修饰变量：表示该变量第一次赋值后，不能再次被赋值（有且仅能被赋值一次）。</p><h6 id="枚举的特征："><a href="#枚举的特征：" class="headerlink" title="枚举的特征："></a><strong>枚举的特征：</strong></h6><p>枚举类都是继承了枚举类型：java.lang.Enum<br>枚举都是最终类，不可以被继承。<br>构造器的构造器都是私有的，枚举对外不能创建对象。<br>枚举类的第一行默认都是罗列枚举对象的名称的。<br>枚举类相当于是多例模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Season</span>&#123;<br> SPRING,SUMER,AUTUMN,WINTER;<br>&#125;<br>Season k;<br>SWITCh(k)&#123;<br><span class="hljs-keyword">case</span> SPRING:<br><span class="hljs-keyword">case</span> SUMER:<br><span class="hljs-keyword">case</span> AUTUMN:<br><span class="hljs-keyword">case</span> WINTER:<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="模板方法："><a href="#模板方法：" class="headerlink" title="模板方法："></a>模板方法：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br><span class="hljs-comment">//声明模板方法,建议用final修饰</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我的爸爸&quot;</span>);<br>        System.out.println(wrtiemain());<br>        System.out.println(<span class="hljs-string">&quot;他真牛逼&quot;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">writemain</span><span class="hljs-params">()</span>&#123;<br> System.out.println(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="接口"><a href="#接口" class="headerlink" title="接口:"></a>接口:</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Demo</span>&#123;<br><span class="hljs-comment">//1、常量</span><br><span class="hljs-type">String</span> <span class="hljs-variable">SCHOOL_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xzs&quot;</span><br><span class="hljs-comment">//public static final String SCHOOL_NAME</span><br><span class="hljs-comment">//2、抽象方法</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">//public abstract void run();</span><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="接口实现："><a href="#接口实现：" class="headerlink" title="接口实现："></a>接口实现：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">man</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Demo</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>JDK8开始后新增了那些方法？<br>默认方法：default修饰，实现类对象调用。<br>静态方法：static修饰，必须用当前接口名调用<br>私有方法：private修饰，jdk9开始才有的，只能在接口内部被调用。</p><h6 id="接口的注意事项"><a href="#接口的注意事项" class="headerlink" title="接口的注意事项"></a>接口的注意事项</h6><p>1、接口<strong>不能创建对象</strong>。<br>2、一个类实现多个接口，多个接口中有<strong>同样的静态方法</strong>不冲突。<br>3、一个类继承了父类，同时又实现了接口，父类中和接口中有同名方法，<strong>默认用父类的</strong>。<br>4、一个类实现了多个接口，多个接口中存在同名的默认方法，不冲突，<strong>这个类重写该方法即可</strong>。<br>5、一个接口继承多个接口，是没有问题的，如果多个接口中存在规范冲突则不能多继承。</p><h6 id="多态："><a href="#多态：" class="headerlink" title="多态："></a>多态：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Animal 父类 run();方法</span><br><span class="hljs-comment">//dog 子类 wang();方法独有</span><br><span class="hljs-comment">//cat 子类 miao();方法独有</span><br><span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">dog</span>();<br><span class="hljs-type">Animal</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">cat</span>();<br><span class="hljs-comment">//多态展示</span><br>a.run();<span class="hljs-comment">//狗跑</span><br>b.run();<span class="hljs-comment">//猫跑</span><br><span class="hljs-comment">//a.wang();出错</span><br><span class="hljs-type">dog</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span>(dog) a;<br>c.wang();<span class="hljs-comment">//正确，没有创建新对象，c不是新对象</span><br><span class="hljs-comment">//建议用法</span><br><span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> dog)&#123;<br><span class="hljs-type">dog</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span>(dog) a;<br>c.wang();<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a <span class="hljs-keyword">instanceof</span> cat)&#123;<br><span class="hljs-type">cat</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span>(cat) a;<br>c.miao();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><p>·内部类就是定义在一个类里面的类，里面的类可以理解成（寄生），外部类可以理解成（宿主）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>&#123;<br><span class="hljs-comment">//内部类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Heart</span>&#123;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>内部类的使用场景、作用</strong><br>当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么整个内部的完整结构可以选择使用内部类来设计。<br>内部类通常可以方便访问外部类的成员，包括私有的成员。<br>内部类提供了更好的封装性，内部类本身就可以用private protectecd等修饰，封装性可以做更多控制。</p><h6 id="1、静态内部类（用static修饰）"><a href="#1、静态内部类（用static修饰）" class="headerlink" title="1、静态内部类（用static修饰）"></a>1、<strong>静态内部类</strong>（用static修饰）</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">Outer.<span class="hljs-type">inner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>.inner(); <br></code></pre></td></tr></table></figure><h6 id="2、成员内部类（无static）"><a href="#2、成员内部类（无static）" class="headerlink" title="2、成员内部类（无static）"></a>2、<strong>成员内部类</strong>（无static）</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">Outer.<span class="hljs-type">inner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">inner</span>();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">150</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Heart</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">110</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">78</span>;<br>          System.out.println(c);<br>          System.out.println(<span class="hljs-built_in">this</span>.b);<br>          System.out.println(People.<span class="hljs-built_in">this</span>.a);<br>&#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="3、局部内部类"><a href="#3、局部内部类" class="headerlink" title="3、局部内部类"></a>3、<strong>局部内部类</strong></h6><h6 id="4、匿名内部类"><a href="#4、匿名内部类" class="headerlink" title="4、匿名内部类*"></a>4、<strong>匿名内部类</strong>*</h6><p>​    本质上是一个没有名字的局部内部类，定义在方法中、代码块中、等。</p><p>​    作用：方便创建子类对象，最终目的为了简化代码编写。</p><p>匿名内部类是一个没有名字的内部类。<br>匿名内部类写出来就会产生一个匿名内部类的对象。<br>匿名内部类的对象类型相当于是当前new的那个的类型的子类类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 类|抽象类名|或者接口名（）&#123;<br>重写方法；<br>&#125;;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br>main&#123;<br>    <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>()&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>            Systerm.out.println(<span class="hljs-string">&quot;老虎会跑&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal:"></a>BigDecimal:</h4><p>解决浮点数精度失真问题</p><p>使用步骤<br>创建对象BigDecimal封装浮点型数据（最好的方式是调用方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*public static BigDecimal valueOf(double val) &#123;</span><br><span class="hljs-comment">        // Reminder: a zero double returns &#x27;0.0&#x27;, so we cannot fastpath</span><br><span class="hljs-comment">        // to use the constant ZERO.  This might be important enough to</span><br><span class="hljs-comment">        // justify a factory approach, a cache, or a few private</span><br><span class="hljs-comment">        // constants, later.</span><br><span class="hljs-comment">        return new BigDecimal(Double.toString(val));</span><br><span class="hljs-comment">        &#125;*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test_BigDecimal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> BigDecimal.valueOf(<span class="hljs-number">0.1</span>);<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">a2</span> <span class="hljs-operator">=</span> BigDecimal.valueOf(<span class="hljs-number">0.2</span>);<br>        System.out.println(a1.add(a2));<br>        System.out.println(a1.subtract(a2));<br>        System.out.println(a1.multiply(a2));<br>        System.out.println(a1.divide(a2));<br>        <span class="hljs-comment">//转换为double传给别人</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> a1.doubleValue();<br>        System.out.println(rs);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="日期与时间"><a href="#日期与时间" class="headerlink" title="日期与时间"></a>日期与时间</h4><h6 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h6><p>Date类的对象在ava中代表的是当前所在系统的此刻日期时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//计算当前时间121毫秒后时间</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">date</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        System.out.println(a);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> a.getTime();<br>        System.out.println(time);<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        System.out.println(d1);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">time2</span> <span class="hljs-operator">=</span>System.currentTimeMillis();<br>        time2 += (<span class="hljs-number">60</span> * <span class="hljs-number">60</span> + <span class="hljs-number">121</span>) * <span class="hljs-number">1000</span>;<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">d2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(time2);<br>        System.out.println(d2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="simpleDateFormat类"><a href="#simpleDateFormat类" class="headerlink" title="simpleDateFormat类"></a>simpleDateFormat类</h6><p>可以对Date对象或时间毫秒值格式化成我们喜欢的时间形式。<br>也可以把字符串的时间形式解析成日期对象。</p><p>1、格式化</p><table><thead><tr><th>Sun Apr 24 15:17:16 CST 2022<br/>2022年04月24日 15:17:16 星期日 下午<br/>2022年04月24日 15:19:17 星期日 下午</th></tr></thead></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">simpleDateFormat</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//日期对象</span><br>        <span class="hljs-type">Date</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        System.out.println(d);<br>        <span class="hljs-comment">//格式</span><br>        <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy年MM月dd日 HH:mm:ss EEE a&quot;</span>);<br>        <span class="hljs-comment">//格式化</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> sdf.format(d);<br>        System.out.println(rs);<br>        <span class="hljs-comment">//毫秒</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">time1</span> <span class="hljs-operator">=</span>System.currentTimeMillis() +<span class="hljs-number">121</span>*<span class="hljs-number">1000</span>;<br>        <span class="hljs-type">String</span>  <span class="hljs-variable">rs2</span> <span class="hljs-operator">=</span> sdf.format(time1);<br>        System.out.println(rs2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、解析</p><p>请计算出2021年08月06日11点11分11秒，往后走2天14小时49分06秒后的时间是多少。</p><table><thead><tr><th>2021年08月09日 02:00:17</th></tr></thead></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">simpleDateFormat2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ParseException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">dateStr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2021年08月06日 11:11:11&quot;</span>;<br>        <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> sdf.parse(dateStr);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span>d.getTime()+(<span class="hljs-number">2L</span>*<span class="hljs-number">24</span>*<span class="hljs-number">60</span>*<span class="hljs-number">60</span> +<span class="hljs-number">14</span>*<span class="hljs-number">60</span>*<span class="hljs-number">60</span> +<span class="hljs-number">49</span>*<span class="hljs-number">60</span> +<span class="hljs-number">6</span>)*<span class="hljs-number">1000</span>;<br>        System.out.println(sdf.format(time));<br>    &#125;<br></code></pre></td></tr></table></figure><h6 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h6><p>Calendar代表了系统此刻日期对应的日历对象。<br>Calendar是一个抽象类，不能直接创建对象。</p><table><thead><tr><th>java.util.GregorianCalendar[time=1650786277579,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=”Asia/Shanghai”,offset=28800000,dstSavings=0,useDaylight=false,transitions=31,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2022,MONTH=3,WEEK_OF_YEAR=18,WEEK_OF_MONTH=5,DAY_OF_MONTH=24,DAY_OF_YEAR=114,DAY_OF_WEEK=1,DAY_OF_WEEK_IN_MONTH=4,AM_PM=1,HOUR=3,HOUR_OF_DAY=15,MINUTE=44,SECOND=37,MILLISECOND=579,ZONE_OFFSET=28800000,DST_OFFSET=0]<br/>2022<br/>4<br/>24<br/>Fri Apr 29 15:44:37 CST 2022<br/><br/></th></tr></thead></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Canlendar</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//1、拿到系统此时的日历对象</span><br>        <span class="hljs-type">Calendar</span> <span class="hljs-variable">cal</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>        System.out.println(cal);<br>        <span class="hljs-comment">//2、获取日历信息</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">year</span> <span class="hljs-operator">=</span> cal.get(Calendar.YEAR);<br>        System.out.println(year);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">month</span> <span class="hljs-operator">=</span>cal.get(Calendar.MONTH)+<span class="hljs-number">1</span>;<br>        System.out.println(month);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">day</span> <span class="hljs-operator">=</span> cal.get(Calendar.DAY_OF_MONTH);<br>        System.out.println(day);<br>        <span class="hljs-comment">//3、修改时间</span><br>        <span class="hljs-comment">//cal.set();</span><br>        cal.add(Calendar.DAY_OF_MONTH,<span class="hljs-number">5</span>);<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> cal.getTime();<br>        System.out.println(d);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="新增API"><a href="#新增API" class="headerlink" title="新增API"></a>新增API</h6><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs markdown">从Java8开始，java.time包提供了新的日期和时间APl,主要涉及的类型有：<br><br><span class="hljs-bullet">-</span> LocalDate:不包含具体时间的日期。<br><span class="hljs-bullet">-</span> LocalTime:不含日期的时间。<br><span class="hljs-bullet">-</span> LocalDateTime:包含了日期及时间。<br><span class="hljs-bullet">-</span> JDK8新增日期类<br><span class="hljs-bullet">-</span> Instant:代表的是时间戳。<br><span class="hljs-bullet">-</span> DateTimeFormatter用于做时间的格式化和解析的<br><span class="hljs-bullet">-</span> Duration:用于计算两个“时间”间隔<br><span class="hljs-bullet">-</span> Period:用于计算两个“日期”间隔<br><br>新增的AP叫严格区分了时刻、本地日期、本地时间，并且，对日期和时间进行运算更加方便。<br>其次，新API的类型几乎全部是不变类型(和String的使用类似)，可以放心使用不必担心被修改。<br></code></pre></td></tr></table></figure><p>代码：Day14。</p><h4 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h4><p>包装类<br>其实就是8种基本数据类型对应的引用类型。                </p><table><thead><tr><th>基本数据类型</th><th>引用数据类型</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><p><strong>为什么提供包装类？</strong><br>Java为了实现一切皆对象，为8种基本类型提供了对应的引用类型。<br>后面的集合和泛型其实也只能支持包装类型，不支持基本数据类型。</p><p>包装类的特有功能<br>包装类的变量的默认值可以是ul,容错率更高。<br><strong>可以把基本类型的数据转换成字符串类型（用处不大）</strong><br>①调用toString(）方法得到字符串结果。<br>②调用Integer.toString（）（基本类型的数据）。<br><strong>可以把字符串类型的数值转换成真实的数据类型（真的很有用）</strong><br>①Integer.parselnt(“字符串类型的整数”)。<br>②Double.parseDouble(“字符串类型的小数”)。</p><p><strong>Integer.valueof()  , Double.valueof()</strong></p><h4 id="正则表达式Pattern"><a href="#正则表达式Pattern" class="headerlink" title="正则表达式Pattern"></a>正则表达式Pattern</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegexDemo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//public boolean matches(String regex):判断是否与正则表达式匹配，匹配返回true</span><br>        <span class="hljs-comment">// 只能是 a  b  c</span><br>        System.out.println(<span class="hljs-string">&quot;a&quot;</span>.matches(<span class="hljs-string">&quot;[abc]&quot;</span>)); <span class="hljs-comment">// true</span><br>        System.out.println(<span class="hljs-string">&quot;z&quot;</span>.matches(<span class="hljs-string">&quot;[abc]&quot;</span>)); <span class="hljs-comment">// false</span><br><br>        <span class="hljs-comment">// 不能出现a  b  c</span><br>        System.out.println(<span class="hljs-string">&quot;a&quot;</span>.matches(<span class="hljs-string">&quot;[^abc]&quot;</span>)); <span class="hljs-comment">// false</span><br>        System.out.println(<span class="hljs-string">&quot;z&quot;</span>.matches(<span class="hljs-string">&quot;[^abc]&quot;</span>)); <span class="hljs-comment">// true</span><br><br>        System.out.println(<span class="hljs-string">&quot;a&quot;</span>.matches(<span class="hljs-string">&quot;\\d&quot;</span>)); <span class="hljs-comment">// false</span><br>        System.out.println(<span class="hljs-string">&quot;3&quot;</span>.matches(<span class="hljs-string">&quot;\\d&quot;</span>)); <span class="hljs-comment">// true</span><br>        System.out.println(<span class="hljs-string">&quot;333&quot;</span>.matches(<span class="hljs-string">&quot;\\d&quot;</span>)); <span class="hljs-comment">// false</span><br>        System.out.println(<span class="hljs-string">&quot;z&quot;</span>.matches(<span class="hljs-string">&quot;\\w&quot;</span>)); <span class="hljs-comment">// true</span><br>        System.out.println(<span class="hljs-string">&quot;2&quot;</span>.matches(<span class="hljs-string">&quot;\\w&quot;</span>)); <span class="hljs-comment">// true</span><br>        System.out.println(<span class="hljs-string">&quot;21&quot;</span>.matches(<span class="hljs-string">&quot;\\w&quot;</span>)); <span class="hljs-comment">// false</span><br>        System.out.println(<span class="hljs-string">&quot;你&quot;</span>.matches(<span class="hljs-string">&quot;\\w&quot;</span>)); <span class="hljs-comment">//false</span><br>        System.out.println(<span class="hljs-string">&quot;你&quot;</span>.matches(<span class="hljs-string">&quot;\\W&quot;</span>)); <span class="hljs-comment">// true</span><br>        System.out.println(<span class="hljs-string">&quot;---------------------------------&quot;</span>);<br>        <span class="hljs-comment">//  以上正则匹配只能校验单个字符。</span><br><br>        <span class="hljs-comment">// 校验密码</span><br>        <span class="hljs-comment">// 必须是数字 字母 下划线 至少 6位</span><br>        System.out.println(<span class="hljs-string">&quot;2442fsfsf&quot;</span>.matches(<span class="hljs-string">&quot;\\w&#123;6,&#125;&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;244f&quot;</span>.matches(<span class="hljs-string">&quot;\\w&#123;6,&#125;&quot;</span>));<br><br>        <span class="hljs-comment">// 验证码 必须是数字和字符  必须是4位</span><br>        System.out.println(<span class="hljs-string">&quot;23dF&quot;</span>.matches(<span class="hljs-string">&quot;[a-zA-Z0-9]&#123;4&#125;&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;23_F&quot;</span>.matches(<span class="hljs-string">&quot;[a-zA-Z0-9]&#123;4&#125;&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;23dF&quot;</span>.matches(<span class="hljs-string">&quot;[\\w&amp;&amp;[^_]]&#123;4&#125;&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;23_F&quot;</span>.matches(<span class="hljs-string">&quot;[\\w&amp;&amp;[^_]]&#123;4&#125;&quot;</span>));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>public boolean matches(<a href="file:///D:/course/%E5%9F%BA%E7%A1%80%E9%98%B6%E6%AE%B5/API%E6%96%87%E6%A1%A3/docs/api/java.base/java/lang/String.html">String</a> regex): 判断是否匹配正则表达式，匹配返回true，不匹配返回false。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css">字符类(默认匹配一个字符)<br><br><span class="hljs-selector-attr">[abc]</span>     只能是<span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span>, 或c<br><br><span class="hljs-selector-attr">[^abc]</span>     除了<span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span>, c之外的任何字符<br><br><span class="hljs-selector-attr">[a-zA-Z]</span>        <span class="hljs-selector-tag">a</span>到z <span class="hljs-selector-tag">A</span>到Z，包括（范围）<br><br><span class="hljs-selector-attr">[a-d[m-p]</span>]     <span class="hljs-selector-tag">a</span>到d，或m通过<span class="hljs-selector-tag">p</span>：（<span class="hljs-selector-attr">[a-dm-p]</span>联合）<br><br><span class="hljs-selector-attr">[a-z&amp;&amp;[def]</span>]     d, e, 或f(交集)<br><br><span class="hljs-selector-attr">[a-z&amp;&amp;[^bc]</span>]     <span class="hljs-selector-tag">a</span>到z，除了<span class="hljs-selector-tag">b</span>和c：（<span class="hljs-selector-attr">[ad-z]</span>减法）<br><br><span class="hljs-selector-attr">[a-z&amp;&amp;[^m-p]</span>]   <span class="hljs-selector-tag">a</span>到z，除了m到<span class="hljs-selector-tag">p</span>：（<span class="hljs-selector-attr">[a-lq-z]</span>减法）<br></code></pre></td></tr></table></figure><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livescript">预定义的字符类(默认匹配一个字符)<br>.任何字符<br><span class="hljs-string">\d</span>一个数字： [<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]<br><span class="hljs-string">\D</span>非数字： [^<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]<br><span class="hljs-string">\s</span>一个空白字符： [ <span class="hljs-string">\t\n\x0B\f\r]</span><br><span class="hljs-string">\S</span>非空白字符： [^<span class="hljs-string">\s]</span><br><span class="hljs-string">\w</span>[a-zA-Z_0-<span class="hljs-number">9</span>] 英文、数字、下划线<br><span class="hljs-string">\W</span> [^<span class="hljs-string">\w]</span> 一个非单词字符<br></code></pre></td></tr></table></figure><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tp">贪婪的量词（配合匹配多个字符）<br><span class="hljs-keyword">X</span>?<span class="hljs-keyword">X</span> , 一次或根本不<br><span class="hljs-keyword">X</span>*<span class="hljs-keyword">X</span>，零次或多次<br><span class="hljs-keyword">X</span>+<span class="hljs-keyword">X</span> , 一次或多次<br><span class="hljs-keyword">X</span> &#123;n&#125;<span class="hljs-keyword">X</span>，正好n次<br><span class="hljs-keyword">X</span> &#123;n, &#125;<span class="hljs-keyword">X</span>，至少n次<br><span class="hljs-keyword">X</span> &#123;n,m&#125;<span class="hljs-keyword">X</span>，至少n但不超过m次<br></code></pre></td></tr></table></figure><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public String replaceAll(String regex,String newStr）</td><td>按照正则表达式匹配的内容进行替换</td></tr><tr><td>public String[] split(String regex)：</td><td>按照正则表达式匹配的内容进行分割字符串，反回一个字符串数组。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.d6_regex;<br><br><span class="hljs-keyword">import</span> java.util.regex.Matcher;<br><span class="hljs-keyword">import</span> java.util.regex.Pattern;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    拓展：正则表达式爬取信息中的内容。(了解)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegexDemo05</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;来黑马程序学习Java,电话020-43422424，或者联系邮箱&quot;</span> +<br>                <span class="hljs-string">&quot;itcast@itcast.cn,电话18762832633，0203232323&quot;</span> +<br>                <span class="hljs-string">&quot;邮箱bozai@itcast.cn，400-100-3233 ，4001003232&quot;</span>;<br><br>        <span class="hljs-comment">// 需求：从上面的内容中爬取出 电话号码和邮箱。</span><br>        <span class="hljs-comment">// 1、定义爬取规则，字符串形式</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(\\w&#123;1,30&#125;@[a-zA-Z0-9]&#123;2,20&#125;(\\.[a-zA-Z0-9]&#123;2,20&#125;)&#123;1,2&#125;)|(1[3-9]\\d&#123;9&#125;)&quot;</span> +<br>                <span class="hljs-string">&quot;|(0\\d&#123;2,6&#125;-?\\d&#123;5,20&#125;)|(400-?\\d&#123;3,9&#125;-?\\d&#123;3,9&#125;)&quot;</span>;<br><br>        <span class="hljs-comment">// 2、把这个爬取规则编译成匹配对象。</span><br>        <span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern.compile(regex);<br><br>        <span class="hljs-comment">// 3、得到一个内容匹配器对象</span><br>        <span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> pattern.matcher(rs);<br><br>        <span class="hljs-comment">// 4、开始找了</span><br>        <span class="hljs-keyword">while</span> (matcher.find()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">rs1</span> <span class="hljs-operator">=</span> matcher.group();<br>            System.out.println(rs1);<br>        &#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="Arrays类概述"><a href="#Arrays类概述" class="headerlink" title="Arrays类概述"></a><strong>Arrays</strong>类概述</h4><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static <a href="mk:@MSITStore:C:\course\API文档\jdk-9_google.CHM::/java/lang/String.html">String</a> toString(类型[] a)</td><td>返回数组的内容（字符串形式）</td></tr><tr><td>public static void sort(类型[] a)</td><td>对数组进行默认升序排序</td></tr><tr><td>public static <T> void sort(类型[] a, <a href="mk:@MSITStore:C:\course\API文档\jdk-9_google.CHM::/java/util/Comparator.html">Comparator</a>&lt;? super T&gt; c)</td><td>使用比较器对象自定义排序</td></tr><tr><td>public static int binarySearch(int[] a, int key)</td><td>二分搜索数组中的数据，存在返回索引，不存在返回-1</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">如果认为左边数据 大于 右边数据 返回正整数</span><br><span class="hljs-comment">如果认为左边数据 小于 右边数据  返回负整数</span><br><span class="hljs-comment">如果认为左边数据  等于 右边数据  返回0</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArraysDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：自定义数组的排序规则：Comparator比较器对象。</span><br>        <span class="hljs-comment">// 1、Arrays的sort方法对于有值特性的数组是默认升序排序</span><br>        <span class="hljs-type">int</span>[] ages = &#123;<span class="hljs-number">34</span>, <span class="hljs-number">12</span>, <span class="hljs-number">42</span>, <span class="hljs-number">23</span>&#125;;<br>        Arrays.sort(ages);<br>        System.out.println(Arrays.toString(ages));<br><br>        <span class="hljs-comment">// 2、需求：降序排序！(自定义比较器对象，只能支持引用类型的排序！！)</span><br>        Integer[] ages1 = &#123;<span class="hljs-number">34</span>, <span class="hljs-number">12</span>, <span class="hljs-number">42</span>, <span class="hljs-number">23</span>&#125;;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">           参数一：被排序的数组 必须是引用类型的元素</span><br><span class="hljs-comment">           参数二：匿名内部类对象，代表了一个比较器对象。</span><br><span class="hljs-comment">         */</span><br>        Arrays.sort(ages1, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;<br>                <span class="hljs-comment">// 指定比较规则。</span><br><span class="hljs-comment">//                if(o1 &gt; o2)&#123;</span><br><span class="hljs-comment">//                    return 1;</span><br><span class="hljs-comment">//                &#125;else if(o1 &lt; o2)&#123;</span><br><span class="hljs-comment">//                    return -1;</span><br><span class="hljs-comment">//                &#125;</span><br><span class="hljs-comment">//                return 0;</span><br>                <span class="hljs-comment">// return o1 - o2; // 默认升序</span><br>                <span class="hljs-keyword">return</span> o2 - o1; <span class="hljs-comment">//  降序</span><br>            &#125;<br>        &#125;);<br>        System.out.println(Arrays.toString(ages1));<br><br>        System.out.println(<span class="hljs-string">&quot;-------------------------&quot;</span>);<br>        Student[] students = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>[<span class="hljs-number">3</span>];<br>        students[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;吴磊&quot;</span>,<span class="hljs-number">23</span> , <span class="hljs-number">175.5</span>);<br>        students[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;谢鑫&quot;</span>,<span class="hljs-number">18</span> , <span class="hljs-number">185.5</span>);<br>        students[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;王亮&quot;</span>,<span class="hljs-number">20</span> , <span class="hljs-number">195.5</span>);<br>        System.out.println(Arrays.toString(students));<br><br>        <span class="hljs-comment">// Arrays.sort(students);  // 直接运行奔溃</span><br>        Arrays.sort(students, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Student&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Student o1, Student o2)</span> &#123;<br>                <span class="hljs-comment">// 自己指定比较规则</span><br>                <span class="hljs-comment">// return o1.getAge() - o2.getAge(); // 按照年龄升序排序！</span><br>                <span class="hljs-comment">// return o2.getAge() - o1.getAge(); // 按照年龄降序排序！！</span><br>                <span class="hljs-comment">// return Double.compare(o1.getHeight(), o2.getHeight()); // 比较浮点型可以这样写 升序</span><br>                <span class="hljs-keyword">return</span> Double.compare(o2.getHeight(), o1.getHeight()); <span class="hljs-comment">// 比较浮点型可以这样写  降序</span><br>            &#125;<br>        &#125;);<br>        System.out.println(Arrays.toString(students));<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><p><strong>Lambda概述</strong><br>●Lambda:表达式是JDK8开始后的一种新语法形式。<br>●作用：简化匿名内部类的代码写法。<br><strong>Lambda表达式的简化格式</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean">（匿名内部类被重写方法的形参列表）-&gt;&#123;<br>被重写方法的方法体代码。<br>&#125;<br>注：-&gt;是语法形式，无实际含义<br></code></pre></td></tr></table></figure><p><strong>注意：Lambda表达式只能简化函数式接口的匿名内部类的写法形式</strong></p><p>什么是函数式接口？<br>●首先必须是接口、其次接口中有且仅有一个抽象方法的形式<br>●通常我们会在接口上加上一个@Functionallnterface注解，标记该接口必须是满足函数式接口。</p><p>1、Lambda表达式的基本作用？<br>●简化函数式接口的匿名内部类的写法。<br>2、Lambda表达式有什么使用前提？<br>●必须是接口的匿名内部类，接口中只能有一个抽象方法<br>3、Lambda的好处？<br>●Lambda是一个匿名函数，我们可以把Lambda表达式理解为<br>是一段可以传递的代码，它可以写出更简洁、更灵活的代码，<br>作为一种更紧凑的代码风格，使va语言表达能力得到了提升。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LambdaDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：学会使用Lambda的标准格式简化匿名内部类的代码形式</span><br>        <span class="hljs-comment">// 注意：Lambda只能简化接口中只有一个抽象方法的匿名内部类形式（函数式接口）</span><br><span class="hljs-comment">//        Swimming s1 = new Swimming() &#123;</span><br><span class="hljs-comment">//            @Override</span><br><span class="hljs-comment">//            public void swim() &#123;</span><br><span class="hljs-comment">//                System.out.println(&quot;老师游泳贼溜~~~~~&quot;);</span><br><span class="hljs-comment">//            &#125;</span><br><span class="hljs-comment">//        &#125;;</span><br><br><span class="hljs-comment">//        Swimming s1 = () -&gt; &#123;</span><br><span class="hljs-comment">//            System.out.println(&quot;老师游泳贼溜~~~~~&quot;);</span><br><span class="hljs-comment">//        &#125;;</span><br><br>        <span class="hljs-type">Swimming</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">&quot;老师游泳贼溜~~~~~&quot;</span>);<br>        go(s1);<br><br>        System.out.println(<span class="hljs-string">&quot;---------------------&quot;</span>);<br><span class="hljs-comment">//        go(new Swimming() &#123;</span><br><span class="hljs-comment">//            @Override</span><br><span class="hljs-comment">//            public void swim() &#123;</span><br><span class="hljs-comment">//                System.out.println(&quot;学生游泳很开心~~~&quot;);</span><br><span class="hljs-comment">//            &#125;</span><br><span class="hljs-comment">//        &#125;);</span><br><br><span class="hljs-comment">//        go(() -&gt;&#123;</span><br><span class="hljs-comment">//                System.out.println(&quot;学生游泳很开心~~~&quot;);</span><br><span class="hljs-comment">//        &#125;);</span><br><br>        go(() -&gt; System.out.println(<span class="hljs-string">&quot;学生游泳很开心~~~&quot;</span>));<br><br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">go</span><span class="hljs-params">(Swimming s)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;开始。。。&quot;</span>);<br>        s.swim();<br>        System.out.println(<span class="hljs-string">&quot;结束。。。&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@FunctionalInterface</span> <span class="hljs-comment">// 一旦加上这个注解必须是函数式接口，里面只能有一个抽象方法</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Swimming</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Lambda表达式的省略写法(进一步在Lambda表达式的基础上继续简化)<br>参数类型可以省略不写。<br>●如果只有一个参数，参数类型可以省略，同时）也可以省略。<br>●如果Lambda表达式的方法体代码只有一行代码。可以省略大括号不写，同时要省略分号！<br>●如果Lambda表达式的方法体代码只有一行代码。可以省略大括号不写。此时，如果这行代码是<span class="hljs-keyword">return</span>语句，必须省略<span class="hljs-keyword">return</span>不写，同时也必须省略<span class="hljs-string">&quot;，&quot;</span>不写<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LambdaDemo3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Integer[] ages1 = &#123;<span class="hljs-number">34</span>, <span class="hljs-number">12</span>, <span class="hljs-number">42</span>, <span class="hljs-number">23</span>&#125;;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         参数一：被排序的数组 必须是引用类型的元素</span><br><span class="hljs-comment">         参数二：匿名内部类对象，代表了一个比较器对象。</span><br><span class="hljs-comment">         */</span><br><span class="hljs-comment">//        Arrays.sort(ages1, new Comparator&lt;Integer&gt;() &#123;</span><br><span class="hljs-comment">//            @Override</span><br><span class="hljs-comment">//            public int compare(Integer o1, Integer o2) &#123;</span><br><span class="hljs-comment">//                return o2 - o1; //  降序</span><br><span class="hljs-comment">//            &#125;</span><br><span class="hljs-comment">//        &#125;);</span><br><br><span class="hljs-comment">//        Arrays.sort(ages1, (Integer o1, Integer o2) -&gt; &#123;</span><br><span class="hljs-comment">//                return o2 - o1; //  降序</span><br><span class="hljs-comment">//        &#125;);</span><br><br><br><span class="hljs-comment">//        Arrays.sort(ages1, ( o1,  o2) -&gt; &#123;</span><br><span class="hljs-comment">//            return o2 - o1; //  降序</span><br><span class="hljs-comment">//        &#125;);</span><br><br>        Arrays.sort(ages1, ( o1,  o2 ) -&gt;  o2 - o1 );<br><br>        System.out.println(Arrays.toString(ages1));<br><br>        System.out.println(<span class="hljs-string">&quot;---------------------------&quot;</span>);<br>        <span class="hljs-type">JFrame</span> <span class="hljs-variable">win</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JFrame</span>(<span class="hljs-string">&quot;登录界面&quot;</span>);<br>        <span class="hljs-type">JButton</span> <span class="hljs-variable">btn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JButton</span>(<span class="hljs-string">&quot;我是一个很大的按钮&quot;</span>);<br><span class="hljs-comment">//        btn.addActionListener(new ActionListener() &#123;</span><br><span class="hljs-comment">//            @Override</span><br><span class="hljs-comment">//            public void actionPerformed(ActionEvent e) &#123;</span><br><span class="hljs-comment">//                System.out.println(&quot;有人点我，点我，点我！！&quot;);</span><br><span class="hljs-comment">//            &#125;</span><br><span class="hljs-comment">//        &#125;);</span><br><br><span class="hljs-comment">//        btn.addActionListener((ActionEvent e) -&gt; &#123;</span><br><span class="hljs-comment">//                System.out.println(&quot;有人点我，点我，点我！！&quot;);</span><br><span class="hljs-comment">//        &#125;);</span><br><br><span class="hljs-comment">//        btn.addActionListener(( e) -&gt; &#123;</span><br><span class="hljs-comment">//            System.out.println(&quot;有人点我，点我，点我！！&quot;);</span><br><span class="hljs-comment">//        &#125;);</span><br><br><span class="hljs-comment">//        btn.addActionListener( e -&gt; &#123;</span><br><span class="hljs-comment">//            System.out.println(&quot;有人点我，点我，点我！！&quot;);</span><br><span class="hljs-comment">//        &#125;);</span><br><br>        btn.addActionListener( e -&gt; System.out.println(<span class="hljs-string">&quot;有人点我，点我，点我！！&quot;</span>) );<br>        <br>        win.add(btn);<br>        win.setSize(<span class="hljs-number">400</span>, <span class="hljs-number">300</span>);<br>        win.setVisible(<span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="集合collection"><a href="#集合collection" class="headerlink" title="集合collection"></a>集合collection</h4><p>集合是java中存储对象数据的一种容器。</p><h6 id="集合的特点"><a href="#集合的特点" class="headerlink" title="集合的特点"></a><strong>集合的特点</strong></h6><ul><li>集合的大小不固定，启动后可以动态变化，类型也可以选择不固定。集合更像气球。</li><li>集合非常适合做元素的增删操作。</li><li>注意：集合中只能存储<strong>引用类型数据</strong>，如果要存储基本类型数据可以选用包装类。</li></ul><p><strong>1、数组和集合的元素存储的个数问题。</strong><br>    ●数组定义后类型确定，长度固定<br>    ●集合类型可以不固定，大小是可变的。<br><strong>2、数组和集合存储元素的类型问题。</strong><br>    ●数组可以存储基本类型和引用类型的数据。<br>    ●集合只能存储引用数据类型的数据。<br><strong>3、数组和集合适合的场景</strong><br>    ●数组适合做数据个数和类型确定的场景。<br>    ●集合适合做数据个数不确定，且要做增删元素的场景。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220425105730336.png" alt="image-20220425105730336"></p><p><img src="JAVA%E5%9F%BA%E7%A1%80.assets/image-20220425105950636.png" alt="image-20220425105950636"></p><p><strong>Collection集合特点</strong><br>●<strong>List系列集合</strong>：添加的元素是有序、可重复、有索引。<br>    ◆ArrayList、LinekdList:有序。可重复、有奏引。<br>●<strong>Set系列集合</strong>：添加的元素是无序、不重复、无索引。<br>    ◆HashSet:无序、不重复、无索引；LinkedHashSet:<strong>有序</strong>、不重复、无索引。<br>    ◆TreeSet:<strong>按照大小默认升序排序</strong>、不重复、无索引。</p><h6 id="集合常用用法及常用API"><a href="#集合常用用法及常用API" class="headerlink" title="集合常用用法及常用API"></a>集合常用用法及常用API</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection &lt;String&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collection &lt;Integer&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collection &lt;Double&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Object[] arrs =c.toArrays()<span class="hljs-comment">//把集合转化为整数</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public  boolean add(E e)</td><td>把给定的对象添加到当前集合中</td></tr><tr><td>public  void clear()</td><td>清空集合中所有的元素</td></tr><tr><td>public  boolean remove(E e)</td><td>把给定的对象在当前集合中删除</td></tr><tr><td>public  boolean contains(Object obj)</td><td>判断当前集合中是否包含给定的对象</td></tr><tr><td>public  boolean isEmpty()</td><td>判断当前集合是否为空</td></tr><tr><td>public  int size()</td><td>返回集合中元素的个数。</td></tr><tr><td>public  Object[] toArray()</td><td>把集合中的元素，存储到数组中</td></tr></tbody></table><p><strong>遍历集合</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Iterator&lt;String&gt; it = lists.iterator();<br> <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>   <span class="hljs-type">String</span> <span class="hljs-variable">ele</span> <span class="hljs-operator">=</span> it.next();<br>   System.out.println(ele);<br> &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">for</span>(String ele : list) &#123;<span class="hljs-comment">//list.for快捷键</span><br>System.out.println(ele);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">lists.forEach(s -&gt; &#123;<br>      System.out.println(s);<br> &#125;);<br></code></pre></td></tr></table></figure><h6 id="各种数据结构的特点和作用是什么样的"><a href="#各种数据结构的特点和作用是什么样的" class="headerlink" title="各种数据结构的特点和作用是什么样的"></a>各种数据结构的特点和作用是什么样的</h6><ul><li>队列：先进先出，后进后出。</li><li>栈：后进先出，先进后出。</li><li>数组：内存连续区域，查询快，增删慢。</li><li>链表：元素是游离的，查询慢，首尾操作极快。</li><li>二叉树：永远只有一个根节点，每个结点不超过2个子节点的树。</li><li>查找二叉树：小的左边，大的右边，但是可能树很高，查询性能变差。</li><li>平衡查找二叉树：让树的高度差不大于1，增删改查都提高了。</li><li>红黑树（就是基于红黑规则实现了自平衡的排序二叉树）</li></ul><h6 id="ArrayList集合底层原理"><a href="#ArrayList集合底层原理" class="headerlink" title="ArrayList集合底层原理"></a>ArrayList集合底层原理</h6><p>ArrayList底层是基于数组实现的：根据索引定位元素快，增删需要做元素的移位操作。<br>第一次创建集合并添加第一个元素的时候，在底层创建一个默认长度为10的数组。满了后每次扩容1.5倍，迁移。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220425201738284.png" alt="image-20220425201738284"></p><h6 id="LinkedList的特点-适用于栈和队列"><a href="#LinkedList的特点-适用于栈和队列" class="headerlink" title="LinkedList的特点(适用于栈和队列)"></a>LinkedList的特点(适用于栈和队列)</h6><p>●底层数据结构是双链表，查询慢，首尾操作的速度是极快的，所以多了很多首尾操作的特有API。</p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public  void addFirst(E e)</td><td>在该列表开头插入指定的元素</td></tr><tr><td>public  void addLast(E e)</td><td>将指定的元素追加到此列表的末尾</td></tr><tr><td>public  E getFirst()</td><td>返回此列表中的第一个元素</td></tr><tr><td>public  E getLast()</td><td>返回此列表中的最后一个元素</td></tr><tr><td>public  E removeFirst()</td><td>从此列表中删除并返回第一个元素</td></tr><tr><td>public  E removeLast()</td><td>从此列表中删除并返回最后一个元素</td></tr></tbody></table><h6 id="并发增删异常"><a href="#并发增删异常" class="headerlink" title="并发增删异常"></a>并发增删异常</h6><p><strong>当我们从集合中找出某个元素并删除的时候可能出现一种并发修改异常问题。</strong><br><strong>哪些遍历存在问题？</strong><br>迭代器遍历集合且直接用集合删除元素的时候可能出现。</p><p>增强for循环遍历集合且直接用集合删除元素的时候可能出现。</p><p><strong>哪种遍历且删除元素不出问题</strong><br>迭代器遍历集合但是用迭代器自己的删除方法操作可以解决。</p><p>使用for循环遍历并别除元素不会存在这个问题。</p><h4 id="泛型概述"><a href="#泛型概述" class="headerlink" title="泛型概述"></a>泛型概述</h4><ul><li>泛型：是DK5中引入的特性，可以在编译阶段约束操作的数据类型，并进行检查。</li><li>泛型的格式：&lt;数据类型&gt;；注意：泛型只能支持引用数据类型。</li><li>集合体系的全部接口和实现类都是支持泛型的使用的。</li></ul><h6 id="泛型的好处："><a href="#泛型的好处：" class="headerlink" title="泛型的好处："></a>泛型的好处：</h6><ul><li>统一数据类型。</li><li>把运行时期的问题提前到了编译期间，避免了强制类型转换可能出现的异常，因为编译阶段类型就能确定下来。</li></ul><p><strong>模拟ArrayList集合自定义一个集合MyArrayLists集合，完成添加和删除功能的泛型设计即可。</strong></p><h6 id="1、泛型类的核心思想："><a href="#1、泛型类的核心思想：" class="headerlink" title="1、泛型类的核心思想："></a><strong>1、泛型类的核心思想：</strong></h6><p>把出现泛型变量的地方全部替换成传输的真实数据类型</p><h6 id="2、泛型类的作用"><a href="#2、泛型类的作用" class="headerlink" title="2、泛型类的作用"></a><strong>2、泛型类的作用</strong></h6><p>编译阶段约定操作的数据的类型，类似于集合的作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 需求：模拟ArrayList定义一个MyArrayList ，关注泛型设计</span><br>    MyArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyArrayList</span>&lt;&gt;();<br>    list.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;MySQL&quot;</span>);<br>    list.remove(<span class="hljs-string">&quot;MySQL&quot;</span>);<br>    System.out.println(list);<br><br>    MyArrayList&lt;Integer&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyArrayList</span>&lt;&gt;();<br>    list2.add(<span class="hljs-number">23</span>);<br>    list2.add(<span class="hljs-number">24</span>);<br>    list2.add(<span class="hljs-number">25</span>);<br>    list2.remove(<span class="hljs-number">25</span>);<br>    System.out.println(list2);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArrayList</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ArrayList</span> <span class="hljs-variable">lists</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span>&#123;<br>        lists.add(e);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(E e)</span>&#123;<br>        lists.remove(e);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> lists.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="泛型方法的概述"><a href="#泛型方法的概述" class="headerlink" title="泛型方法的概述"></a>泛型方法的概述</h6><p>定义方法时同时定义了泛型的方法就是泛型方法。<br>泛型方法的格式：修饰符&lt;泛型变量&gt;方法返回值方法名称（形参列表）川</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">范例：<span class="hljs-keyword">public</span>&lt;T&gt;<span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(T t)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        String[] names = &#123;<span class="hljs-string">&quot;小璐&quot;</span>, <span class="hljs-string">&quot;蓉容&quot;</span>, <span class="hljs-string">&quot;小何&quot;</span>&#125;;<br>        printArray(names);<br><br>        Integer[] ages = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br>        printArray(ages);<br><br>        Integer[] ages2 = getArr(ages);<br>        String[]  names2 = getArr(names);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T[] getArr(T[] arr)&#123;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">(T[] arr)</span>&#123;<br>        <span class="hljs-keyword">if</span>(arr != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;[&quot;</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>                sb.append(arr[i]).append(i == arr.length - <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;&quot;</span> : <span class="hljs-string">&quot;, &quot;</span>);<br>            &#125;<br>            sb.append(<span class="hljs-string">&quot;]&quot;</span>);<br>            System.out.println(sb);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            System.out.println(arr);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="泛型接口的概述"><a href="#泛型接口的概述" class="headerlink" title="泛型接口的概述"></a>泛型接口的概述</h6><p>使用了泛型定义的接口就是泛型接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">泛型接口的格式：修饰符interface接口名称&lt;泛型变量&gt;&#123;&#125;<br>范例：<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Data</span>&lt;E&gt;&#123;&#125;<br></code></pre></td></tr></table></figure><p>作用：泛型接口可以让实现类选择当前功能需要操作的数据类型。</p><p>教务系统，提供一个接口可约束一定要完成数据（学生，老师）的增删改查操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Data</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(E e)</span>;<br>    E <span class="hljs-title function_">queryById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TeacherData</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Data</span>&lt;Teacher&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Teacher teacher)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Teacher teacher)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Teacher <span class="hljs-title function_">queryById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：泛型通配符。?</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    需求：开发一个极品飞车的游戏，所有的汽车都能一起参与比赛。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    注意：</span><br><span class="hljs-comment">        虽然BMW和BENZ都继承了Car</span><br><span class="hljs-comment">        但是ArrayList&lt;BMW&gt;和ArrayList&lt;BENZ&gt;与ArrayList&lt;Car&gt;没有关系的！!</span><br><span class="hljs-comment">    通配符：？</span><br><span class="hljs-comment">        ？可以在“使用泛型”的时候代表一切类型。</span><br><span class="hljs-comment">        E T K V 是在定义泛型的时候使用的。</span><br><span class="hljs-comment">    泛型的上下限：</span><br><span class="hljs-comment">        ？ extends Car : ?必须是Car或者其子类  泛型上限</span><br><span class="hljs-comment">        ? super Car ：？必须是Car或者其父类   泛型下限</span><br><span class="hljs-comment">    小结：</span><br><span class="hljs-comment">        通配符：？</span><br><span class="hljs-comment">        ？可以在“使用泛型”的时候代表一切类型。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;BMW&gt; bmws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        bmws.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BMW</span>());<br>        bmws.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BMW</span>());<br>        bmws.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BMW</span>());<br>        go(bmws);<br><br>        ArrayList&lt;BENZ&gt; benzs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        benzs.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BENZ</span>());<br>        benzs.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BENZ</span>());<br>        benzs.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BENZ</span>());<br>        go(benzs);<br><br>        ArrayList&lt;Dog&gt; dogs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        dogs.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>());<br>        dogs.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>());<br>        dogs.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>());<br>        <span class="hljs-comment">// go(dogs);</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">       所有车比赛，?通配符</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">go</span><span class="hljs-params">(ArrayList&lt;? extends Car&gt; cars)</span>&#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>&#123;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BENZ</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span>&#123;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BMW</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span>&#123;<br>&#125;<br><br><span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a><strong>Set集合</strong></h4><h6 id="Set系列集合特点"><a href="#Set系列集合特点" class="headerlink" title="Set系列集合特点"></a>Set系列集合特点</h6><p><strong>无序</strong>：存取顺序不一致<br><strong>不重复</strong>：可以去除重复<br><strong>无索引</strong>：没有带索引的方法，所以不能使用普通fo循环遍历，也不能通过索引来获取元素。</p><h6 id="Set集合实现类特点"><a href="#Set集合实现类特点" class="headerlink" title="Set集合实现类特点"></a>Set集合实现类特点</h6><p><strong>HashSet</strong>:无序、不重复、无索引。<br><strong>LinkedHashSet</strong>:有序、不重复、无索引。<br><strong>TreeSet</strong>:排序、不重复、无索引。</p><h6 id="HashSet底层原理"><a href="#HashSet底层原理" class="headerlink" title="HashSet底层原理"></a>HashSet底层原理</h6><ul><li>HashSets集合底层采取哈希表存储的数据。</li><li>哈希表是一种对于增删改查数据性能都较好的结构。</li></ul><h6 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h6><ul><li>是JDK根据对象的地址，按照某种规则算出来的it类型的数值。</li><li>Object类的API:public int hashCode（）:返回对象的哈希值</li></ul><h6 id="对象的哈希值特点"><a href="#对象的哈希值特点" class="headerlink" title="对象的哈希值特点"></a>对象的哈希值特点</h6><ul><li>同一个对象多次调用nashCode(O方法返回的哈希值是相同的</li><li>默认情况下，不同对象的哈希值是不同的。</li><li><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230320143432642.png" alt="image-20230320143432642"></li></ul><ol><li><p>创建一个默认长度16的数组，数组名table</p></li><li><p>根据元素的哈希值跟数组的长度求余计算出应存入的位置（哈希算法）</p></li><li><p>判断当前位置是否为null,如果是null直接存入</p></li><li><p>如果位置不为null,表示有元素，则调用equals方法比较</p></li><li><p>如果一样，则不存，如果不一样，则存入数组，</p><ul><li><p>​    DK7新元素占老元素位置，指向老元素</p></li><li><p>​    JDK8中新元素挂在老元素下面</p></li></ul></li></ol><h6 id="JDK1-8版本开始HashSet原理解析"><a href="#JDK1-8版本开始HashSet原理解析" class="headerlink" title="JDK1.8版本开始HashSet原理解析"></a>JDK1.8版本开始HashSet原理解析</h6><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220426143547400.png" alt="image-20220426143547400"></p><p>1.底层结构：哈希表(数组、链表、红黑树的结合体)。<br>2.当挂在元素下面的数据过多时，查询性能降低，从JDK8开始后，当链表长度超过8的时候，自动转换为红黑树。</p><h6 id="2-哈希表的详细流程"><a href="#2-哈希表的详细流程" class="headerlink" title="2.哈希表的详细流程"></a>2.哈希表的详细流程</h6><p>①创建一个默认长度16，默认加载因为0.75的数组，数组名table。<br>②根据元素的哈希值跟数组的长度计算出应存入的位置。<br>③判断当前位置是否为nul,如果是nul直接存入，如果位置不为null,表示有元素则调用equals方法比较属性值，如果一样，则不存，如果不一样，则存入数组。<br>④当数组存满到16*0.75=12时，就自动扩容，每次扩容原先的两倍</p><p>结论：如果希望Set集合认为2个内容一样的对象是重复的，必须重写对象的hashCode()和equals()方法</p><h6 id="linkhashset原理："><a href="#linkhashset原理：" class="headerlink" title="linkhashset原理："></a>linkhashset原理：</h6><p>原理：底层数据结构是依然哈希表，只是每个元素又额外的多了一个双链表的机制记录存储的顺序。</p><h6 id="TreeSet集合概述和特点"><a href="#TreeSet集合概述和特点" class="headerlink" title="TreeSet集合概述和特点"></a>TreeSet集合概述和特点</h6><p>不重复、无索引、可排序<br>可排序：按照元素的大小默认升序（有小到大）排序。<br>TreeSet集合底层是基于红黑树的数据结构实现排序的，增删改查性能好。<br>注意：TreeSet集合是一定要排序的，可以将元素按照指定的规则进行序。</p><p>2.TreeSet集合自定义排序规则有几种方式<br>●2种。<br>●类实现Comparable接口，重写比较规则。<br>●集合自定义Comparator比较器对象，重写比较规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Apple&gt;&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String color;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> price;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> weight;<br>    .<br>    .<br>    .<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">      方式一：类自定义比较规则</span><br><span class="hljs-comment">      o1.compareTo(o2)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> o</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Apple o)</span> &#123;<br>        <span class="hljs-comment">// 按照重量进行比较的</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.weight - o.weight ; <span class="hljs-comment">// 去重重量重复的元素</span><br>        <span class="hljs-comment">// return this.weight - o.weight &gt;= 0 ? 1 : -1; // 保留重量重复的元素</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SetDemo5</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Set&lt;Integer&gt; sets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;(); <span class="hljs-comment">// 不重复 无索引 可排序</span><br>        sets.add(<span class="hljs-number">23</span>);<br>        sets.add(<span class="hljs-number">24</span>);<br>        sets.add(<span class="hljs-number">12</span>);<br>        sets.add(<span class="hljs-number">8</span>);<br>        System.out.println(sets);<br><br>        Set&lt;String&gt; sets1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;(); <span class="hljs-comment">// 不重复 无索引 可排序</span><br>        sets1.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        sets1.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        sets1.add(<span class="hljs-string">&quot;angela&quot;</span>);<br>        sets1.add(<span class="hljs-string">&quot;黑马&quot;</span>);<br>        sets1.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        sets1.add(<span class="hljs-string">&quot;About&quot;</span>);<br>        sets1.add(<span class="hljs-string">&quot;Python&quot;</span>);<br>        sets1.add(<span class="hljs-string">&quot;UI&quot;</span>);<br>        sets1.add(<span class="hljs-string">&quot;UI&quot;</span>);<br>        System.out.println(sets1);<br><br>        System.out.println(<span class="hljs-string">&quot;------------------------------&quot;</span>);<br>        <span class="hljs-comment">// 方式二：集合自带比较器对象进行规则定制</span><br>        <span class="hljs-comment">//</span><br><span class="hljs-comment">//        Set&lt;Apple&gt; apples = new TreeSet&lt;&gt;(new Comparator&lt;Apple&gt;() &#123;</span><br><span class="hljs-comment">//            @Override</span><br><span class="hljs-comment">//            public int compare(Apple o1, Apple o2) &#123;</span><br><span class="hljs-comment">//                // return o1.getWeight() - o2.getWeight(); // 升序</span><br><span class="hljs-comment">//                // return o2.getWeight() - o1.getWeight(); // 降序</span><br><span class="hljs-comment">//                // 注意：浮点型建议直接使用Double.compare进行比较</span><br><span class="hljs-comment">//                // return Double.compare(o1.getPrice() , o2.getPrice()); // 升序</span><br><span class="hljs-comment">//                return Double.compare(o2.getPrice() , o1.getPrice()); // 降序</span><br><span class="hljs-comment">//            &#125;</span><br><span class="hljs-comment">//        &#125;);</span><br><br>        Set&lt;Apple&gt; apples = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;(( o1,  o2) -&gt;  Double.compare(o2.getPrice() , o1.getPrice())  );<br>        apples.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>(<span class="hljs-string">&quot;红富士&quot;</span>, <span class="hljs-string">&quot;红色&quot;</span>, <span class="hljs-number">9.9</span>, <span class="hljs-number">500</span>));<br>        apples.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>(<span class="hljs-string">&quot;青苹果&quot;</span>, <span class="hljs-string">&quot;绿色&quot;</span>, <span class="hljs-number">15.9</span>, <span class="hljs-number">300</span>));<br>        apples.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>(<span class="hljs-string">&quot;绿苹果&quot;</span>, <span class="hljs-string">&quot;青色&quot;</span>, <span class="hljs-number">29.9</span>, <span class="hljs-number">400</span>));<br>        apples.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>(<span class="hljs-string">&quot;黄苹果&quot;</span>, <span class="hljs-string">&quot;黄色&quot;</span>, <span class="hljs-number">9.8</span>, <span class="hljs-number">500</span>));<br>        System.out.println(apples);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>1.如果希望元素可以重复，又有索引，索引查询要快？<br>    ●用ArrayList?集合，基于数组的。（用的最多）<br>2.如果希望元素可以重复，又有索引，增删首尾操作快？<br>    ●用LinkedList集合，基于链表的。<br>3.如果希望增删改查都快，但是元素不重复、无序、无索引。<br>    ●用HashSet集合，基于哈希表的。<br>4.如果希望增删改查都快，但是元素不重复、有序、无索引。<br>    ●用LinkedHashSet集合，基于哈希表和双链表。<br>5.如果要对对象进行排序。<br>    ●用TreeSet:集合，基于红黑树。后续也可以用List集合实现排序。</p><h6 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h6><p>●可变参数用在形参中可以接收多个数据。<br>可变参数的格式：数据类型…参数名称<br><strong>可变参数的作用</strong><br>●传输参数非常灵活，方便。可以不传输参数，可以传输1个或者多个，也可以传输一个数组</p><p>●可变参数在方法内部本质上就是一个数组。</p><p><strong>可变参数的注意事项：</strong><br>●1.一个形参列表中可变参数只能有一个<br>●2.可变参数必须放在形参列表的最后面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        sum(); <span class="hljs-comment">// 1、不传参数</span><br>        sum(<span class="hljs-number">10</span>); <span class="hljs-comment">// 2、可以传输一个参数</span><br>        sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>); <span class="hljs-comment">// 3、可以传输多个参数</span><br>        sum(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;); <span class="hljs-comment">// 4、可以传输一个数组</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">       注意：一个形参列表中只能有一个可变参数,可变参数必须放在形参列表的最后面</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nums</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(  <span class="hljs-type">int</span>...nums)</span>&#123;<br>        <span class="hljs-comment">// 注意：可变参数在方法内部其实就是一个数组。 nums</span><br>        System.out.println(<span class="hljs-string">&quot;元素个数：&quot;</span> + nums.length);<br>        System.out.println(<span class="hljs-string">&quot;元素内容：&quot;</span> + Arrays.toString(nums));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：Collections工具类的使用。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    java.utils.Collections:是集合工具类</span><br><span class="hljs-comment">    Collections并不属于集合，是用来操作集合的工具类。</span><br><span class="hljs-comment">    Collections有几个常用的API:</span><br><span class="hljs-comment">         - public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c, T... elements)</span><br><span class="hljs-comment">             给集合对象批量添加元素！</span><br><span class="hljs-comment">         - public static void shuffle(List&lt;?&gt; list) :打乱集合顺序。</span><br><span class="hljs-comment">         - public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。</span><br><span class="hljs-comment">         - public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; c):将集合中元素按照指定规则排序。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectionsDemo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">//names.add(&quot;楚留香&quot;);</span><br>        <span class="hljs-comment">//names.add(&quot;胡铁花&quot;);</span><br>        <span class="hljs-comment">//names.add(&quot;张无忌&quot;);</span><br>        <span class="hljs-comment">//names.add(&quot;陆小凤&quot;);</span><br>        Collections.addAll(names, <span class="hljs-string">&quot;楚留香&quot;</span>,<span class="hljs-string">&quot;胡铁花&quot;</span>, <span class="hljs-string">&quot;张无忌&quot;</span>,<span class="hljs-string">&quot;陆小凤&quot;</span>);<br>        System.out.println(names);<br><br>        <span class="hljs-comment">// 2、public static void shuffle(List&lt;?&gt; list) :打乱集合顺序。</span><br>        Collections.shuffle(names);<br>        System.out.println(names);<br><br>        <span class="hljs-comment">// 3、 public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。 （排值特性的元素）</span><br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Collections.addAll(list, <span class="hljs-number">12</span>, <span class="hljs-number">23</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>);<br>        System.out.println(list);<br>        Collections.sort(list);<br>        System.out.println(list);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：引用数据类型的排序。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    字符串按照首字符的编号升序排序！</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    自定义类型的比较方法API:Collections</span><br><span class="hljs-comment">         - public static &lt;T&gt; void sort(List&lt;T&gt; list):</span><br><span class="hljs-comment">               将集合中元素按照默认规则排序。</span><br><span class="hljs-comment">               对于自定义的引用类型的排序人家根本不知道怎么排，直接报错！</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">         - public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; c):</span><br><span class="hljs-comment">                将集合中元素按照指定规则排序,自带比较器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectionsDemo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Apple&gt; apples = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// 可以重复！</span><br>        apples.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>(<span class="hljs-string">&quot;红富士&quot;</span>, <span class="hljs-string">&quot;红色&quot;</span>, <span class="hljs-number">9.9</span>, <span class="hljs-number">500</span>));<br>        apples.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>(<span class="hljs-string">&quot;青苹果&quot;</span>, <span class="hljs-string">&quot;绿色&quot;</span>, <span class="hljs-number">15.9</span>, <span class="hljs-number">300</span>));<br>        apples.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>(<span class="hljs-string">&quot;绿苹果&quot;</span>, <span class="hljs-string">&quot;青色&quot;</span>, <span class="hljs-number">29.9</span>, <span class="hljs-number">400</span>));<br>        apples.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>(<span class="hljs-string">&quot;黄苹果&quot;</span>, <span class="hljs-string">&quot;黄色&quot;</span>, <span class="hljs-number">9.8</span>, <span class="hljs-number">500</span>));<br><br><span class="hljs-comment">//        Collections.sort(apples); // 方法一：可以的，Apple类已经重写了比较规则</span><br><span class="hljs-comment">//        System.out.println(apples);</span><br><br>        <span class="hljs-comment">// 方式二：sort方法自带比较器对象</span><br><span class="hljs-comment">//        Collections.sort(apples, new Comparator&lt;Apple&gt;() &#123;</span><br><span class="hljs-comment">//            @Override</span><br><span class="hljs-comment">//            public int compare(Apple o1, Apple o2) &#123;</span><br><span class="hljs-comment">//                return Double.compare(o1.getPrice() , o2.getPrice()); // 按照价格排序！！</span><br><span class="hljs-comment">//            &#125;</span><br><span class="hljs-comment">//        &#125;);</span><br><br>        Collections.sort(apples, ( o1,  o2) -&gt;  Double.compare(o1.getPrice() , o2.getPrice()) );<br>        System.out.println(apples);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="斗地主发牌案例："><a href="#斗地主发牌案例：" class="headerlink" title="斗地主发牌案例："></a>斗地主发牌案例：</h6><p>能把Collection和Collections串起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Card</span> &#123;<br>    <span class="hljs-keyword">private</span> String size;<br>    <span class="hljs-keyword">private</span> String color;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> index; <span class="hljs-comment">// 牌的真正大小</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Card</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Card</span><span class="hljs-params">(String size, String color, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-built_in">this</span>.size = size;<br>        <span class="hljs-built_in">this</span>.color = color;<br>        <span class="hljs-built_in">this</span>.index = index;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSize</span><span class="hljs-params">(String size)</span> &#123;<br>        <span class="hljs-built_in">this</span>.size = size;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getColor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> color;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setColor</span><span class="hljs-params">(String color)</span> &#123;<br>        <span class="hljs-built_in">this</span>.color = color;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getIndex</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> index;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-built_in">this</span>.index = index;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size + color;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：斗地主游戏的案例开发。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    业务需求分析:</span><br><span class="hljs-comment">        斗地主的做牌, 洗牌, 发牌, 排序（拓展知识）, 看牌。</span><br><span class="hljs-comment">        业务: 总共有54张牌。</span><br><span class="hljs-comment">        点数: &quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;J&quot;,&quot;Q&quot;,&quot;K&quot;,&quot;A&quot;,&quot;2&quot;</span><br><span class="hljs-comment">        花色: &quot;♠&quot;, &quot;♥&quot;, &quot;♣&quot;, &quot;♦&quot;</span><br><span class="hljs-comment">        大小王: &quot;👲&quot; , &quot;🃏&quot;</span><br><span class="hljs-comment">        点数分别要组合4种花色，大小王各一张。</span><br><span class="hljs-comment">        斗地主：发出51张牌，剩下3张作为底牌。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    功能：</span><br><span class="hljs-comment">        1.做牌。</span><br><span class="hljs-comment">        2.洗牌。</span><br><span class="hljs-comment">        3.定义3个玩家</span><br><span class="hljs-comment">        4.发牌。</span><br><span class="hljs-comment">        5.排序（拓展，了解，作业）</span><br><span class="hljs-comment">        6.看牌</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GameDemo</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">      1、定义一个静态的集合存储54张牌对象</span><br><span class="hljs-comment">     */</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Card&gt; allCards = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">      2、做牌：定义静态代码块初始化牌数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">// 3、定义点数：个数确定，类型确定，使用数组</span><br>        String[] sizes = &#123;<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;10&quot;</span>,<span class="hljs-string">&quot;J&quot;</span>,<span class="hljs-string">&quot;Q&quot;</span>,<span class="hljs-string">&quot;K&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>&#125;;<br>        <span class="hljs-comment">// 4、定义花色：个数确定，类型确定，使用数组</span><br>        String[] colors = &#123;<span class="hljs-string">&quot;♠&quot;</span>, <span class="hljs-string">&quot;♥&quot;</span>, <span class="hljs-string">&quot;♣&quot;</span>, <span class="hljs-string">&quot;♦&quot;</span>&#125;;<br>        <span class="hljs-comment">// 5、组合点数和花色</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录牌的大小</span><br>        <span class="hljs-keyword">for</span> (String size : sizes) &#123;<br>            index++;<br>            <span class="hljs-keyword">for</span> (String color : colors) &#123;<br>                <span class="hljs-comment">// 6、封装成一个牌对象。</span><br>                <span class="hljs-type">Card</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Card</span>(size, color, index);<br>                <span class="hljs-comment">// 7、存入到集合容器中去</span><br>                allCards.add(c);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 8 大小王存入到集合对象中去 &quot;👲&quot; , &quot;🃏&quot;</span><br>        <span class="hljs-type">Card</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Card</span>(<span class="hljs-string">&quot;&quot;</span> ,  <span class="hljs-string">&quot;🃏&quot;</span>, ++index);<br>        <span class="hljs-type">Card</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Card</span>(<span class="hljs-string">&quot;&quot;</span> ,  <span class="hljs-string">&quot;👲&quot;</span>,++index);<br>        Collections.addAll(allCards , c1 , c2);<br>        System.out.println(<span class="hljs-string">&quot;新牌：&quot;</span> + allCards);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 9、洗牌</span><br>        Collections.shuffle(allCards);<br>        System.out.println(<span class="hljs-string">&quot;洗牌后：&quot;</span> + allCards);<br><br>        <span class="hljs-comment">// 10、发牌（定义三个玩家，每个玩家的牌也是一个集合容器）</span><br>        List&lt;Card&gt; linhuchong = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Card&gt; jiumozhi = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Card&gt; renyingying = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-comment">// 11、开始发牌（从牌集合中发出51张牌给三个玩家，剩余3张作为底牌）</span><br>        <span class="hljs-comment">// allCards = [🃏, A♠, 5♥, 2♠, 2♣, Q♣, 👲, Q♠ ...</span><br>        <span class="hljs-comment">//    i        0  1   2   3   4   5    6  7      %  3</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; allCards.size() - <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-comment">// 先拿到当前牌对象</span><br>            <span class="hljs-type">Card</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> allCards.get(i);<br>            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 请阿冲接牌</span><br>                linhuchong.add(c);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i % <span class="hljs-number">3</span> == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-comment">// 请阿鸠</span><br>                jiumozhi.add(c);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i % <span class="hljs-number">3</span> == <span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-comment">// 请盈盈接牌</span><br>                renyingying.add(c);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 12、拿到最后三张底牌(把最后三张牌截取成一个子集合)</span><br>        List&lt;Card&gt; lastThreeCards = allCards.subList(allCards.size() - <span class="hljs-number">3</span> , allCards.size());<br><br>        <span class="hljs-comment">// 13、给玩家的牌排序（从大到小 可以自己先试试怎么实现）</span><br>        sortCards(linhuchong);<br>        sortCards(jiumozhi);<br>        sortCards(renyingying);<br><br>        <span class="hljs-comment">// 14、输出玩家的牌：</span><br>        System.out.println(<span class="hljs-string">&quot;啊冲：&quot;</span> + linhuchong);<br>        System.out.println(<span class="hljs-string">&quot;啊鸠：&quot;</span> + jiumozhi);<br>        System.out.println(<span class="hljs-string">&quot;盈盈：&quot;</span> + renyingying);<br>        System.out.println(<span class="hljs-string">&quot;三张底牌：&quot;</span> + lastThreeCards);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">       给牌排序</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cards</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortCards</span><span class="hljs-params">(List&lt;Card&gt; cards)</span> &#123;<br>        <span class="hljs-comment">// cards = [J♥, A♦, 3♥, 🃏, 5♦, Q♥, 2♥</span><br>        Collections.sort(cards, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Card&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Card o1, Card o2)</span> &#123;<br>                <span class="hljs-comment">// o1 = J♥</span><br>                <span class="hljs-comment">// o2 = A♦</span><br>                <span class="hljs-comment">// 知道牌的大小，才可以指定规则</span><br>                <span class="hljs-keyword">return</span> o2.getIndex() - o1.getIndex();<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h4><h6 id="Map集合概述和使用"><a href="#Map集合概述和使用" class="headerlink" title="Map集合概述和使用"></a>Map集合概述和使用</h6><ul><li>Map集合是一种双列集合，每个元素包含两个数据。</li><li>Map集合的每个元素的格式：key=value（键值对元素）。</li><li>Map集合也被称为“键值对集合”。</li></ul><h6 id="Map集合整体格式："><a href="#Map集合整体格式：" class="headerlink" title="Map集合整体格式："></a>Map集合整体格式：</h6><ul><li>Collection集合的格式：[元素1，元素2，元素3.]</li><li>Map集合的完整格式：{key1=value1,key2=value2,key3=value.3,…</li></ul><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220426154833924.png" alt="image-20220426154833924"></p><h6 id="Map集合体系特点"><a href="#Map集合体系特点" class="headerlink" title="Map集合体系特点"></a>Map集合体系特点</h6><ul><li>Map集合的特点都是由键决定的。</li><li>Map集合的键是无序，不重复的，无索引的，值不做要求（可以重复）。</li><li>Map集合后面重复的键对应的值会覆盖前面重复键的值。</li><li>Map集合的键值对都可以为nul.</li></ul><h6 id="Map集合实现类特点"><a href="#Map集合实现类特点" class="headerlink" title="Map集合实现类特点"></a>Map集合实现类特点</h6><ul><li><p>HashMap:元素按照键是无序，不重复，无索引，值不做要求。(与Map体系一致)</p></li><li><p>LinkedHashMap:元素按照键是有序，不重复，无索引，值不做要求。</p><p>原理：底层数据结构是依然哈希表，只是每个键值对元素又额外的多了一个双链表的机制记录存储的顺序。</p></li><li><p>TreeMap:元素按照建是排序，不重复，无索引的，值不做要求。</p></li></ul><h6 id="Map常用API"><a href="#Map常用API" class="headerlink" title="Map常用API"></a>Map常用API</h6><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>V  put(K key,V value)</td><td>添加元素</td></tr><tr><td>V  remove(Object key)</td><td>根据键删除键值对元素</td></tr><tr><td>void  clear()</td><td>移除所有的键值对元素</td></tr><tr><td>boolean containsKey(Object key)</td><td>判断集合是否包含指定的键</td></tr><tr><td>boolean containsValue(Object value)</td><td>判断集合是否包含指定的值</td></tr><tr><td>boolean isEmpty()</td><td>判断集合是否为空</td></tr><tr><td>int  size()</td><td>集合的长度，也就是集合中键值对的个数</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：Map集合的常用API(重点中的重点)</span><br><span class="hljs-comment">     - public V put(K key, V value):  把指定的键与指定的值添加到Map集合中。</span><br><span class="hljs-comment">     - public V remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</span><br><span class="hljs-comment">     - public V get(Object key) 根据指定的键，在Map集合中获取对应的值。</span><br><span class="hljs-comment">     - public Set&lt;K&gt; keySet(): 获取Map集合中所有的键，存储到Set集合中。</span><br><span class="hljs-comment">     - public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。</span><br><span class="hljs-comment">     - public boolean containKey(Object key):判断该集合中是否有此键。</span><br><span class="hljs-comment">     - public boolean containValue(Object value):判断该集合中是否有此值。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1.添加元素: 无序，不重复，无索引。</span><br>        Map&lt;String , Integer&gt; maps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        maps.put(<span class="hljs-string">&quot;iphoneX&quot;</span>,<span class="hljs-number">10</span>);<br>        maps.put(<span class="hljs-string">&quot;娃娃&quot;</span>,<span class="hljs-number">20</span>);<br>        maps.put(<span class="hljs-string">&quot;iphoneX&quot;</span>,<span class="hljs-number">100</span>);<span class="hljs-comment">//  Map集合后面重复的键对应的元素会覆盖前面重复的整个元素！</span><br>        maps.put(<span class="hljs-string">&quot;huawei&quot;</span>,<span class="hljs-number">100</span>);<br>        maps.put(<span class="hljs-string">&quot;生活用品&quot;</span>,<span class="hljs-number">10</span>);<br>        maps.put(<span class="hljs-string">&quot;手表&quot;</span>,<span class="hljs-number">10</span>);<br>        <span class="hljs-comment">// &#123;huawei=100, 手表=10, 生活用品=10, iphoneX=100, 娃娃=20&#125;</span><br>        System.out.println(maps);<br><br>        <span class="hljs-comment">// 2.清空集合</span><br><span class="hljs-comment">//        maps.clear();</span><br><span class="hljs-comment">//        System.out.println(maps);</span><br><br>        <span class="hljs-comment">// 3.判断集合是否为空，为空返回true ,反之！</span><br>        System.out.println(maps.isEmpty());<br><br>        <span class="hljs-comment">// 4.根据键获取对应值:public V get(Object key)</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> maps.get(<span class="hljs-string">&quot;huawei&quot;</span>);<br>        System.out.println(key);<br>        System.out.println(maps.get(<span class="hljs-string">&quot;生活用品&quot;</span>)); <span class="hljs-comment">// 10</span><br>        System.out.println(maps.get(<span class="hljs-string">&quot;生活用品2&quot;</span>)); <span class="hljs-comment">// null</span><br><br>        <span class="hljs-comment">// 5.根据键删除整个元素。(删除键会返回键的值)</span><br>        System.out.println(maps.remove(<span class="hljs-string">&quot;iphoneX&quot;</span>));<br>        System.out.println(maps);<br><br>        <span class="hljs-comment">// 6.判断是否包含某个键 ，包含返回true ,反之</span><br>        System.out.println(maps.containsKey(<span class="hljs-string">&quot;娃娃&quot;</span>));  <span class="hljs-comment">// true</span><br>        System.out.println(maps.containsKey(<span class="hljs-string">&quot;娃娃2&quot;</span>));  <span class="hljs-comment">// false</span><br>        System.out.println(maps.containsKey(<span class="hljs-string">&quot;iphoneX&quot;</span>)); <span class="hljs-comment">// false</span><br><br>        <span class="hljs-comment">// 7.判断是否包含某个值。</span><br>        System.out.println(maps.containsValue(<span class="hljs-number">100</span>));  <span class="hljs-comment">//</span><br>        System.out.println(maps.containsValue(<span class="hljs-number">10</span>));  <span class="hljs-comment">//</span><br>        System.out.println(maps.containsValue(<span class="hljs-number">22</span>)); <span class="hljs-comment">//</span><br><br>        <span class="hljs-comment">// &#123;huawei=100, 手表=10, 生活用品=10, 娃娃=20&#125;</span><br>        <span class="hljs-comment">// 8.获取全部键的集合：public Set&lt;K&gt; keySet()</span><br>        Set&lt;String&gt; keys = maps.keySet();<br>        System.out.println(keys);<br><br>        System.out.println(<span class="hljs-string">&quot;------------------------------&quot;</span>);<br>        <span class="hljs-comment">// 9.获取全部值的集合：Collection&lt;V&gt; values();</span><br>        Collection&lt;Integer&gt; values = maps.values();<br>        System.out.println(values);<br><br>        <span class="hljs-comment">// 10.集合的大小</span><br>        System.out.println(maps.size()); <span class="hljs-comment">// 4</span><br><br>        <span class="hljs-comment">// 11.合并其他Map集合。(拓展)</span><br>        Map&lt;String , Integer&gt; map1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map1.put(<span class="hljs-string">&quot;java1&quot;</span>, <span class="hljs-number">1</span>);<br>        map1.put(<span class="hljs-string">&quot;java2&quot;</span>, <span class="hljs-number">100</span>);<br>        Map&lt;String , Integer&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map2.put(<span class="hljs-string">&quot;java2&quot;</span>, <span class="hljs-number">1</span>);<br>        map2.put(<span class="hljs-string">&quot;java3&quot;</span>, <span class="hljs-number">100</span>);<br>        map1.putAll(map2); <span class="hljs-comment">// 把集合map2的元素拷贝一份到map1中去</span><br>        System.out.println(map1);<br>        System.out.println(map2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="Map三种遍历方式"><a href="#Map三种遍历方式" class="headerlink" title="Map三种遍历方式"></a>Map三种遍历方式</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：Map集合的遍历方式一：键找值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Map集合的遍历方式有：3种。</span><br><span class="hljs-comment">        （1）“键找值”的方式遍历：先获取Map集合全部的键，再根据遍历键找值。</span><br><span class="hljs-comment">        （2）“键值对”的方式遍历：难度较大。</span><br><span class="hljs-comment">        （3）JDK 1.8开始之后的新技术：Lambda表达式。（暂时了解）</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    a.“键找值”的方式遍历Map集合。</span><br><span class="hljs-comment">        1.先获取Map集合的全部键的Set集合。</span><br><span class="hljs-comment">        2.遍历键的Set集合，然后通过键找值。</span><br><span class="hljs-comment">    小结：</span><br><span class="hljs-comment">        代码简单，需要记住!</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapDemo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Map&lt;String , Integer&gt; maps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">// 1.添加元素: 无序，不重复，无索引。</span><br>        maps.put(<span class="hljs-string">&quot;娃娃&quot;</span>,<span class="hljs-number">30</span>);<br>        maps.put(<span class="hljs-string">&quot;iphoneX&quot;</span>,<span class="hljs-number">100</span>);<br>        maps.put(<span class="hljs-string">&quot;huawei&quot;</span>,<span class="hljs-number">1000</span>);<br>        maps.put(<span class="hljs-string">&quot;生活用品&quot;</span>,<span class="hljs-number">10</span>);<br>        maps.put(<span class="hljs-string">&quot;手表&quot;</span>,<span class="hljs-number">10</span>);<br>        System.out.println(maps);<br>        <span class="hljs-comment">// maps = &#123;huawei=1000, 手表=10, 生活用品=10, iphoneX=100, 娃娃=30&#125;</span><br><br>        <span class="hljs-comment">// 1、键找值：第一步：先拿到集合的全部键。</span><br>        Set&lt;String&gt; keys = maps.keySet();<br>        <span class="hljs-comment">// 2、第二步：遍历每个键，根据键提取值</span><br>        <span class="hljs-keyword">for</span> (String key : keys) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> maps.get(key);<br>            System.out.println(key + <span class="hljs-string">&quot;===&gt;&quot;</span> + value);<br>        &#125;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：Map集合的遍历方式。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Map集合的遍历方式有：3种。</span><br><span class="hljs-comment">        （1）“键找值”的方式遍历：先获取Map集合全部的键，再根据键找值。</span><br><span class="hljs-comment">        （2）“键值对”的方式遍历：难度较大。</span><br><span class="hljs-comment">        （3）JDK 1.8开始之后的新技术：Lambda表达式。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    b.“键值对”的方式遍历：</span><br><span class="hljs-comment">        1.把Map集合转换成一个Set集合:Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</span><br><span class="hljs-comment">        2.此时键值对元素的类型就确定了，类型是键值对实体类型：Map.Entry&lt;K, V&gt;</span><br><span class="hljs-comment">        3.接下来就可以用foreach遍历这个Set集合，类型用Map.Entry&lt;K, V&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapDemo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Map&lt;String , Integer&gt; maps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">// 1.添加元素: 无序，不重复，无索引。</span><br>        maps.put(<span class="hljs-string">&quot;娃娃&quot;</span>,<span class="hljs-number">30</span>);<br>        maps.put(<span class="hljs-string">&quot;iphoneX&quot;</span>,<span class="hljs-number">100</span>);<br>        maps.put(<span class="hljs-string">&quot;huawei&quot;</span>,<span class="hljs-number">1000</span>);<br>        maps.put(<span class="hljs-string">&quot;生活用品&quot;</span>,<span class="hljs-number">10</span>);<br>        maps.put(<span class="hljs-string">&quot;手表&quot;</span>,<span class="hljs-number">10</span>);<br>        System.out.println(maps);<br>        <span class="hljs-comment">// maps = &#123;huawei=1000, 手表=10, 生活用品=10, iphoneX=100, 娃娃=30&#125;</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">            maps = &#123;huawei=1000, 手表=10, 生活用品=10, iphoneX=100, 娃娃=30&#125;</span><br><span class="hljs-comment">                👇</span><br><span class="hljs-comment">            使用foreach遍历map集合.发现Map集合的键值对元素直接是没有类型的。所以不可以直接foreach遍历集合。</span><br><span class="hljs-comment">                👇</span><br><span class="hljs-comment">            可以通过调用Map的方法 entrySet把Map集合转换成Set集合形式  maps.entrySet();</span><br><span class="hljs-comment">                👇</span><br><span class="hljs-comment">            Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entries =  maps.entrySet();</span><br><span class="hljs-comment">             [(huawei=1000), (手表=10), (生活用品=10), (iphoneX=100), (娃娃=30)]</span><br><span class="hljs-comment">                              entry</span><br><span class="hljs-comment">                👇</span><br><span class="hljs-comment">            此时可以使用foreach遍历</span><br><span class="hljs-comment">       */</span><br>       <span class="hljs-comment">// 1、把Map集合转换成Set集合</span><br>        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = maps.entrySet();<br>        <span class="hljs-comment">// 2、开始遍历</span><br>        <span class="hljs-keyword">for</span>(Map.Entry&lt;String, Integer&gt; entry : entries)&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> entry.getKey();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> entry.getValue();<br>            System.out.println(key + <span class="hljs-string">&quot;====&gt;&quot;</span> + value);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：Map集合的遍历方式。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Map集合的遍历方式有：3种。</span><br><span class="hljs-comment">        （1）“键找值”的方式遍历：先获取Map集合全部的键，再根据键找值。</span><br><span class="hljs-comment">        （2）“键值对”的方式遍历：难度较大。</span><br><span class="hljs-comment">        （3）JDK 1.8开始之后的新技术：Lambda表达式。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    c.JDK 1.8开始之后的新技术：Lambda表达式。（暂时了解）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapDemo03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Map&lt;String , Integer&gt; maps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">// 1.添加元素: 无序，不重复，无索引。</span><br>        maps.put(<span class="hljs-string">&quot;娃娃&quot;</span>,<span class="hljs-number">30</span>);<br>        maps.put(<span class="hljs-string">&quot;iphoneX&quot;</span>,<span class="hljs-number">100</span>);<span class="hljs-comment">//  Map集合后面重复的键对应的元素会覆盖前面重复的整个元素！</span><br>        maps.put(<span class="hljs-string">&quot;huawei&quot;</span>,<span class="hljs-number">1000</span>);<br>        maps.put(<span class="hljs-string">&quot;生活用品&quot;</span>,<span class="hljs-number">10</span>);<br>        maps.put(<span class="hljs-string">&quot;手表&quot;</span>,<span class="hljs-number">10</span>);<br>        System.out.println(maps);<br><br>        <span class="hljs-comment">//  maps = &#123;huawei=1000, 手表=10, 生活用品=10, iphoneX=100, 娃娃=30&#125;</span><br><br><span class="hljs-comment">//        maps.forEach(new BiConsumer&lt;String, Integer&gt;() &#123;</span><br><span class="hljs-comment">//            @Override</span><br><span class="hljs-comment">//            public void accept(String key, Integer value) &#123;</span><br><span class="hljs-comment">//                System.out.println(key + &quot;---&gt;&quot; + value);</span><br><span class="hljs-comment">//            &#125;</span><br><span class="hljs-comment">//        &#125;);</span><br><br>        maps.forEach((k, v) -&gt; &#123;<br>                System.out.println(k + <span class="hljs-string">&quot;---&gt;&quot;</span> + v);<br>        &#125;);<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>需求</strong><br>某个班级80名学生，现在需要组成秋游活动，班长提供了四个景点依次是(A、B、C、D),每个学生只能选择一个景点，请统计出最终哪个景点想去的人数最多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapTest1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>         <span class="hljs-comment">// 1、把80个学生选择的数据拿进来。</span><br>        String[] selects = &#123;<span class="hljs-string">&quot;A&quot;</span> , <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>&#125;;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">80</span>; i++) &#123;<br>            sb.append(selects[r.nextInt(selects.length)]);<br>        &#125;<br>        System.out.println(sb);<br><br>        <span class="hljs-comment">// 2、定义一个Map集合记录最终统计的结果： A=30 B=20 C=20 D=10  键是景点 值是选择的数量</span><br>        Map&lt;Character, Integer&gt; infos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(); <span class="hljs-comment">//</span><br><br>        <span class="hljs-comment">// 3、遍历80个学生选择的数据</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; sb.length(); i++) &#123;<br>            <span class="hljs-comment">// 4、提取当前选择景点字符</span><br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> sb.charAt(i);<br>            <span class="hljs-comment">// 5、判断Map集合中是否存在这个键</span><br>            <span class="hljs-keyword">if</span>(infos.containsKey(ch))&#123;<br>                 <span class="hljs-comment">// 让其值 + 1</span><br>                infos.put(ch , infos.get(ch) + <span class="hljs-number">1</span>);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 说明此景点是第一次被选</span><br>                infos.put(ch , <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 4、输出集合</span><br>        System.out.println(infos);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="集合嵌套"><a href="#集合嵌套" class="headerlink" title="集合嵌套"></a>集合嵌套</h6><p>某个班级多名学生，现在需要组成秋游活动，班长提供了四个景点依次是(A、B、C、D),每个学生可以选择多个景点，请统计出最终哪个景点想去的人数最多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapTest4</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1、要求程序记录每个学生选择的情况。</span><br>        <span class="hljs-comment">// 使用一个Map集合存储。</span><br>        Map&lt;String, List&lt;String&gt;&gt; data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>        <span class="hljs-comment">// 2、把学生选择的数据存入进去。</span><br>        List&lt;String&gt; selects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Collections.addAll(selects, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>);<br>        data.put(<span class="hljs-string">&quot;罗勇&quot;</span>, selects);<br><br>        List&lt;String&gt; selects1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Collections.addAll(selects1, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span> , <span class="hljs-string">&quot;D&quot;</span>);<br>        data.put(<span class="hljs-string">&quot;胡涛&quot;</span>, selects1);<br><br>        List&lt;String&gt; selects2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Collections.addAll(selects2 , <span class="hljs-string">&quot;A&quot;</span>,  <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span> , <span class="hljs-string">&quot;D&quot;</span>);<br>        data.put(<span class="hljs-string">&quot;刘军&quot;</span>, selects2);<br><br>        System.out.println(data);<br><br>        <span class="hljs-comment">// 3、统计每个景点选择的人数。</span><br>        Map&lt;String, Integer&gt; infos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(); <span class="hljs-comment">// &#123;&#125;</span><br><br>        <span class="hljs-comment">// 4、提取所有人选择的景点的信息。</span><br>        Collection&lt;List&lt;String&gt;&gt; values = data.values();<br>        System.out.println(values);<br>        <span class="hljs-comment">// values = [[A, B, C, D], [B, C, D], [A, C]]</span><br>        <span class="hljs-comment">//             value</span><br><br>        <span class="hljs-keyword">for</span> (List&lt;String&gt; value : values) &#123;<br>            <span class="hljs-keyword">for</span> (String s : value) &#123;<br>                <span class="hljs-comment">// 有没有包含这个景点</span><br>                <span class="hljs-keyword">if</span>(infos.containsKey(s))&#123;<br>                    infos.put(s, infos.get(s) + <span class="hljs-number">1</span>);<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    infos.put(s , <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        System.out.println(infos);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Stream、异常体系、日志框架"><a href="#Stream、异常体系、日志框架" class="headerlink" title="Stream、异常体系、日志框架"></a>Stream、异常体系、日志框架</h4><h6 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h6><p>定义</p><p>不可变集合，就是不可被修改的集合。<br>集合的数据项在创建的时候提供，并且在整个生命周期中都不可改变。否则报错。</p><p>如果某个数据不能被修改，把它防御性地拷贝到不可变集合中是个很好的实践。<br>或者当集合对象被不可信的库调用时，不可变形式是安全的。</p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>static  <E> List<E> of(E…elements)</td><td>创建一个具有指定元素的List集合对象</td></tr><tr><td>static  <E> Set<E> of(E…elements)</td><td>创建一个具有指定元素的Set集合对象</td></tr><tr><td>static &lt;K  , V&gt;  Map&lt;K，V&gt; of(E…elements)</td><td>创建一个具有指定元素的Map集合对象</td></tr></tbody></table><h6 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h6><p>在Java8中，得益于Lambda所带来的函数式编程，引入了一个全新Stream流概念。<br>目的：用于简化集合和数组操作的API。</p><p>初体验-&gt;对比</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Collections.addAll(names, <span class="hljs-string">&quot;张三丰&quot;</span>,<span class="hljs-string">&quot;张无忌&quot;</span>,<span class="hljs-string">&quot;周芷若&quot;</span>,<span class="hljs-string">&quot;赵敏&quot;</span>,<span class="hljs-string">&quot;张强&quot;</span>);<br>        System.out.println(names);<br><span class="hljs-comment">//</span><br><span class="hljs-comment">//        // 1、从集合中找出姓张的放到新集合</span><br><span class="hljs-comment">//        List&lt;String&gt; zhangList = new ArrayList&lt;&gt;();</span><br><span class="hljs-comment">//        for (String name : names) &#123;</span><br><span class="hljs-comment">//            if(name.startsWith(&quot;张&quot;))&#123;</span><br><span class="hljs-comment">//                zhangList.add(name);</span><br><span class="hljs-comment">//            &#125;</span><br><span class="hljs-comment">//        &#125;</span><br><span class="hljs-comment">//        System.out.println(zhangList);</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//        // 2、找名称长度是3的姓名</span><br><span class="hljs-comment">//        List&lt;String&gt; zhangThreeList = new ArrayList&lt;&gt;();</span><br><span class="hljs-comment">//        for (String name : zhangList) &#123;</span><br><span class="hljs-comment">//            if(name.length() == 3)&#123;</span><br><span class="hljs-comment">//                zhangThreeList.add(name);</span><br><span class="hljs-comment">//            &#125;</span><br><span class="hljs-comment">//        &#125;</span><br><span class="hljs-comment">//        System.out.println(zhangThreeList);</span><br><br>        <span class="hljs-comment">// 3、使用Stream实现的</span><br>        names.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>)).filter(s -&gt; s.length() == <span class="hljs-number">3</span>).forEach(s -&gt; System.out.println(s));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>1、Stream流的作用是什么，结合了什么技术？<br>    简化集合、数组操作的API。结合了Lambda表达式。<br>2、说说Stream流的思想和使用步骤。<br>    先得到集合或者数组的Stream流（就是一根传送带）。<br>    把元素放上去。<br>    然后就用这个Stream流简化的API来方便的操作元素。</p><h6 id="Stream流的三类方法"><a href="#Stream流的三类方法" class="headerlink" title="Stream流的三类方法"></a>Stream流的三类方法</h6><ul><li><p>获取Stream流</p><p>创建一条流水线，并把数据放到流水线上准备进行操作</p></li><li><p>中间方法</p><p>流水线上的操作。一次操作完毕之后，还可以继续进行其他操作。</p></li><li><p>终结方法</p><p>一个Stream流只能有一个终结方法，是流水线上的最后一个操作</p></li></ul><h6 id="集合获取Stream流的方式"><a href="#集合获取Stream流的方式" class="headerlink" title="集合获取Stream流的方式"></a>集合获取Stream流的方式</h6><p>可以使用Collection接口中的默认方法stream()生成流</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>default  Stream<E> stream()</td><td>获取当前集合对象的Stream流</td></tr></tbody></table><h6 id="数组获取Stream流的方式"><a href="#数组获取Stream流的方式" class="headerlink" title="数组获取Stream流的方式"></a>数组获取Stream流的方式</h6><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>public  static <T>  Stream<T>  stream(T[]  array)</td><td>获取当前数组的Stream流</td></tr><tr><td>public  static<T>  Stream<T>  of(T…  values)</td><td>获取当前数组/可变数据的Stream流</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     目标：Stream流的获取</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     Stream流式思想的核心：</span><br><span class="hljs-comment">                 是先得到集合或者数组的Stream流（就是一根传送带）</span><br><span class="hljs-comment">                 然后就用这个Stream流操作集合或者数组的元素。</span><br><span class="hljs-comment">                 然后用Stream流简化替代集合操作的API.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     集合获取流的API:</span><br><span class="hljs-comment">         (1) default Stream&lt;E&gt; stream();</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     小结：</span><br><span class="hljs-comment">         集合获取Stream流用: stream();</span><br><span class="hljs-comment">         数组：Arrays.stream(数组)   /  Stream.of(数组);</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamDemo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/** --------------------Collection集合获取流-------------------------------   */</span><br>        Collection&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Stream&lt;String&gt; s =  list.stream();<br><br>        <span class="hljs-comment">/** --------------------Map集合获取流-------------------------------   */</span><br>        Map&lt;String, Integer&gt; maps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">// 键流</span><br>        Stream&lt;String&gt; keyStream = maps.keySet().stream();<br>        <span class="hljs-comment">// 值流</span><br>        Stream&lt;Integer&gt; valueStream = maps.values().stream();<br>        <span class="hljs-comment">// 键值对流（拿整体）</span><br>        Stream&lt;Map.Entry&lt;String,Integer&gt;&gt; keyAndValueStream =  maps.entrySet().stream();<br><br>        <span class="hljs-comment">/** ---------------------数组获取流------------------------------   */</span><br>        String[] names = &#123;<span class="hljs-string">&quot;赵敏&quot;</span>,<span class="hljs-string">&quot;小昭&quot;</span>,<span class="hljs-string">&quot;灭绝&quot;</span>,<span class="hljs-string">&quot;周芷若&quot;</span>&#125;;<br>        Stream&lt;String&gt; nameStream = Arrays.stream(names);<br>        Stream&lt;String&gt; nameStream2 = Stream.of(names);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="311Stream常用API"><a href="#311Stream常用API" class="headerlink" title="311Stream常用API"></a>311Stream常用API</h1><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>Stream<T>  filter(Predicate&lt;?  super  T&gt;  predicate)</td><td>用于对流中的数据进行<strong>过滤。</strong></td></tr><tr><td>Stream<T>  limit(long maxSize)</td><td>获取前几个元素</td></tr><tr><td>Stream<T>  skip(long n)</td><td>跳过前几个元素</td></tr><tr><td>Stream<T>  distinct()</td><td>去除流中重复的元素。依赖(hashCode和equals方法)</td></tr><tr><td>static  <T> Stream<T> concat(Stream  a, Stream b)</td><td><strong>合并</strong>a和b两个流为一个流</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     目标：Stream流的常用API</span><br><span class="hljs-comment">         forEach : 逐一处理(遍历)</span><br><span class="hljs-comment">         count：统计个数</span><br><span class="hljs-comment">            -- long count();</span><br><span class="hljs-comment">         filter : 过滤元素</span><br><span class="hljs-comment">            -- Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</span><br><span class="hljs-comment">         limit : 取前几个元素</span><br><span class="hljs-comment">         skip : 跳过前几个</span><br><span class="hljs-comment">         map : 加工方法</span><br><span class="hljs-comment">         concat : 合并流。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamDemo03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;张无忌&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;周芷若&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;赵敏&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;张强&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;张三丰&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;张三丰&quot;</span>);<br><br>        <span class="hljs-comment">// Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</span><br>        list.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>)).forEach(s -&gt; System.out.println(s));<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> list.stream().filter(s -&gt; s.length() == <span class="hljs-number">3</span>).count();<br>        System.out.println(size);<br><br>       <span class="hljs-comment">// list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;)).limit(2).forEach(s -&gt; System.out.println(s));</span><br>        list.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>)).limit(<span class="hljs-number">2</span>).forEach(System.out::println);<br><br>        list.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>)).skip(<span class="hljs-number">2</span>).forEach(System.out::println);<br><br>        <span class="hljs-comment">// map加工方法: 第一个参数原材料  -&gt; 第二个参数是加工后的结果。</span><br>        <span class="hljs-comment">// 给集合元素的前面都加上一个：黑马的：</span><br>        list.stream().map(s -&gt; <span class="hljs-string">&quot;黑马的：&quot;</span> + s).forEach(a -&gt; System.out.println(a));<br><br>        <span class="hljs-comment">// 需求：把所有的名称 都加工成一个学生对象。</span><br>         list.stream().map(s -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(s)).forEach(s -&gt; System.out.println(s));<br><span class="hljs-comment">//        list.stream().map(Student::new).forEach(System.out::println); // 构造器引用  方法引用</span><br><br>        <span class="hljs-comment">// 合并流。</span><br>        Stream&lt;String&gt; s1 = list.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>));<br>        Stream&lt;String&gt; s2 = Stream.of(<span class="hljs-string">&quot;java1&quot;</span>, <span class="hljs-string">&quot;java2&quot;</span>);<br>        <span class="hljs-comment">// public static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span><br>        Stream&lt;String&gt; s3 = Stream.concat(s1 , s2);<br>        s3.distinct().forEach(s -&gt; System.out.println(s));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamDemo04</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> allMoney ;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> allMoney2 ; <span class="hljs-comment">// 2个部门去掉最高工资，最低工资的总和</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Employee&gt; one = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        one.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;猪八戒&quot;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-number">30000</span> , <span class="hljs-number">25000</span>, <span class="hljs-literal">null</span>));<br>        one.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;孙悟空&quot;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-number">25000</span> , <span class="hljs-number">1000</span>, <span class="hljs-string">&quot;顶撞上司&quot;</span>));<br>        one.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;沙僧&quot;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-number">20000</span> , <span class="hljs-number">20000</span>, <span class="hljs-literal">null</span>));<br>        one.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;小白龙&quot;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-number">20000</span> , <span class="hljs-number">25000</span>, <span class="hljs-literal">null</span>));<br><br>        List&lt;Employee&gt; two = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        two.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;武松&quot;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-number">15000</span> , <span class="hljs-number">9000</span>, <span class="hljs-literal">null</span>));<br>        two.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;李逵&quot;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-number">20000</span> , <span class="hljs-number">10000</span>, <span class="hljs-literal">null</span>));<br>        two.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;西门庆&quot;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-number">50000</span> , <span class="hljs-number">100000</span>, <span class="hljs-string">&quot;被打&quot;</span>));<br>        two.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;潘金莲&quot;</span>,<span class="hljs-string">&#x27;女&#x27;</span>,<span class="hljs-number">3500</span> , <span class="hljs-number">1000</span>, <span class="hljs-string">&quot;被打&quot;</span>));<br>        two.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;武大郎&quot;</span>,<span class="hljs-string">&#x27;女&#x27;</span>,<span class="hljs-number">20000</span> , <span class="hljs-number">0</span>, <span class="hljs-string">&quot;下毒&quot;</span>));<br><br>        <span class="hljs-comment">// 1、开发一部的最高工资的员工。（API）</span><br>        <span class="hljs-comment">// 指定大小规则了</span><br><span class="hljs-comment">//        Employee e = one.stream().max((e1, e2) -&gt; Double.compare(e1.getSalary() + e1.getBonus(),  e2.getSalary() + e2.getBonus()))</span><br><span class="hljs-comment">//                .get();</span><br><span class="hljs-comment">//       System.out.println(e);</span><br>        <span class="hljs-type">Topperformer</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> one.stream().max((e1, e2) -&gt; Double.compare(e1.getSalary() + e1.getBonus(),  e2.getSalary() + e2.getBonus()))<br>                .map(e -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Topperformer</span>(e.getName(),  e.getSalary() + e.getBonus())).get();<br>        System.out.println(t);<br><br>        <span class="hljs-comment">// 2、统计平均工资，去掉最高工资和最低工资</span><br>        one.stream().sorted((e1, e2) -&gt; Double.compare(e1.getSalary() + e1.getBonus(),  e2.getSalary() + e2.getBonus()))<br>                .skip(<span class="hljs-number">1</span>).limit(one.size() - <span class="hljs-number">2</span>).forEach(e -&gt; &#123;<br>                    <span class="hljs-comment">// 求出总和：剩余员工的工资总和</span><br>            allMoney += (e.getSalary() + e.getBonus());<br>        &#125;);<br>        System.out.println(<span class="hljs-string">&quot;开发一部的平均工资是：&quot;</span> + allMoney / (one.size() - <span class="hljs-number">2</span>));<br><br>        <span class="hljs-comment">// 3、合并2个集合流，再统计</span><br>        Stream&lt;Employee&gt; s1 = one.stream();<br>        Stream&lt;Employee&gt; s2 = two.stream();<br>        Stream&lt;Employee&gt; s3 = Stream.concat(s1 , s2);<br>        s3.sorted((e1, e2) -&gt; Double.compare(e1.getSalary() + e1.getBonus(),  e2.getSalary() + e2.getBonus()))<br>                .skip(<span class="hljs-number">1</span>).limit(one.size() + two.size() - <span class="hljs-number">2</span>).forEach(e -&gt; &#123;<br>            <span class="hljs-comment">// 求出总和：剩余员工的工资总和</span><br>            allMoney2 += (e.getSalary() + e.getBonus());<br>        &#125;);<br><br>        <span class="hljs-comment">// BigDecimal</span><br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> BigDecimal.valueOf(allMoney2);<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> BigDecimal.valueOf(one.size()  + two.size() - <span class="hljs-number">2</span>);<br>        System.out.println(<span class="hljs-string">&quot;开发部的平均工资是：&quot;</span> + a.divide(b,<span class="hljs-number">2</span>, RoundingMode.HALF_UP));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="收集Stream流"><a href="#收集Stream流" class="headerlink" title="收集Stream流"></a>收集Stream流</h6><p><strong>收集Stream流的含义</strong>：就是把Stream流操作后的结果数据转回到集合或者数组中去。</p><p>Stream流：方便操作集合/数组的<strong>手段。</strong></p><p>集合/数组：才是开发中的<strong>目的</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamDemo05</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;张无忌&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;周芷若&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;赵敏&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;张强&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;张三丰&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;张三丰&quot;</span>);<br><br>        Stream&lt;String&gt; s1 = list.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>));<br>        List&lt;String&gt; zhangList = s1.collect(Collectors.toList()); <span class="hljs-comment">// 可变集合</span><br>        zhangList.add(<span class="hljs-string">&quot;java1&quot;</span>);<br>        System.out.println(zhangList);<br><br><span class="hljs-comment">//       List&lt;String&gt; list1 = s1.toList(); // 得到不可变集合</span><br><span class="hljs-comment">//       list1.add(&quot;java&quot;);</span><br><span class="hljs-comment">//       System.out.println(list1);</span><br><br>        <span class="hljs-comment">// 注意注意注意：“流只能使用一次”</span><br>        Stream&lt;String&gt; s2 = list.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>));<br>        Set&lt;String&gt; zhangSet = s2.collect(Collectors.toSet());<br>        System.out.println(zhangSet);<br><br>        Stream&lt;String&gt; s3 = list.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>));<br><span class="hljs-comment">//         Object[] arrs = s3.toArray();</span><br>        String[] arrs = s3.toArray(String[]::<span class="hljs-keyword">new</span>); <span class="hljs-comment">// 可以不管，拓展一下思维！！</span><br>        System.out.println(<span class="hljs-string">&quot;Arrays数组内容：&quot;</span> + Arrays.toString(arrs));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><h6 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h6><ul><li>异常是程序在“编译”或者“执行”的过程中可能出现的问题，注意：语法错误不算在异常体系中。</li><li>比如：数组索引越界、空指针异常、</li><li>日期格式化异常，等…</li></ul><h6 id="为什么要学习异常？"><a href="#为什么要学习异常？" class="headerlink" title="为什么要学习异常？"></a>为什么要学习异常？</h6><ul><li>异常一旦出现了，如果没有提前处理，程序就会退出JM虚拟机而终止</li><li>研究异常并且避免异常，然后提前处理异常，体现的是程序的安全，健壮性。</li></ul><h6 id="异常分为几类？"><a href="#异常分为几类？" class="headerlink" title="异常分为几类？"></a>异常分为几类？</h6><ul><li>编译时异常、运行时异常。</li><li>编译时异常：没有继承RuntimeExcpetion的异常，编译阶段就会错。</li><li>运行时异常：继承自RuntimeException的异常或其子类，编译阶段不报错，运行可能报错。</li></ul><h6 id="运行时异常示例"><a href="#运行时异常示例" class="headerlink" title="运行时异常示例"></a>运行时异常示例</h6><ul><li>数组索引越界异常：ArraylndexOutOfBoundsException</li><li>空指针异常：NullPointerException,直接输出没有问题，但是调用空指针的变量的功能就会报错。</li><li>数学操作异常：ArithmeticException</li><li>类型转换异常：ClassCastException</li><li>数字转换异常：NumberFormatException</li></ul><h6 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a><strong>编译时异常</strong></h6><ul><li>不是RuntimeException或者其子类的异常，编译阶就报错，必须处理，否则代码不通过。</li><li>是担心程序员的技术不行，在编译阶段就爆出一个错误，目的在于提醒不要出错！</li><li>编译时异常是可遇不可求，遇到了就遇到了呗。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2015-01-12 10:23:21&quot;</span>;<br><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br><span class="hljs-type">Date</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> sdf.parse(date);<span class="hljs-comment">//</span><br>System.out.println(d);<br></code></pre></td></tr></table></figure><h6 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h6><p><strong>异常处理方式1—— throws</strong></p><ul><li><p>throws：用在方法上，可以将方法内部出现的异常抛出去给本方法的调用者处理。</p></li><li><p>这种方式并不好，发生异常的方法自己不处理异常，如果异常最终抛出去给虚拟机将引起程序死亡。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">方法 <span class="hljs-keyword">throws</span> Exception&#123;<br>&#125;<br><span class="hljs-comment">//代表抛一切异常</span><br></code></pre></td></tr></table></figure><p><strong>异常处理方式2—— try…catch…</strong></p><ul><li><p>监视捕获异常，用在方法内部，可以将方法内部出现的异常直接捕获处理。</p></li><li><p>这种方式还可以，发生异常的方法自己独立完成异常的处理，程序可以继续往下执行。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">// 可能出现异常的代码！</span><br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>    e.printStackTrace(); <br>    <span class="hljs-comment">// 直接打印异常栈信息</span><br>&#125;<br><span class="hljs-comment">//Exception可以捕获处理一切异常类型！</span><br></code></pre></td></tr></table></figure><p><strong>异常处理方式——前两者结合</strong></p><ul><li><p>方法直接将异通过throws抛出去给调用者</p></li><li><p>调用者收到异常后直接捕获处理。</p></li></ul><h6 id="自定义异常的必要？"><a href="#自定义异常的必要？" class="headerlink" title="自定义异常的必要？"></a><strong>自定义异常的必要</strong>？</h6><ul><li><p>Java无法为这个世界上全部的问题提供异常类。</p></li><li><p>如果企业想通过异常的方式来管理自己的某个业务问题，就需要自定义异常类了。</p></li></ul><h6 id="自定义异常的好处："><a href="#自定义异常的好处：" class="headerlink" title="自定义异常的好处："></a><strong>自定义异常的好处：</strong></h6><ul><li><p>可以使用异常的机制管理业务问题，如提醒程序员注意。</p></li><li><p>同时一旦出现bug，可以用异常的形式清晰的指出出错的地方。</p></li></ul><h6 id="自定义异常分类"><a href="#自定义异常分类" class="headerlink" title="自定义异常分类"></a>自定义异常分类</h6><p><strong>1、自定义编译时异常</strong></p><ul><li><p>定义一个异常类继承Exception.</p></li><li><p>重写构造器。</p></li><li><p>在出现异常的地方用throw new 自定义对象抛出，</p></li></ul><p>作用：编译时异常是编译阶段就报错，提醒更加强烈，一定需要处理！！</p><p><strong>2、自定义运行时异常</strong></p><ul><li><p>定义一个异常类继承RuntimeException.</p></li><li><p>重写构造器。</p></li><li><p>在出现异常的地方用throw new 自定义对象抛出!</p></li></ul><p>作用：提醒不强烈，编译阶段不报错！！运行时才可能出现！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    自定义的编译时异常</span><br><span class="hljs-comment">      1、继承Exception</span><br><span class="hljs-comment">      2、重写构造器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ItheimaAgeIlleagalException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ItheimaAgeIlleagalException</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ItheimaAgeIlleagalException</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    自定义的运行时异常</span><br><span class="hljs-comment">      1、继承RuntimeException</span><br><span class="hljs-comment">      2、重写构造器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ItheimaAgeIlleagalRuntimeException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ItheimaAgeIlleagalRuntimeException</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ItheimaAgeIlleagalRuntimeException</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标:自定义异常(了解)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    引入:Java已经为开发中可能出现的异常都设计了一个类来代表.</span><br><span class="hljs-comment">        但是实际开发中,异常可能有无数种情况,Java无法为</span><br><span class="hljs-comment">        这个世界上所有的异常都定义一个代表类。</span><br><span class="hljs-comment">        假如一个企业如果想为自己认为的某种业务问题定义成一个异常</span><br><span class="hljs-comment">        就需要自己来自定义异常类.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    需求：认为年龄小于0岁，大于200岁就是一个异常。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    自定义异常:</span><br><span class="hljs-comment">        自定义编译时异常.</span><br><span class="hljs-comment">            a.定义一个异常类继承Exception.</span><br><span class="hljs-comment">            b.重写构造器。</span><br><span class="hljs-comment">            c.在出现异常的地方用throw new 自定义对象抛出!</span><br><span class="hljs-comment">            编译时异常是编译阶段就报错，提醒更加强烈，一定需要处理！！</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        自定义运行时异常.</span><br><span class="hljs-comment">            a.定义一个异常类继承RuntimeException.</span><br><span class="hljs-comment">            b.重写构造器。</span><br><span class="hljs-comment">            c.在出现异常的地方用throw new 自定义对象抛出!</span><br><span class="hljs-comment">            提醒不强烈，编译阶段不报错！！运行时才可能出现！！</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//        try &#123;</span><br><span class="hljs-comment">//            checkAge(-34);</span><br><span class="hljs-comment">//        &#125; catch (ItheimaAgeIlleagalException e) &#123;</span><br><span class="hljs-comment">//            e.printStackTrace();</span><br><span class="hljs-comment">//        &#125;</span><br><br>        <span class="hljs-keyword">try</span> &#123;<br>            checkAge2(-<span class="hljs-number">23</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkAge2</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span>  &#123;<br>        <span class="hljs-keyword">if</span>(age &lt; <span class="hljs-number">0</span> || age &gt; <span class="hljs-number">200</span>)&#123;<br>            <span class="hljs-comment">// 抛出去一个异常对象给调用者</span><br>            <span class="hljs-comment">// throw ：在方法内部直接创建一个异常对象，并从此点抛出</span><br>            <span class="hljs-comment">// throws : 用在方法申明上的，抛出方法内部的异常</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ItheimaAgeIlleagalRuntimeException</span>(age + <span class="hljs-string">&quot; is illeagal!&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;年龄合法：推荐商品给其购买~~&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> <span class="hljs-keyword">throws</span> ItheimaAgeIlleagalException &#123;<br>        <span class="hljs-keyword">if</span>(age &lt; <span class="hljs-number">0</span> || age &gt; <span class="hljs-number">200</span>)&#123;<br>            <span class="hljs-comment">// 抛出去一个异常对象给调用者</span><br>            <span class="hljs-comment">// throw ：在方法内部直接创建一个异常对象，并从此点抛出</span><br>            <span class="hljs-comment">// throws : 用在方法申明上的，抛出方法内部的异常</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ItheimaAgeIlleagalException</span>(age + <span class="hljs-string">&quot; is illeagal!&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;年龄合法：推荐商品给其购买~~&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="日志技术"><a href="#日志技术" class="headerlink" title="日志技术"></a>日志技术</h4><h6 id="日志技术具备的优势"><a href="#日志技术具备的优势" class="headerlink" title="日志技术具备的优势"></a>日志技术具备的优势</h6><ul><li>可以将系统执行的信息选择性的记录到指定的位置(控制台、文件中、数据库中)。</li><li>可以随时以开关的形式控制是否记录日志，无需修改源代码。</li></ul><table><thead><tr><th></th><th><strong>输出语句</strong></th><th><strong>日志技术</strong></th></tr></thead><tbody><tr><td>输出位置</td><td>只能是控制台</td><td>可以将日志信息写入到文件或者数据库中</td></tr><tr><td>取消日志</td><td>需要修改代码，灵活性比较差</td><td>不需要修改代码，灵活性比较好</td></tr><tr><td>多线程</td><td>性能较差</td><td>性能较好</td></tr></tbody></table><h6 id="1-日志的规范是什么，常见的有几种形式。"><a href="#1-日志的规范是什么，常见的有几种形式。" class="headerlink" title="1.日志的规范是什么，常见的有几种形式。"></a><strong>1.日志的规范是什么，常见的有几种形式。</strong></h6><ul><li>日志规范大多是一些接口，提供给实现框架去设计的。</li><li>常见的规范是：</li><li>Commons Logging</li><li>Simple Logging Facade for Java</li></ul><h6 id="2-日志的实现框架有哪些常见的？"><a href="#2-日志的实现框架有哪些常见的？" class="headerlink" title="2.日志的实现框架有哪些常见的？"></a><strong>2.日志的实现框架有哪些常见的？</strong></h6><ul><li>Log4</li><li>Logback(我们重点学习的，其他的都大同小异)</li></ul><h6 id="3-使用Logback需要使用哪几个模块，各自的作用是什么。"><a href="#3-使用Logback需要使用哪几个模块，各自的作用是什么。" class="headerlink" title="3.使用Logback需要使用哪几个模块，各自的作用是什么。"></a>3.使用Logback需要使用哪几个模块，各自的作用是什么。</h6><ul><li>slf4j-api:日志规范</li><li>logback-core:基础模块。</li><li>logback-classic:它是log4j的一个改良版本，同时它完整实现了slf4码API。</li></ul><h6 id="需求：导入Logback日志技术到项目中，用于纪录系统的日志信息"><a href="#需求：导入Logback日志技术到项目中，用于纪录系统的日志信息" class="headerlink" title="需求：导入Logback日志技术到项目中，用于纪录系统的日志信息"></a>需求：导入Logback日志技术到项目中，用于纪录系统的日志信息</h6><p>分析：</p><p>①：在项目下新建文件夹lib，导入Logback的相关jar包到该文件夹下，并添加到项目依赖库中去。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230320143356284.png" alt="image-20230320143356284"></p><p>②：将Logback的核心配置文件logback.xml直接拷贝到src目录下（必须是src下）。</p><p>③：在代码中获取日志的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">LOGGER</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(<span class="hljs-string">&quot;类对象&quot;</span>);<br></code></pre></td></tr></table></figure><p>④：使用日志对象LOGGER调用其方法输出不能的日志信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> 快速搭建logback框架</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">logback</span> &#123;<br>    <span class="hljs-comment">//创建logback对象</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">LOGGER</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(<span class="hljs-string">&quot;logback.class&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            LOGGER.debug(<span class="hljs-string">&quot;main方法开始执行&quot;</span>);<br>            LOGGER.info(<span class="hljs-string">&quot;第二行代码&quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            LOGGER.trace(<span class="hljs-string">&quot;a=&quot;</span>+a);<br>            LOGGER.trace(<span class="hljs-string">&quot;b=&quot;</span>+b);<br>            System.out.println(a / b);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            LOGGER.error(<span class="hljs-string">&quot;功能出现异常&quot;</span>+e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h6><ul><li><p>级别程度依次是：TRACE&lt; DEBUG&lt; INFO&lt;WARN&lt;ERROR ; 默认级别是debug（忽略大小写），对应其方法。</p></li><li><p>作用：用于控制系统中哪些日志级别是可以输出的，只输出级别不低于设定级别的日志信息。</p></li><li><p>ALL  和 OFF分别是打开全部日志信息，及关闭全部日志信息。</p></li></ul><p>具体在<code>&lt;root level=&quot;INFO&quot;&gt;</code>标签的level属性中设置日志级别。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">“INFO</span>&quot;&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><h6 id="File类概述"><a href="#File类概述" class="headerlink" title="File类概述"></a>File类概述</h6><p>File类在包java.io.File下、代表操作系统的文件对象(文件、文件夹)。<br>File类提供了诸如：定位文件，获取文件本身的信息、删除文件、创建文件（文件夹）等功能。</p><h6 id="创建File对象"><a href="#创建File对象" class="headerlink" title="创建File对象"></a>创建File对象</h6><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td><strong>public</strong> File(String  pathname)</td><td>根据文件路径创建文件对象</td></tr><tr><td><strong>public</strong> File(String  parent, String child)</td><td>从父路径名字符串和子路径名字符串创建文件对象</td></tr><tr><td><strong>public</strong> File(File parent, String child)</td><td>根据父路径对应文件对象和子路径名字符串创建文件对象</td></tr></tbody></table><p>绝对路径：从盘符开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">file1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(“D:\\itheima\\a.txt”); <br></code></pre></td></tr></table></figure><p>相对路径：不带盘符，默认直接到当前工程下的目录寻找文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">file3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(“模块名\\a.txt”); <br></code></pre></td></tr></table></figure><h6 id="File类的判断文件类型、获取文件信息功能"><a href="#File类的判断文件类型、获取文件信息功能" class="headerlink" title="File类的判断文件类型、获取文件信息功能"></a>File类的判断文件类型、获取文件信息功能</h6><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public  boolean isDirectory()</td><td>测试此抽象路径名表示的File是否为文件夹</td></tr><tr><td>public  boolean isFile()</td><td>测试此抽象路径名表示的File是否为文件</td></tr><tr><td>public  boolean  exists()</td><td>测试此抽象路径名表示的File是否存在</td></tr><tr><td>public  String getAbsolutePath()</td><td>返回此抽象路径名的绝对路径名字符串</td></tr><tr><td>public  String getPath()</td><td>将此抽象路径名转换为路径名字符串</td></tr><tr><td>public  String getName()</td><td>返回由此抽象路径名表示的文件或文件夹的名称</td></tr><tr><td>public  long lastModified()</td><td>返回文件最后修改的时间毫秒值</td></tr></tbody></table><h6 id="File类创建文件的功能"><a href="#File类创建文件的功能" class="headerlink" title="File类创建文件的功能"></a>File类创建文件的功能</h6><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public boolean createNewFile()</td><td>创建一个新的空的文件</td></tr><tr><td>public boolean mkdir()</td><td>只能创建一级文件夹</td></tr><tr><td>public boolean mkdirs()</td><td>可以创建多级文件夹</td></tr></tbody></table><h6 id="File类删除文件的功能"><a href="#File类删除文件的功能" class="headerlink" title="File类删除文件的功能"></a>File类删除文件的功能</h6><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public  boolean delete()</td><td>删除由此抽象路径名表示的文件或空文件夹</td></tr></tbody></table><ul><li><p>delete方法默认只能删除文件和空文件夹。</p></li><li><p>delete方法直接删除不走回收站</p></li></ul><h6 id="File类的遍历功能"><a href="#File类的遍历功能" class="headerlink" title="File类的遍历功能"></a><strong>File</strong>类的遍历功能</h6><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public String[] list()</td><td>获取当前目录下所有的”一级文件名称”到一个字符串数组中去返回。</td></tr><tr><td>public File[] listFiles()(常用)</td><td>获取当前目录下所有的”一级文件对象”到一个文件对象数组中去返回（重点）</td></tr></tbody></table><p><strong>listFiles方法注意事项：</strong></p><ul><li>当调用者不存在时，返回null</li><li>当调用者是一个文件时，返回null</li><li>当调用者是一个空文件夹时，返回一个长度为0的数组</li><li>当调用者是一个有内容的文件夹时，将里面所有文件和文件夹的路径放在File数组中返回</li><li>当调用者是一个有隐藏文件的文件夹时，将里面所有文件和文件夹的路径放在File数组中返回，包含隐藏内容</li><li>当调用者是一个需要权限才能进入的文件夹时，返回null</li></ul><h6 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h6><p><strong>递归算法三要素大体可以总结为</strong>：</p><ul><li>递归的公式：f（）=f(n-1)*n;</li><li>递归的终结点：f(1)</li><li>递归的方向必须走向终结点：</li></ul><p><strong>需求：计算1-n的阶乘的结果，使用递归思想解决，我们先从数学思维上理解递归的流程和核心点。</strong></p><p>分析</p><p>①假如我们认为存在一个公式是 f(n) = 1*<em>2</em>…(n-1)*n;</p><p>②那么公式等价形式就是： f(n) = f(n-1) *n</p><p>③如果求的是 1-5的阶乘 的结果，我们手工应该应该如何应用上述公式计算。</p><ul><li>f(5) = f(4) * 5</li><li>f(4) = f(3) * 4</li><li>f(3) = f(2) * 3</li><li>f(2) = f(1) * 2</li><li>f(1) = 1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecursionDemo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(f(<span class="hljs-number">5</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> f(n - <span class="hljs-number">1</span>) * n;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>案例</strong></p><p>猴子第一天摘下若干桃子，当即吃了一半，觉得好不过瘾，于是又多吃了一个</p><p>第二天又吃了前天剩余桃子数量的一半，觉得好不过瘾，于是又多吃了一个</p><p>以后每天都是吃前天剩余桃子数量的一半，觉得好不过瘾，又多吃了一个</p><p>等到第10天的时候发现桃子只有1个了。</p><p>需求：请问猴子第一天摘了多少个桃子？</p><p>分析：</p><p>①整体来看，每一天都是做同一个事件，典型的规律化问题，考虑递归三要素：</p><p>②递归公式： </p><p>③递归终结点：</p><p>④递归方向：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">      目标 猴子吃桃。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     公式（合理的）： f(x) - f(x)/2 - 1 = f(x+1)</span><br><span class="hljs-comment">                   2f(x) - f(x) - 2 = 2f(x + 1)</span><br><span class="hljs-comment">                   f(x) = 2f(x + 1) + 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    求f(1) = ?</span><br><span class="hljs-comment">    终结点： f（10） = 1</span><br><span class="hljs-comment">    递归的方向：合理的</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecursionDemo04</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(f(<span class="hljs-number">1</span>));<br>        System.out.println(f(<span class="hljs-number">2</span>));<br>        System.out.println(f(<span class="hljs-number">3</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">10</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * f(n + <span class="hljs-number">1</span>) + <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="111文件查找"><a href="#111文件查找" class="headerlink" title="111文件查找"></a>111文件查找</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：去D判断搜索 eDiary.exe文件</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecursionDemo05</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 2、传入目录 和  文件名称</span><br>        searchFile(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:/&quot;</span>) , <span class="hljs-string">&quot;eDiary.exe&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1、搜索某个目录下的全部文件，找到我们想要的文件。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dir  被搜索的源目录</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileName 被搜索的文件名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">searchFile</span><span class="hljs-params">(File dir,String fileName)</span>&#123;<br>        <span class="hljs-comment">// 3、判断dir是否是目录</span><br>        <span class="hljs-keyword">if</span>(dir != <span class="hljs-literal">null</span> &amp;&amp; dir.isDirectory())&#123;<br>            <span class="hljs-comment">// 可以找了</span><br>            <span class="hljs-comment">// 4、提取当前目录下的一级文件对象</span><br>            File[] files = dir.listFiles(); <span class="hljs-comment">// null  []</span><br>            <span class="hljs-comment">// 5、判断是否存在一级文件对象，存在才可以遍历</span><br>            <span class="hljs-keyword">if</span>(files != <span class="hljs-literal">null</span> &amp;&amp; files.length &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">for</span> (File file : files) &#123;<br>                    <span class="hljs-comment">// 6、判断当前遍历的一级文件对象是文件 还是 目录</span><br>                    <span class="hljs-keyword">if</span>(file.isFile())&#123;<br>                        <span class="hljs-comment">// 7、是不是咱们要找的，是把其路径输出即可</span><br>                        <span class="hljs-keyword">if</span>(file.getName().contains(fileName))&#123;<br>                            System.out.println(<span class="hljs-string">&quot;找到了：&quot;</span> + file.getAbsolutePath());<br>                            <span class="hljs-comment">// 启动它。</span><br>                            <span class="hljs-keyword">try</span> &#123;<br>                                <span class="hljs-type">Runtime</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<br>                                r.exec(file.getAbsolutePath());<br>                            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                                e.printStackTrace();<br>                            &#125;<br>                        &#125;<br>                    &#125;<span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// 8、是文件夹，需要继续递归寻找</span><br>                        searchFile(file, fileName);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;对不起，当前搜索的位置不是文件夹！&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h4><h6 id="1-字符串常见的字符底层组成是什么样的？"><a href="#1-字符串常见的字符底层组成是什么样的？" class="headerlink" title="1.字符串常见的字符底层组成是什么样的？"></a>1.字符串常见的字符底层组成是什么样的？</h6><ul><li>英文和数字等在任何国家的字符集中都占1个字节</li><li>GBK字符中一个中文字符占2个字节</li><li>UTF-8编码中一个中文1般占3个字节</li></ul><h6 id="2-编码前的字符集和编码好的字符集有什么要求？"><a href="#2-编码前的字符集和编码好的字符集有什么要求？" class="headerlink" title="2.编码前的字符集和编码好的字符集有什么要求？"></a>2.编码前的字符集和编码好的字符集有什么要求？</h6><ul><li>必须一致，否则会出现中文字符乱码</li></ul><p>String编码</p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>byte[] getBytes()</td><td>使用平台的默认字符集将该  String编码为一系列字节，将结果存储到新的字节数组中</td></tr><tr><td>byte[] getBytes(String charsetName)</td><td>使用指定的字符集将该 String编码为一系列字节，将结果存储到新的字节数组中</td></tr></tbody></table><p>String解码</p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>String(byte[] bytes)</td><td>通过使用平台的默认字符集解码指定的字节数组来构造新的  String</td></tr><tr><td>String(byte[] bytes, String charsetName)</td><td>通过指定的字符集解码指定的字节数组来构造新的 String</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     目标：学会自己进行文字的编码和解码，为以后可能用到的场景做准备。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1、编码：把文字转换成字节（使用指定的编码）</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc我爱你中国&quot;</span>;<br>        <span class="hljs-comment">// byte[] bytes = name.getBytes(); // 以当前代码默认字符集进行编码 （UTF-8）</span><br>        <span class="hljs-type">byte</span>[] bytes = name.getBytes(<span class="hljs-string">&quot;GBK&quot;</span>); <span class="hljs-comment">// 指定编码</span><br>        System.out.println(bytes.length);<br>        System.out.println(Arrays.toString(bytes));<br><br>        <span class="hljs-comment">// 2、解码：把字节转换成对应的中文形式（编码前 和 编码后的字符集必须一致，否则乱码 ）</span><br>        <span class="hljs-comment">// String rs = new String(bytes); // 默认的UTF-8</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes, <span class="hljs-string">&quot;GBK&quot;</span>); <span class="hljs-comment">// 指定GBK解码</span><br>        System.out.println(rs);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h4><h6 id="IO流概述"><a href="#IO流概述" class="headerlink" title="IO流概述"></a><strong>IO</strong>流概述</h6><ul><li><p>I表示intput，是数据从硬盘文件读入到内存的过程，称之输入，负责读。</p></li><li><p>O表示output，是内存程序的数据从内存到写出到硬盘文件的过程，称之输出，负责写。</p></li></ul><h6 id="总结流的四大类"><a href="#总结流的四大类" class="headerlink" title="总结流的四大类:"></a><strong>总结</strong>流的四大类:</h6><ul><li><p>字节输入流：以内存为基准，来自磁盘文件/网络中的数据以字节的形式读入到内存中去的流称为字节输入流。</p></li><li><p>字节输出流：以内存为基准，把内存中的数据以字节写出到磁盘文件或者网络中去的流称为字节输出流。</p></li><li><p>字符输入流：以内存为基准，来自磁盘文件/网络中的数据以字符的形式读入到内存中去的流称为字符输入流。</p></li><li><p>字符输出流：以内存为基准，把内存中的数据以字符写出到磁盘文件或者网络介质中去的流称为字符输出流。</p></li></ul><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220428190902198.png" alt="image-20220428190902198"></p><h6 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h6><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public int  read()</td><td>每次读取一个字节返回，如果字节已经没有可读的返回-1</td></tr><tr><td>public int  read(byte[] buffer)</td><td>每次读取一个字节数组返回读取字节数，如果字节已经没有可读的返回-1</td></tr></tbody></table><p>1.如何使用字节输入流读取中文内容输出不乱码呢？<br>    一次性读取完全部字节。<br>    可以定义与文件一样大的字节数组读取，也可以使用官方API。<br>2.直接把文件数据全部读取到一个字节数组可以避免乱码，是否存在问题？<br>    如果文件过大，定义的字节数组可能引起内存溢出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   目标：使用文件字节输入流每次读取一个字节数组的数据。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileInputStreamDemo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1、创建一个文件字节输入流管道与源文件接通</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;file-io-app/src/data02.txt&quot;</span>);<br><br>        <span class="hljs-comment">// 2、定义一个字节数组，用于读取字节数组</span><br><span class="hljs-comment">//        byte[] buffer = new byte[3]; // 3B</span><br><span class="hljs-comment">//        int len = is.read(buffer);</span><br><span class="hljs-comment">//        System.out.println(&quot;读取了几个字节：&quot; + len);</span><br><span class="hljs-comment">//        String rs = new String(buffer);</span><br><span class="hljs-comment">//        System.out.println(rs);</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//        int len1 = is.read(buffer);</span><br><span class="hljs-comment">//        System.out.println(&quot;读取了几个字节：&quot; + len1);</span><br><span class="hljs-comment">//        String rs1 = new String(buffer);</span><br><span class="hljs-comment">//        System.out.println(rs1);</span><br><span class="hljs-comment">//        // buffer = [a b c]</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//        // buffer = [a b c]  ==&gt;  [c d c]</span><br><span class="hljs-comment">//        int len2 = is.read(buffer);</span><br><span class="hljs-comment">//        System.out.println(&quot;读取了几个字节：&quot; + len2);</span><br><span class="hljs-comment">//        // 读取多少倒出多少</span><br><span class="hljs-comment">//        String rs2 = new String(buffer,0 ,len2);</span><br><span class="hljs-comment">//        System.out.println(rs2);</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//        int len3 = is.read(buffer);</span><br><span class="hljs-comment">//        System.out.println(len3); // 读取完毕返回-1</span><br><br>        <span class="hljs-comment">// 3、改进使用循环，每次读取一个字节数组</span><br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">3</span>];<br>        <span class="hljs-type">int</span> len; <span class="hljs-comment">// 记录每次读取的字节数。</span><br>        <span class="hljs-keyword">while</span> ((len = is.read(buffer)) != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 读取多少倒出多少</span><br>            System.out.print(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer, <span class="hljs-number">0</span> , len));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="文件字节输出流：FileOutputStream"><a href="#文件字节输出流：FileOutputStream" class="headerlink" title="文件字节输出流：FileOutputStream"></a><strong>文件字节输出流：FileOutputStream</strong></h6><p>作用：以内存为基准，把内存中的数据以字节的形式写出到磁盘文件中去的流。</p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public FileOutputStream(File file)</td><td>创建字节输出流管道与源文件对象接通</td></tr><tr><td>public FileOutputStream(File file，boolean append)</td><td>创建字节输出流管道与源文件对象接通，可追加数据</td></tr><tr><td>public FileOutputStream(String filepath)</td><td>创建字节输出流管道与源文件路径接通</td></tr><tr><td>public FileOutputStream(String filepath，boolean append)</td><td>创建字节输出流管道与源文件路径接通，可追加数据</td></tr></tbody></table><h6 id="文件字节输出流（FileOutputStream）写数据出去的API"><a href="#文件字节输出流（FileOutputStream）写数据出去的API" class="headerlink" title="文件字节输出流（FileOutputStream）写数据出去的API"></a>文件字节输出流（FileOutputStream）写数据出去的API</h6><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public void write(int a)</td><td>写一个字节出去</td></tr><tr><td>public void write(byte[] buffer)</td><td>写一个字节数组出去</td></tr><tr><td>public void write(byte[] buffer , int pos , int len)</td><td>写一个字节数组的一部分出去。</td></tr></tbody></table><h6 id="流的关闭与刷新"><a href="#流的关闭与刷新" class="headerlink" title="流的关闭与刷新"></a><strong>流的关闭与刷新</strong></h6><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>flush()</td><td>刷新流，还可以继续写数据</td></tr><tr><td>close()</td><td>关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据</td></tr></tbody></table><p>字节输出流如何实现写出去的数据能换行?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">os.write“\r\n”.getBytes())<br></code></pre></td></tr></table></figure><p>如何让写出去的数据能成功生效？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">flush()刷新数据<br><br>close()方法是关闭流，关闭包含刷新，关闭后流不可以继续使用了。<br></code></pre></td></tr></table></figure><h6 id="案例：文件复制"><a href="#案例：文件复制" class="headerlink" title="案例：文件复制"></a>案例：文件复制</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *   目标：学会使用finally释放资源。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TryCatchFinallyDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br><br>            <span class="hljs-comment">// System.out.println(10/ 0);</span><br><br>            <span class="hljs-comment">// 1、创建一个字节输入流管道与原视频接通</span><br>             is = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;file-io-app/src/out04.txt&quot;</span>);<br><br>            <span class="hljs-comment">// 2、创建一个字节输出流管道与目标文件接通</span><br>             os = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;file-io-app/src/out05.txt&quot;</span>);<br><br>            <span class="hljs-comment">// 3、定义一个字节数组转移数据</span><br>            <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-type">int</span> len; <span class="hljs-comment">// 记录每次读取的字节数。</span><br>            <span class="hljs-keyword">while</span> ((len = is.read(buffer)) != -<span class="hljs-number">1</span>)&#123;<br>                os.write(buffer, <span class="hljs-number">0</span> , len);<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;复制完成了！&quot;</span>);<br><br>         <span class="hljs-comment">//   System.out.println( 10 / 0);</span><br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 无论代码是正常结束，还是出现异常都要最后执行这里</span><br>            System.out.println(<span class="hljs-string">&quot;========finally=========&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 4、关闭流。</span><br>                <span class="hljs-keyword">if</span>(os!=<span class="hljs-literal">null</span>)os.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span>(is != <span class="hljs-literal">null</span>) is.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        System.out.println(test(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a , <span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a / b;<br>            <span class="hljs-keyword">return</span> c;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">111111</span>; <span class="hljs-comment">// 计算出现bug.</span><br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;--finally--&quot;</span>);<br>            <span class="hljs-comment">// 哪怕上面有return语句执行，也必须先执行完这里才可以！</span><br>            <span class="hljs-comment">// 开发中不建议在这里加return ，如果加了，返回的永远是这里的数据了，这样会出问题！</span><br>            <span class="hljs-comment">//return 100;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *   目标：学会使用JDK 7的新方式释放资源</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TryCatchResouceDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-keyword">try</span> (<br>                <span class="hljs-comment">// 这里面只能放置资源对象，用完会自动关闭：自动调用资源对象的close方法关闭资源（即使出现异常也会做关闭操作）</span><br>                <span class="hljs-comment">// 1、创建一个字节输入流管道与原视频接通</span><br>               <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;file-io-app/src/out04.txt&quot;</span>);<br>                <span class="hljs-comment">// 2、创建一个字节输出流管道与目标文件接通</span><br>               <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;file-io-app/src/out05.txt&quot;</span>);<br><br>               <span class="hljs-comment">// int age = 23; // 这里只能放资源</span><br>                <span class="hljs-type">MyConnection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyConnection</span>(); <span class="hljs-comment">// 最终会自动调用资源的close方法</span><br>                ) &#123;<br><br>            <span class="hljs-comment">// 3、定义一个字节数组转移数据</span><br>            <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-type">int</span> len; <span class="hljs-comment">// 记录每次读取的字节数。</span><br>            <span class="hljs-keyword">while</span> ((len = is.read(buffer)) != -<span class="hljs-number">1</span>)&#123;<br>                os.write(buffer, <span class="hljs-number">0</span> , len);<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;复制完成了！&quot;</span>);<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConnection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AutoCloseable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;连接资源被成功释放了！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="1-字节流适合做一切文件数据的拷贝吗？"><a href="#1-字节流适合做一切文件数据的拷贝吗？" class="headerlink" title="1.字节流适合做一切文件数据的拷贝吗？"></a>1.字节流适合做一切文件数据的拷贝吗？</h6><ul><li>任何文件的底层都是字节，拷贝是一字不漏的转移字节，只要前后文件格式、编码一致没有任何问题。</li></ul><h6 id="文件字符输入流"><a href="#文件字符输入流" class="headerlink" title="文件字符输入流"></a>文件字符输入流</h6><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public FileReader(File file)</td><td>创建字符输入流管道与源文件对象接通</td></tr><tr><td>public FileReader(String  pathname)</td><td>创建字符输入流管道与源文件路径接通</td></tr></tbody></table><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public int read()</td><td>每次读取一个字符返回，如果字符已经没有可读的返回-1</td></tr><tr><td>public int  read(char[] buffer)</td><td>每次读取一个字符数组，返回读取的字符个数，如果字符已经没有可读的返回-1</td></tr></tbody></table><p>字符流的好处，每次读取一个字符存在什么问题？<br>    读取中文字符不会出现乱码（如果代码和文件编码一致）<br>    性能较慢</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     目标：字符输入流的使用。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     IO流的体系：</span><br><span class="hljs-comment">            字节流                                   字符流</span><br><span class="hljs-comment">     字节输入流           字节输出流               字符输入流       字符输出流</span><br><span class="hljs-comment">     InputStream         OutputStream            Reader         Writer     (抽象类)</span><br><span class="hljs-comment">     FileInputStream     FileOutputStream        FileReader     FileWriter (实现类)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     c.FileReader:文件字符输入流。</span><br><span class="hljs-comment">         -- 作用：以内存为基准，把磁盘文件的数据以字符的形式读入到内存。</span><br><span class="hljs-comment">            简单来说，读取文本文件内容到内存中去。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">         -- 构造器：</span><br><span class="hljs-comment">            public FileReader(File file):创建一个字符输入流与源文件对象接通。</span><br><span class="hljs-comment">            public FileReader(String filePath):创建一个字符输入流与源文件路径接通。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">         -- 方法：</span><br><span class="hljs-comment">            public int read(): 读取一个字符的编号返回！ 读取完毕返回-1</span><br><span class="hljs-comment">            public int read(char[] buffer):读取一个字符数组，读取多少个字符就返回多少个数量，读取完毕返回-1</span><br><span class="hljs-comment">     小结：</span><br><span class="hljs-comment">        字符流一个一个字符的读取文本内容输出，可以解决中文读取输出乱码的问题。</span><br><span class="hljs-comment">        字符流很适合操作文本文件内容。</span><br><span class="hljs-comment">        但是：一个一个字符的读取文本内容性能较差！！</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileReaderDemo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 目标：每次读取一个字符。</span><br>        <span class="hljs-comment">// 1、创建一个字符输入流管道与源文件接通</span><br>        <span class="hljs-type">Reader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;file-io-app\\src\\data06.txt&quot;</span>);<br><br>        <span class="hljs-comment">// 2、读取一个字符返回，没有可读的字符了返回-1</span><br><span class="hljs-comment">//        int code = fr.read();</span><br><span class="hljs-comment">//        System.out.print((char)code);</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//        int code1 = fr.read();</span><br><span class="hljs-comment">//        System.out.print((char)code1);</span><br><br>        <span class="hljs-comment">// 3、使用循环读取字符</span><br>        <span class="hljs-type">int</span> code;<br>        <span class="hljs-keyword">while</span> ((code = fr.read()) != -<span class="hljs-number">1</span>)&#123;<br>            System.out.print((<span class="hljs-type">char</span>) code);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileReaderDemo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1、创建一个文件字符输入流与源文件接通</span><br>        <span class="hljs-type">Reader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;file-io-app/src/data07.txt&quot;</span>);<br><br>        <span class="hljs-comment">// 2、用循环，每次读取一个字符数组的数据。  1024 + 1024 + 8</span><br>        <span class="hljs-type">char</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">1024</span>]; <span class="hljs-comment">// 1K字符</span><br>        <span class="hljs-type">int</span> len;<br>        <span class="hljs-keyword">while</span> ((len = fr.read(buffer)) != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer, <span class="hljs-number">0</span>, len);<br>            System.out.print(rs);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     目标：字符输出流的使用。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     IO流的体系：</span><br><span class="hljs-comment">            字节流                                   字符流</span><br><span class="hljs-comment">     字节输入流           字节输出流               字符输入流       字符输出流</span><br><span class="hljs-comment">     InputStream         OutputStream           Reader         Writer     (抽象类)</span><br><span class="hljs-comment">     FileInputStream     FileOutputStream       FileReader     FileWriter (实现类)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     d.FileWriter文件字符输出流的使用。</span><br><span class="hljs-comment">        -- 作用：以内存为基准，把内存中的数据按照字符的形式写出到磁盘文件中去。</span><br><span class="hljs-comment">            简单来说，就是把内存的数据以字符写出到文件中去。</span><br><span class="hljs-comment">        -- 构造器：</span><br><span class="hljs-comment">           public FileWriter(File file):创建一个字符输出流管道通向目标文件对象。</span><br><span class="hljs-comment">           public FileWriter(String filePath):创建一个字符输出流管道通向目标文件路径。</span><br><span class="hljs-comment">           public FileWriter(File file,boolean append):创建一个追加数据的字符输出流管道通向目标文件对象。</span><br><span class="hljs-comment">           public FileWriter(String filePath,boolean append):创建一个追加数据的字符输出流管道通向目标文件路径。</span><br><span class="hljs-comment">        -- 方法：</span><br><span class="hljs-comment">             a.public void write(int c):写一个字符出去</span><br><span class="hljs-comment">             b.public void write(String c)写一个字符串出去：</span><br><span class="hljs-comment">             c.public void write(char[] buffer):写一个字符数组出去</span><br><span class="hljs-comment">             d.public void write(String c ,int pos ,int len):写字符串的一部分出去</span><br><span class="hljs-comment">             e.public void write(char[] buffer ,int pos ,int len):写字符数组的一部分出去</span><br><span class="hljs-comment">     小结：</span><br><span class="hljs-comment">        字符输出流可以写字符数据出去，总共有5个方法写字符。</span><br><span class="hljs-comment">        覆盖管道：</span><br><span class="hljs-comment">             Writer fw = new FileWriter(&quot;Day10Demo/src/dlei03.txt&quot;); // 覆盖数据管道</span><br><span class="hljs-comment">        追加数据管道：</span><br><span class="hljs-comment">             Writer fw = new FileWriter(&quot;Day10Demo/src/dlei03.txt&quot;,true); // 追加数据管道</span><br><span class="hljs-comment">        换行：</span><br><span class="hljs-comment">             fw.write(&quot;\r\n&quot;); // 换行</span><br><span class="hljs-comment">        结论：读写字符文件数据建议使用字符流。复制文件建议使用字节流。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileWriterDemo03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1、创建一个字符输出流管道与目标文件接通</span><br>        <span class="hljs-comment">// Writer fw = new FileWriter(&quot;file-io-app/src/out08.txt&quot;); // 覆盖管道，每次启动都会清空文件之前的数据</span><br>        <span class="hljs-type">Writer</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;file-io-app/src/out08.txt&quot;</span>, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 覆盖管道，每次启动都会清空文件之前的数据</span><br><br><span class="hljs-comment">//      a.public void write(int c):写一个字符出去</span><br>        fw.write(<span class="hljs-number">98</span>);<br>        fw.write(<span class="hljs-string">&#x27;a&#x27;</span>);<br>        fw.write(<span class="hljs-string">&#x27;徐&#x27;</span>); <span class="hljs-comment">// 不会出问题了</span><br>        fw.write(<span class="hljs-string">&quot;\r\n&quot;</span>); <span class="hljs-comment">// 换行</span><br><br><span class="hljs-comment">//       b.public void write(String c)写一个字符串出去</span><br>        fw.write(<span class="hljs-string">&quot;abc我是中国人&quot;</span>);<br>        fw.write(<span class="hljs-string">&quot;\r\n&quot;</span>); <span class="hljs-comment">// 换行</span><br><br><br><span class="hljs-comment">//       c.public void write(char[] buffer):写一个字符数组出去</span><br>        <span class="hljs-type">char</span>[] chars = <span class="hljs-string">&quot;abc我是中国人&quot;</span>.toCharArray();<br>        fw.write(chars);<br>        fw.write(<span class="hljs-string">&quot;\r\n&quot;</span>); <span class="hljs-comment">// 换行</span><br><br><br><span class="hljs-comment">//       d.public void write(String c ,int pos ,int len):写字符串的一部分出去</span><br>        fw.write(<span class="hljs-string">&quot;abc我是中国人&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>);<br>        fw.write(<span class="hljs-string">&quot;\r\n&quot;</span>); <span class="hljs-comment">// 换行</span><br><br><br><span class="hljs-comment">//       e.public void write(char[] buffer ,int pos ,int len):写字符数组的一部分出去</span><br>        fw.write(chars, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>);<br>        fw.write(<span class="hljs-string">&quot;\r\n&quot;</span>); <span class="hljs-comment">// 换行</span><br><br><br>        <span class="hljs-comment">// fw.flush();// 刷新后流可以继续使用</span><br>        fw.close(); <span class="hljs-comment">// 关闭包含刷新，关闭后流不能使用</span><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h4><h6 id="缓冲流概述"><a href="#缓冲流概述" class="headerlink" title="缓冲流概述"></a>缓冲流概述</h6><p>缓冲流也称为高效流、或者高级流。之前学习的字节流可以称为原始流。<br>作用：缓冲流自带缓冲区、可以提高原始字节流、字符流读写数据的性能</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220429095931746.png" alt="image-20220429095931746"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220429095931746.png"><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220429100034115.png" alt="image-20220429100034115"></p><p>1.缓冲流的作用？<br>    缓冲流自带缓冲区、可以提高原始字节流、字符流读写数据的性能<br>2.缓冲流有几种？<br>字节缓冲流<br>    字节缓冲输入流：BufferedInputStream<br>    字节缓冲输出流：BufferedOutputStream<br>字符缓冲流<br>    字符缓冲输入流：BufferedReader<br>    字符缓冲输出流：BufferedWriter</p><p><strong>字节缓冲流性能优化原理：</strong></p><p>​    字节缓冲输入流自带了8KB缓冲池，以后我们直接从缓冲池读取数据，所以性能较好。</p><p>​    字节缓冲输出流自带了8KB缓冲池，数据就直接写入到缓冲池中去，写数据性能极高了。</p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public BufferedInputStream(InputStream is)</td><td>可以把低级的字节输入流包装成一个高级的缓冲字节输入流管道，从而提高字节输入流读数据的性能</td></tr><tr><td>public BufferedOutputStream(OutputStream os)</td><td>可以把低级的字节输出流包装成一个高级的缓冲字节输出流，从而提高写数据的性能</td></tr></tbody></table><p>1.推荐使用哪种方式提高字节流读写数据的性能？</p><p><strong>建议使用字节缓冲输入流、字节缓冲输出流，结合字节数组的方式，目前来看是性能最优的组合。</strong></p><h6 id="字符缓冲输入流"><a href="#字符缓冲输入流" class="headerlink" title="字符缓冲输入流"></a><strong>字符缓冲输入流</strong></h6><p>字符缓冲输入流：BufferedReader。</p><p>作用：提高字符输入流读取数据的性能，除此之外多了按照行读取数据的功能</p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public  BufferedReader(Reader r)</td><td>可以把低级的字符输入流包装成一个高级的缓冲字符输入流管道，从而提高字符输入流读数据的性能</td></tr></tbody></table><h6 id="字符缓冲输入流新增功能"><a href="#字符缓冲输入流新增功能" class="headerlink" title="字符缓冲输入流新增功能"></a><strong>字符缓冲输入流新增功能</strong></h6><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public  String readLine()</td><td>读取一行数据返回，如果读取没有完毕，无行可读返回null</td></tr></tbody></table><h6 id="字符缓冲输出流"><a href="#字符缓冲输出流" class="headerlink" title="字符缓冲输出流"></a><strong>字符缓冲输出流</strong></h6><p> 字符缓冲输出流：BufferedWriter。</p><p> 作用：提高字符输出流写取数据的性能，除此之外多了换行功能</p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public BufferedWriter(Writer  w)</td><td>可以把低级的字符输出流包装成一个高级的缓冲字符输出流管道，从而提高字符输出流写数据的性能</td></tr></tbody></table><h6 id="字符缓冲输出流新增功能"><a href="#字符缓冲输出流新增功能" class="headerlink" title="字符缓冲输出流新增功能"></a><strong>字符缓冲输出流新增功能</strong></h6><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public  void newLine()</td><td>换行操作</td></tr></tbody></table><h4 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h4><p>1、如果代码编码和文件编码不一致，使用字符流直接读取还能不乱码吗？<br>    会乱码。<br>2、如果如何解决呢？<br>    使用字符输入转换流<br>    可以提取文件(GBK)的原始字节流，原始字节不会存在问题。<br>    然后把字节流以指定编码转换成字符输入流，这样字符输入流中的字符就不乱码了</p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public InputStreamReader(InputStream is)</td><td>可以把原始的字节流按照代码默认编码转换成字符输入流。几乎不用，与默认的FileReader一样。</td></tr><tr><td>public InputStreamReader(InputStream is ，String charset)</td><td>可以把原始的字节流按照指定编码转换成字符输入流，这样字符流中的字符就不乱码了(重点)</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     目标：字符输入转换流InputStreamReader的使用。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">             字节流                                     字符流</span><br><span class="hljs-comment">     字节输入流               字节输出流              字符输入流            字符输出流</span><br><span class="hljs-comment">     InputStream             OutputStream          Reader               Writer   (抽象类)</span><br><span class="hljs-comment">     FileInputStream         FileOutputStream      FileReader           FileWriter(实现类)</span><br><span class="hljs-comment">     BufferedInputStream     BufferedOutputStream  BufferedReader       BufferedWriter(实现类，缓冲流)</span><br><span class="hljs-comment">                                                   InputStreamReader    OutputStreamWriter</span><br><span class="hljs-comment">     字符输入转换流InputStreamReader:</span><br><span class="hljs-comment">          -- 作用：可以解决字符流读取不同编码乱码的问题。</span><br><span class="hljs-comment">                  也可以把原始的字节流按照指定编码转换成字符输入流</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">          -- 构造器：</span><br><span class="hljs-comment">                public InputStreamReader(InputStream is)：可以使用当前代码默认编码转换成字符流，几乎不用！</span><br><span class="hljs-comment">                public InputStreamReader(InputStream is,String charset):可以指定编码把字节流转换成字符流(核心)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     小结：</span><br><span class="hljs-comment">        字符输入转换流InputStreamReader:作用：可以解决字符流读取不同编码乱码的问题。</span><br><span class="hljs-comment">        public InputStreamReader(InputStream is,String charset):可以指定编码把字节流转换成字符流(核心)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputStreamReaderDemo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 代码UTF-8   文件 GBK  &quot;D:\\resources\\data.txt&quot;</span><br>        <span class="hljs-comment">// 1、提取GBK文件的原始字节流。   abc 我</span><br>        <span class="hljs-comment">//                            ooo oo</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:\\resources\\data.txt&quot;</span>);<br>        <span class="hljs-comment">// 2、把原始字节流转换成字符输入流</span><br>        <span class="hljs-comment">// Reader isr = new InputStreamReader(is); // 默认以UTF-8的方式转换成字符流。 还是会乱码的  跟直接使用FileReader是一样的</span><br>        <span class="hljs-type">Reader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(is , <span class="hljs-string">&quot;GBK&quot;</span>); <span class="hljs-comment">// 以指定的GBK编码转换成字符输入流  完美的解决了乱码问题</span><br><br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(isr);<br>        String line;<br>        <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-literal">null</span>)&#123;<br>            System.out.println(line);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>字符输出转换流</strong></p><p>字符输入转换流：OutputStreamWriter，可以把字节输出流按照指定编码转换成字符输出流。</p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public OutputStreamWriter(OutputStream os)</td><td>可以把原始的字节输出流按照代码默认编码转换成字符输出流。几乎不用。</td></tr><tr><td>public OutputStreamWriter(OutputStream os，String  charset)</td><td>可以把原始的字节输出流按照指定编码转换成字符输出流(重点)</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     目标：字符输出转换OutputStreamWriter流的使用。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                字节流                                         字符流</span><br><span class="hljs-comment">     字节输入流               字节输出流              字符输入流            字符输出流</span><br><span class="hljs-comment">     InputStream             OutputStream          Reader               Writer   (抽象类)</span><br><span class="hljs-comment">     FileInputStream         FileOutputStream      FileReader           FileWriter(实现类)</span><br><span class="hljs-comment">     BufferedInputStream     BufferedOutputStream  BufferedReader       BufferedWriter(实现类，缓冲流)</span><br><span class="hljs-comment">                                                   InputStreamReader    OutputStreamWriter</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     字符输出转换流：OutputStreamWriter</span><br><span class="hljs-comment">           -- 作用：可以指定编码把字节输出流转换成字符输出流。</span><br><span class="hljs-comment">                   可以指定写出去的字符的编码。</span><br><span class="hljs-comment">           -- 构造器：</span><br><span class="hljs-comment">                public OutputStreamWriter(OutputStream os) :   用当前默认编码UTF-8把字节输出流转换成字符输出流</span><br><span class="hljs-comment">                public OutputStreamWriter(OutputStream os , String charset):指定编码把字节输出流转换成字符输出流</span><br><span class="hljs-comment">     小结：</span><br><span class="hljs-comment">        字符输出转换流OutputStreamWriter可以指定编码把字节输出流转换成字符输出流。</span><br><span class="hljs-comment">        从而实现指定写出去的字符编码！</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OutputStreamWriterDemo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1、定义一个字节输出流</span><br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;io-app2/src/out03.txt&quot;</span>);<br><br>        <span class="hljs-comment">// 2、把原始的字节输出流转换成字符输出流</span><br>        <span class="hljs-comment">// Writer osw = new OutputStreamWriter(os); // 以默认的UTF-8写字符出去 跟直接写FileWriter一样</span><br>        <span class="hljs-type">Writer</span> <span class="hljs-variable">osw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(os , <span class="hljs-string">&quot;GBK&quot;</span>); <span class="hljs-comment">// 指定GBK的方式写字符出去</span><br><br>        <span class="hljs-comment">// 3、把低级的字符输出流包装成高级的缓冲字符输出流。</span><br>        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(osw);<br><br>        bw.write(<span class="hljs-string">&quot;我爱中国1~~&quot;</span>);<br>        bw.write(<span class="hljs-string">&quot;我爱中国2~~&quot;</span>);<br>        bw.write(<span class="hljs-string">&quot;我爱中国3~~&quot;</span>);<br><br>        bw.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h4><h6 id="对象序列化："><a href="#对象序列化：" class="headerlink" title="对象序列化："></a><strong>对象序列化</strong>：</h6><p>作用：以内存为基准，把内存中的对象存储到磁盘文件中去，称为对象序列化。</p><p>使用到的流是对象字节输出流：ObjectOutputStream</p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public ObjectOutputStream(OutputStream  out)</td><td>把低级字节输出流包装成高级的对象字节输出流</td></tr></tbody></table><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public final void writeObject(Object obj)</td><td>把对象写出去到对象序列化流的文件中去</td></tr></tbody></table><p>1.对象序列化的含义是什么？</p><p><strong>把对象数据存入到文件中去。</strong></p><p>2.对象序列化用到了哪个流？</p><p><strong>对象字节输出流ObjectOutputStram</strong></p><p><strong>public void writeObject(Object obj)</strong></p><p>3.序列化对象的要求是怎么样的？</p><p><strong>对象必须实现序列化接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  对象如果要序列化，必须实现Serializable序列化接口。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-comment">// 申明序列化的版本号码</span><br>    <span class="hljs-comment">// 序列化的版本号与反序列化的版本号必须一致才不会出错！</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String loginName;<br>    <span class="hljs-comment">// transient修饰的成员变量不参与序列化了</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> String passWord;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age ;<br>.<br>    .<br>    .  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     目标：学会对象序列化，使用 ObjectOutputStream 把内存中的对象存入到磁盘文件中。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     transient修饰的成员变量不参与序列化了</span><br><span class="hljs-comment">     对象如果要序列化，必须实现Serializable序列化接口。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     申明序列化的版本号码</span><br><span class="hljs-comment">     序列化的版本号与反序列化的版本号必须一致才不会出错！</span><br><span class="hljs-comment">     private static final long serialVersionUID = 1;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectOutputStreamDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1、创建学生对象</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;陈磊&quot;</span>, <span class="hljs-string">&quot;chenlei&quot;</span>,<span class="hljs-string">&quot;1314520&quot;</span>, <span class="hljs-number">21</span>);<br><br>        <span class="hljs-comment">// 2、对象序列化：使用对象字节输出流包装字节输出流管道</span><br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;io-app2/src/obj.txt&quot;</span>));<br><br>        <span class="hljs-comment">// 3、直接调用序列化方法</span><br>        oos.writeObject(s);<br><br>        <span class="hljs-comment">// 4、释放资源</span><br>        oos.close();<br>        System.out.println(<span class="hljs-string">&quot;序列化完成了~~&quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="对象反序列化："><a href="#对象反序列化：" class="headerlink" title="对象反序列化："></a><strong>对象反序列化</strong>：</h6><p>使用到的流是对象字节输入流：ObjectInputStream</p><p>作用：以内存为基准，把存储到磁盘文件中去的对象数据恢复成内存中的对象，称为对象反序列化。</p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public ObjectInputStream(InputStream  out)</td><td>把低级字节输如流包装成高级的对象字节输入流</td></tr></tbody></table><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public  Object readObject()</td><td>把存储到磁盘文件中去的对象数据恢复成内存中的对象返回</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：学会进行对象反序列化：使用对象字节输入流把文件中的对象数据恢复成内存中的Java对象。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectInputStreamDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1、创建对象字节输入流管道包装低级的字节输入流管道</span><br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;io-app2/src/obj.txt&quot;</span>));<br><br>        <span class="hljs-comment">// 2、调用对象字节输入流的反序列化方法</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (Student) is.readObject();<br><br>        System.out.println(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h6><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220429103304035.png" alt="image-20220429103304035"></p><p><strong>打印流</strong></p><p>作用：打印流可以实现方便、高效的打印数据到文件中去。打印流一般是指：PrintStream，PrintWriter两个类。</p><p>可以实现打印什么数据就是什么数据，例如打印整数97写出去就是97，打印boolean的true，写出去就是true。</p><p><strong>PrintStream</strong></p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public PrintStream(OutputStream os)</td><td>打印流直接通向字节输出流管道</td></tr><tr><td>public PrintStream(File f)</td><td>打印流直接通向文件对象</td></tr><tr><td>public PrintStream(String filepath)</td><td>打印流直接通向文件路径</td></tr></tbody></table><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public void print(Xxx  xx)</td><td>打印任意类型的数据出去</td></tr></tbody></table><p><strong>PrintWriter</strong></p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public PrintWriter(OutputStream os)</td><td>打印流直接通向字节输出流管道</td></tr><tr><td>public PrintWriter (Writer w)</td><td>打印流直接通向字符输出流管道</td></tr><tr><td>public PrintWriter (File f)</td><td>打印流直接通向文件对象</td></tr><tr><td>public PrintWriter (String filepath)</td><td>打印流直接通向文件路径</td></tr></tbody></table><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public void print(Xxx  xx)</td><td>打印任意类型的数据出去</td></tr></tbody></table><p><strong>PrintStream和PrintWriter的区别</strong></p><p>打印数据功能上是一模一样的，都是使用方便，性能高效（核心优势）</p><p>PrintStream继承自字节输出流OutputStream，支持写字节数据的方法。</p><p>PrintWriter继承自字符输出流Writer，支持写字符数据出去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：学会使用打印流 高效  方便写数据到文件。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1、创建一个打印流对象</span><br><span class="hljs-comment">//        PrintStream ps = new PrintStream(new FileOutputStream(&quot;io-app2/src/ps.txt&quot;));</span><br><span class="hljs-comment">//        PrintStream ps = new PrintStream(new FileOutputStream(&quot;io-app2/src/ps.txt&quot; , true)); // 追加数据，在低级管道后面加True</span><br><span class="hljs-comment">//        PrintStream ps = new PrintStream(&quot;io-app2/src/ps.txt&quot; );</span><br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(<span class="hljs-string">&quot;io-app2/src/ps.txt&quot;</span>); <span class="hljs-comment">// 打印功能上与PrintStream的使用没有区别</span><br><br>        ps.println(<span class="hljs-number">97</span>);<br>        ps.println(<span class="hljs-string">&#x27;a&#x27;</span>);<br>        ps.println(<span class="hljs-number">23.3</span>);<br>        ps.println(<span class="hljs-literal">true</span>);<br>        ps.println(<span class="hljs-string">&quot;我是打印流输出的，我是啥就打印啥&quot;</span>);<br><br>        ps.close();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：了解改变输出语句的位置到文件</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;锦瑟无端五十弦&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;一弦一柱思华年&quot;</span>);<br><br>        <span class="hljs-comment">// 改变输出语句的位置（重定向）</span><br>        <span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(<span class="hljs-string">&quot;io-app2/src/log.txt&quot;</span>);<br>        System.setOut(ps); <span class="hljs-comment">// 把系统打印流改成我们自己的打印流</span><br><br>        System.out.println(<span class="hljs-string">&quot;庄生晓梦迷蝴蝶&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;望帝春心托杜鹃&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>1.打印流有几种？各有什么特点？</p><p><strong>打印流一般是指：PrintStream，PrintWriter两个类。</strong></p><p><strong>打印功能2者是一样的使用方式</strong></p><p><strong>PrintStream继承自字节输出流OutputStream，支持写字节</strong></p><p><strong>PrintWrite继承自字符输出流Writer，支持写字符</strong></p><p>2.打印流的优势是什么？</p><p><strong>两者在打印功能上都是使用方便，性能高效（核心优势）</strong></p><h6 id="补充知识Properties"><a href="#补充知识Properties" class="headerlink" title="补充知识Properties"></a>补充知识Properties</h6><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220429104602782.png" alt="image-20220429104602782"></p><p><strong>Properties属性集对象</strong></p><p>​    其实就是一个Map集合，但是我们一般不会当集合使用，因为HashMap更好用。</p><p><strong>Properties核心作用：</strong></p><p>​    Properties代表的是一个属性文件，可以把自己对象中的键值对信息存入到一个属性文件中去。</p><p>​    属性文件：后缀是.properties结尾的文件,里面的内容都是 key=value，后续做系统配置信息的。</p><p>1.Properties的作用？</p><p><strong>可以存储Properties属性集的键值对数据到属性文件中去：</strong></p><p>​    <strong>void store(Writer writer, String comments)</strong></p><p><strong>可以加载属性文件中的数据到Properties对象中来：</strong></p><p>​    <strong>void load(Reader reader)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：Properties的概述和使用(框架底层使用，了解这个技术即可)（保存数据到属性文件）</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Properties: 属性集对象。</span><br><span class="hljs-comment">         其实就是一个Map集合。也就是一个键值对集合，但是我们一般不会当集合使用，</span><br><span class="hljs-comment">         因为有HashMap。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Properties核心作用：</span><br><span class="hljs-comment">         Properties代表的是一个属性文件，可以把键值对的数据存入到一个属性文件中去。</span><br><span class="hljs-comment">         属性文件：后缀是.properties结尾的文件,里面的内容都是 key=value。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    大家在后期学的很多大型框架技术中，属性文件都是很重要的系统配置文件。</span><br><span class="hljs-comment">        users.properties</span><br><span class="hljs-comment">                admin=123456</span><br><span class="hljs-comment">                dlei=dlei</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     需求：使用Properties对象生成一个属性文件，里面存入用户名和密码信息。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     Properties的方法：</span><br><span class="hljs-comment">         -- public Object setProperty(String key, String value) ： 保存一对属性。  (put)</span><br><span class="hljs-comment">         -- public String getProperty(String key) : 使用此属性列表中指定的键搜索属性值 (get)</span><br><span class="hljs-comment">         -- public Set&lt;String&gt; stringPropertyNames() : 所有键的名称的集合  (keySet())</span><br><span class="hljs-comment">         -- public void store(OutputStream out, String comments): 保存数据到属性文件中去</span><br><span class="hljs-comment">         -- public void store(Writer fw, String comments): 保存数据到属性文件中去</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     小结：</span><br><span class="hljs-comment">            Properties可以保存键值对数据到属性文件</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PropertiesDemo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 需求：使用Properties把键值对信息存入到属性文件中去。</span><br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        properties.setProperty(<span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>);<br>        properties.setProperty(<span class="hljs-string">&quot;dlei&quot;</span>, <span class="hljs-string">&quot;003197&quot;</span>);<br>        properties.setProperty(<span class="hljs-string">&quot;heima&quot;</span>, <span class="hljs-string">&quot;itcast&quot;</span>);<br>        System.out.println(properties);<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">           参数一：保存管道 字符输出流管道</span><br><span class="hljs-comment">           参数二：保存心得</span><br><span class="hljs-comment">         */</span><br>        properties.store(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;io-app2/src/users.properties&quot;</span>)<br>                , <span class="hljs-string">&quot;this is users!! i am very happy! give me 100!&quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：Properties读取属性文件中的键值对信息。（读取）</span><br><span class="hljs-comment">    Properties的方法：</span><br><span class="hljs-comment">        -- public Object setProperty(String key, String value) ： 保存一对属性。</span><br><span class="hljs-comment">        -- public String getProperty(String key) ：使用此属性列表中指定的键搜索属性值</span><br><span class="hljs-comment">        -- public Set&lt;String&gt; stringPropertyNames() ：所有键的名称的集合</span><br><span class="hljs-comment">        -- public void store(OutputStream out, String comments):保存数据到属性文件中去</span><br><span class="hljs-comment">        -- public synchronized void load(InputStream inStream):加载属性文件的数据到属性集对象中去</span><br><span class="hljs-comment">        -- public synchronized void load(Reader fr):加载属性文件的数据到属性集对象中去</span><br><span class="hljs-comment">    小结：</span><br><span class="hljs-comment">        属性集对象可以加载读取属性文件中的数据!!</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PropertiesDemo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 需求：Properties读取属性文件中的键值对信息。（读取）</span><br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        System.out.println(properties);<br><br>        <span class="hljs-comment">// 加载属性文件中的键值对数据到属性对象properties中去</span><br>        properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;io-app2/src/users.properties&quot;</span>));<br><br>        System.out.println(properties);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;dlei&quot;</span>);<br>        System.out.println(rs);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">rs1</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;admin&quot;</span>);<br>        System.out.println(rs1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>void load(InputStream inStream)</td><td>从输入字节流读取属性列表（键和元素对）</td></tr><tr><td>void  load(Reader reader)</td><td>从输入字符流读取属性列表（键和元素对）</td></tr><tr><td>void store(OutputStream out,  String comments)</td><td>将此属性列表（键和元素对）写入此  Properties表中，以适合于使用 load(InputStream)方法的格式写入输出字节流</td></tr><tr><td>void  store(Writer writer, String comments)</td><td>将此属性列表（键和元素对）写入此  Properties表中，以适合使用 load(Reader)方法的格式写入输出字符流</td></tr><tr><td>public Object setProperty(String  key, String value)</td><td>保存键值对（put）</td></tr><tr><td>public String getProperty(String  key)</td><td>使用此属性列表中指定的键搜索属性值  (get)</td></tr><tr><td>public Set<String> stringPropertyNames()</td><td>所有键的名称的集合 (keySet())</td></tr></tbody></table><h4 id="IO框架：commons-io"><a href="#IO框架：commons-io" class="headerlink" title="IO框架：commons-io"></a>IO框架：commons-io</h4><p><strong>commons-io概述</strong></p><ul><li><p>commons-io是apache开源基金组织提供的一组有关IO操作的类库，可以提高IO功能开发的效率。</p></li><li><p>commons-io工具包提供了很多有关io操作的类。有两个主要的类FileUtils, IOUtils</p></li></ul><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>String  readFileToString(File  file, String encoding)</td><td>读取文件中的数据, 返回字符串</td></tr><tr><td>void  copyFile(File  srcFile, File destFile)</td><td>复制文件。</td></tr><tr><td>void  copyDirectoryToDirectory(File  srcDir,  File destDir)</td><td>复制文件夹。</td></tr></tbody></table><p>导入commons-io-2.6.jar做开发</p><p><strong>需求</strong></p><p>使用commons-io简化io流读写</p><p><strong>分析</strong></p><p>①在项目中创建一个文件夹：lib</p><p>②将commons-io-2.6.jar文件复制到lib文件夹</p><p>③在jar文件上点右键，选择 Add as Library -&gt; 点击OK</p><p>④在类中导包使用</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h4 id="线程创建方式"><a href="#线程创建方式" class="headerlink" title="线程创建方式"></a>线程创建方式</h4><h6 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a><strong>Thread类</strong></h6><p>Java是通过java.lang.Thread 类来代表线程的。 </p><p>按照面向对象的思想，Thread类应该提供了实现多线程的方式。</p><h6 id="多线程的实现方案一：继承Thread类"><a href="#多线程的实现方案一：继承Thread类" class="headerlink" title="多线程的实现方案一：继承Thread类"></a><strong>多线程的实现方案一：继承Thread类</strong></h6><p>①定义一个子类MyThread继承线程类java.lang.Thread，重写run()方法</p><p>②创建MyThread类的对象</p><p>③调用线程对象的start()方法启动线程（启动后还是执行run方法的）</p><p><strong>1.为什么不直接调用了run方法，而是调用start启动线程?</strong></p><ul><li><p>直接调用run方法会当成普通方法执行，此时相当于还是单线程执行。</p></li><li><p>只有调用start方法才是启动一个新的线程执行。</p></li></ul><p><strong>2、把主线程任务放在子线程之前了。</strong></p><ul><li>这样主线程一直是先跑完的，相当于是一个单线程的效果了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   目标：多线程的创建方式一：继承Thread类实现。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 3、new一个新线程对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        <span class="hljs-comment">// 4、调用start方法启动线程（执行的还是run方法）</span><br>        t.start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;主线程执行输出：&quot;</span> + i);<br>        &#125;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">   1、定义一个线程类继承Thread类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">       2、重写run方法，里面是定义线程以后要干啥</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;子线程执行输出：&quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>方式一优缺点：</strong></p><p>优点：编码简单</p><p>缺点：线程类已经继承Thread，无法继承其他类，不利于扩展。</p><h6 id="多线程的实现方案二：实现Runnable口"><a href="#多线程的实现方案二：实现Runnable口" class="headerlink" title="多线程的实现方案二：实现Runnable口"></a><strong>多线程的实现方案二：实现Runnable口</strong></h6><p>①定义一个线程任务类MyRunnable实现Runnable接口，重写run()方法</p><p>②创建MyRunnable任务对象</p><p>③把MyRunnable任务对象交给Thread处理。</p><p>④调用线程对象的start()方法启动线程</p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public Thread(String name)</td><td>可以为当前线程指定名称</td></tr><tr><td>public Thread(Runnable target)</td><td>封装Runnable对象成为线程对象</td></tr><tr><td>public Thread(Runnable target ，String name )</td><td>封装Runnable对象成为线程对象，并指定线程名称</td></tr></tbody></table><p><strong>方式二优缺点：</strong></p><p>优点：线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强。</p><p>缺点：编程多一层对象包装，如果线程有执行结果是不可以直接返回的</p><h6 id="多线程的实现方案三：利用Callable、FutureTask接口实现。"><a href="#多线程的实现方案三：利用Callable、FutureTask接口实现。" class="headerlink" title="多线程的实现方案三：利用Callable、FutureTask接口实现。"></a><strong>多线程的实现方案三：利用Callable、FutureTask接口实现。</strong></h6><p>①、得到任务对象</p><p>​    1.定义类实现Callable接口，重写call方法，封装要做的事情。</p><p>​    2.用FutureTask把Callable对象封装成线程任务对象。</p><p>②、把线程任务对象交给Thread处理。</p><p>③、调用Thread的start方法启动线程，执行任务</p><p>④、线程执行完毕后、通过FutureTask的get方法去获取任务执行的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   目标：学会线程的创建方式三：实现Callable接口，结合FutureTask完成。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 3、创建Callable任务对象</span><br>        Callable&lt;String&gt; call = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">100</span>);<br>        <span class="hljs-comment">// 4、把Callable任务对象 交给 FutureTask 对象</span><br>        <span class="hljs-comment">//  FutureTask对象的作用1： 是Runnable的对象（实现了Runnable接口），可以交给Thread了</span><br>        <span class="hljs-comment">//  FutureTask对象的作用2： 可以在线程执行完毕之后通过调用其get方法得到线程执行完成的结果</span><br>        FutureTask&lt;String&gt; f1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(call);<br>        <span class="hljs-comment">// 5、交给线程处理</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(f1);<br>        <span class="hljs-comment">// 6、启动线程</span><br>        t1.start();<br><br><br>        Callable&lt;String&gt; call2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">200</span>);<br>        FutureTask&lt;String&gt; f2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(call2);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(f2);<br>        t2.start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 如果f1任务没有执行完毕，这里的代码会等待，直到线程1跑完才提取结果。</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">rs1</span> <span class="hljs-operator">=</span> f1.get();<br>            System.out.println(<span class="hljs-string">&quot;第一个结果：&quot;</span> + rs1);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 如果f2任务没有执行完毕，这里的代码会等待，直到线程2跑完才提取结果。</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">rs2</span> <span class="hljs-operator">=</span> f2.get();<br>            System.out.println(<span class="hljs-string">&quot;第二个结果：&quot;</span> + rs2);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    1、定义一个任务类 实现Callable接口  应该申明线程任务执行完毕后的结果的数据类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt;&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyCallable</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">       2、重写call方法（任务方法）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n ; i++) &#123;<br>            sum += i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;子线程执行的结果是：&quot;</span> + sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public FutureTask&lt;&gt;(Callable call)</td><td>把Callable对象封装成FutureTask对象。</td></tr><tr><td>public V get() throws Exception</td><td>获取线程执行call方法返回的结果。</td></tr></tbody></table><p><strong>方式三优缺点：</strong></p><p>优点：线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强。</p><p>可以在线程执行完毕后去获取线程执行的结果。</p><p>缺点：编码复杂一点。</p><h6 id="三种方法对比"><a href="#三种方法对比" class="headerlink" title="三种方法对比"></a>三种方法对比</h6><table><thead><tr><th>方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>继承Thread类</td><td>编程比较简单，可以直接使用Thread类中的方法</td><td>扩展性较差，不能再继承其他的类，不能返回线程执行的结果</td></tr><tr><td>实现Runnable接口</td><td>扩展性强，实现该接口的同时还可以继承其他的类。</td><td>编程相对复杂，不能返回线程执行的结果</td></tr><tr><td>实现Callable接口</td><td>扩展性强，实现该接口的同时还可以继承其他的类。可以得到线程执行的结果</td><td>编程相对复杂</td></tr></tbody></table><h6 id="线程常用API"><a href="#线程常用API" class="headerlink" title="线程常用API"></a>线程常用API</h6><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>String  getName()</td><td>获取当前线程的名称，默认线程名称是Thread-索引</td></tr><tr><td>void  setName(String  name)</td><td>设置线程名称</td></tr><tr><td>public  static Thread currentThread()：</td><td>返回对当前正在执行的线程对象的引用</td></tr><tr><td>public  static void sleep(long time)</td><td>让线程休眠指定的时间，单位为毫秒。</td></tr><tr><td>public  void run()</td><td>线程任务方法</td></tr><tr><td>public  void start()</td><td>线程启动方法</td></tr></tbody></table><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public  Thread(String name)</td><td>可以为当前线程指定名称</td></tr><tr><td>public  Thread(Runnable target)</td><td>把Runnable对象交给线程对象</td></tr><tr><td>public  Thread(Runnable target ，String name )</td><td>把Runnable对象交给线程对象，并指定线程名称</td></tr></tbody></table><h6 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a><strong>线程安全问题</strong></h6><p>多个线程同时操作同一个共享资源的时候可能会出现业务安全问题，称为线程安全问题。</p><p>1.线程安全问题出现的原因？</p><p><strong>存在多线程并发</strong></p><p><strong>同时访问共享资源</strong></p><p><strong>存在修改共享资源</strong></p><h6 id="案例：家庭账户问题"><a href="#案例：家庭账户问题" class="headerlink" title="案例：家庭账户问题"></a>案例：家庭账户问题</h6><p>小明和小红是一对夫妻，他们有一个共同的账户，余额是10万元，模拟2人同时去取钱10万。</p><p><strong>分析：</strong></p><p>①：需要提供一个账户类，创建一个账户对象代表2个人的共享账户。</p><p>②：需要定义一个线程类，线程类可以处理账户对象。</p><p>③：创建2个线程对象，传入同一个账户对象。</p><p>④：启动2个线程，去同一个账户对象中取钱10万。</p><p>//银行亏十万</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br>    <span class="hljs-keyword">private</span> String cardId;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> money; <span class="hljs-comment">// 账户的余额</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Account</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Account</span><span class="hljs-params">(String cardId, <span class="hljs-type">double</span> money)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cardId = cardId;<br>        <span class="hljs-built_in">this</span>.money = money;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">       小明 小红</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawMoney</span><span class="hljs-params">(<span class="hljs-type">double</span> money)</span> &#123;<br>        <span class="hljs-comment">// 0、先获取是谁来取钱，线程的名字就是人名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>        <span class="hljs-comment">// 1、判断账户是否够钱</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.money &gt;= money)&#123;<br>            <span class="hljs-comment">// 2、取钱</span><br>            System.out.println(name + <span class="hljs-string">&quot;来取钱成功，吐出：&quot;</span> + money);<br>            <span class="hljs-comment">// 3、更新余额</span><br>            <span class="hljs-built_in">this</span>.money -= money;<br>            System.out.println(name + <span class="hljs-string">&quot;取钱后剩余：&quot;</span> + <span class="hljs-built_in">this</span>.money);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 4、余额不足</span><br>            System.out.println(name +<span class="hljs-string">&quot;来取钱，余额不足！&quot;</span>);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCardId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> cardId;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCardId</span><span class="hljs-params">(String cardId)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cardId = cardId;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getMoney</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> money;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMoney</span><span class="hljs-params">(<span class="hljs-type">double</span> money)</span> &#123;<br>        <span class="hljs-built_in">this</span>.money = money;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   取钱的线程类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DrawThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-comment">// 接收处理的账户对象</span><br>    <span class="hljs-keyword">private</span> Account acc;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DrawThread</span><span class="hljs-params">(Account acc,String name)</span>&#123;<br>        <span class="hljs-built_in">super</span>(name);<br>        <span class="hljs-built_in">this</span>.acc = acc;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 小明 小红：取钱</span><br>        acc.drawMoney(<span class="hljs-number">100000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    需求：模拟取钱案例。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1、定义线程类，创建一个共享的账户对象</span><br>        <span class="hljs-type">Account</span> <span class="hljs-variable">acc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Account</span>(<span class="hljs-string">&quot;ICBC-111&quot;</span>, <span class="hljs-number">100000</span>);<br><br>        <span class="hljs-comment">// 2、创建2个线程对象，代表小明和小红同时进来了。</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">DrawThread</span>(acc, <span class="hljs-string">&quot;小明&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">DrawThread</span>(acc, <span class="hljs-string">&quot;小红&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h6><p><strong>同步代码块</strong></p><p>作用：把出现线程安全问题的核心代码给上锁。</p><p>原理：每次只能一个线程进入，执行完毕后自动解锁，其他线程才可以进来执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(同步锁对象) &#123;<br>  操作共享资源的代码(核心代码)<br> &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">      小明 小红</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawMoney</span><span class="hljs-params">(<span class="hljs-type">double</span> money)</span> &#123;<br>        <span class="hljs-comment">// 1、拿到是谁来取钱</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>        <span class="hljs-comment">// 同步代码块</span><br>        <span class="hljs-comment">// 小明 小红</span><br>        <span class="hljs-comment">// this == acc 共享账户</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-comment">// 2、判断余额是否足够</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.money &gt;= money)&#123;<br>                <span class="hljs-comment">// 钱够了</span><br>                System.out.println(name+<span class="hljs-string">&quot;来取钱，吐出：&quot;</span> + money);<br>                <span class="hljs-comment">// 更新余额</span><br>                <span class="hljs-built_in">this</span>.money -= money;<br>                System.out.println(name+<span class="hljs-string">&quot;取钱后，余额剩余：&quot;</span> + <span class="hljs-built_in">this</span>.money);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 3、余额不足</span><br>                System.out.println(name+<span class="hljs-string">&quot;来取钱，余额不足！&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>锁对象的规范要求</strong></p><p>规范上：建议使用共享资源作为锁对象。</p><p>对于实例方法建议使用this作为锁对象。</p><p>对于静态方法建议使用字节码（类名.class）对象作为锁对象。</p><h6 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a><strong>同步方法</strong></h6><p>作用：把出现线程安全问题的核心方法给上锁。</p><p>原理：每次只能一个线程进入，执行完毕以后自动解锁，其他线程才可以进来执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-keyword">synchronized</span> 返回值类型 方法名称(形参列表) &#123;<br>    操作共享资源的代码<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">      小明 小红</span><br><span class="hljs-comment">       this == acc</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawMoney</span><span class="hljs-params">(<span class="hljs-type">double</span> money)</span> &#123;<br>        <span class="hljs-comment">// 1、拿到是谁来取钱</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>        <span class="hljs-comment">// 2、判断余额是否足够</span><br>        <span class="hljs-comment">// 小明  小红</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.money &gt;= money)&#123;<br>            <span class="hljs-comment">// 钱够了</span><br>            System.out.println(name+<span class="hljs-string">&quot;来取钱，吐出：&quot;</span> + money);<br>            <span class="hljs-comment">// 更新余额</span><br>            <span class="hljs-built_in">this</span>.money -= money;<br>            System.out.println(name+<span class="hljs-string">&quot;取钱后，余额剩余：&quot;</span> + <span class="hljs-built_in">this</span>.money);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 3、余额不足</span><br>            System.out.println(name+<span class="hljs-string">&quot;来取钱，余额不足！&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>同步方法底层原理</strong></p><ul><li><p>同步方法其实底层也是有隐式锁对象的，只是锁的范围是整个方法代码。</p></li><li><p>如果方法是实例方法：同步方法默认用this作为的锁对象。但是代码要高度面向对象！</p></li><li><p>如果方法是静态方法：同步方法默认用类名.class作为的锁对象。</p></li></ul><h6 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a><strong>Lock锁</strong></h6><ul><li><p>为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock，更加灵活、方便。</p></li><li><p>Lock实现提供比使用synchronized方法和语句可以获得更广泛的锁定操作。</p></li><li><p>Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来构建Lock锁对象。</p></li></ul><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public ReentrantLock()</td><td>获得Lock锁的实现类对象</td></tr></tbody></table><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>void lock()</td><td>获得锁</td></tr><tr><td>void  unlock()</td><td>释放锁</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// final修饰后：锁对象是唯一和不可替换的，非常专业</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     小明 小红</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawMoney</span><span class="hljs-params">(<span class="hljs-type">double</span> money)</span> &#123;<br>       <span class="hljs-comment">// 1、拿到是谁来取钱</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>       <span class="hljs-comment">// 2、判断余额是否足够</span><br>       <span class="hljs-comment">// 小明  小红</span><br>       lock.lock(); <span class="hljs-comment">// 上锁</span><br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.money &gt;= money)&#123;<br>               <span class="hljs-comment">// 钱够了</span><br>               System.out.println(name+<span class="hljs-string">&quot;来取钱，吐出：&quot;</span> + money);<br>               <span class="hljs-comment">// 更新余额</span><br>               <span class="hljs-built_in">this</span>.money -= money;<br>               System.out.println(name+<span class="hljs-string">&quot;取钱后，余额剩余：&quot;</span> + <span class="hljs-built_in">this</span>.money);<br>           &#125;<span class="hljs-keyword">else</span>&#123;<br>               <span class="hljs-comment">// 3、余额不足</span><br>               System.out.println(name+<span class="hljs-string">&quot;来取钱，余额不足！&quot;</span>);<br>           &#125;<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>           lock.unlock(); <span class="hljs-comment">// 解锁</span><br>       &#125;<br><br>   &#125;<br></code></pre></td></tr></table></figure><h6 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h6><p><strong>什么是线程通信、如何实现？</strong></p><p>所谓线程通信就是线程间相互发送数据，线程间共享一个资源即可实现线程通信。</p><p><strong>线程通信常见形式</strong></p><p>通过共享一个数据的方式实现。</p><p>根据共享数据的情况决定自己该怎么做，以及通知其他线程怎么做。</p><p><strong>线程通信实际应用场景</strong></p><ul><li><p>生产者与消费者模型：生产者线程负责生产数据，消费者线程负责消费生产者产生的数据。</p></li><li><p>要求：生产者线程生产完数据后唤醒消费者，然后等待自己，消费者消费完该数据后唤醒生产者，然后等待自己。</p></li></ul><h6 id="线程通信案例模拟"><a href="#线程通信案例模拟" class="headerlink" title="线程通信案例模拟"></a><strong>线程通信案例模拟</strong></h6><p>模拟客服系统，系统可以不断的接入电话 和 分发给客服。</p><p>线程通信的前提：线程通信通常是在多个线程操作同一个共享资源的时候需要进行通信，且要保证线程安全。</p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>void  wait()</td><td>让当前线程等待并释放所占锁，直到另一个线程调用notify()方法或 notifyAll()方法</td></tr><tr><td>void  notify()</td><td>唤醒正在等待的单个线程</td></tr><tr><td>void notifyAll()</td><td>唤醒正在等待的所有线程</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">打电话线程</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 不断的打入电话</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            CallSystem.call();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">   接电话线程类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReceiveThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 1号  2号</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            CallSystem.receive();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">测试</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1、生产者线程：负责不断接收打进来的电话</span><br>        <span class="hljs-type">CallThread</span> <span class="hljs-variable">call</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CallThread</span>();<br>        call.start();<br><br>        <span class="hljs-comment">// 2、消费者线程：客服，每个客服每次接听一个电话</span><br>        <span class="hljs-type">ReceiveThread</span> <span class="hljs-variable">r1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReceiveThread</span>();<br>        r1.start();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">   呼叫系统。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallSystem</span> &#123;<br>    <span class="hljs-comment">// 定义一个变量记录当前呼入进来的电话。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 最多只接听一个。</span><br><br>    <span class="hljs-comment">/* 接入电话</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            number++;<br>            System.out.println(<span class="hljs-string">&quot;成功接入一个用户，等待分发~~~~&quot;</span>);<br><br>            <span class="hljs-comment">// 唤醒别人 : 1个</span><br>            CallSystem.class.notify();<br>            <span class="hljs-comment">// 让当前线程对象进入等待状态。</span><br>            CallSystem.class.wait();<br><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">       分发电话</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receive</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>            <span class="hljs-keyword">if</span>(number == <span class="hljs-number">1</span>)&#123;<br>                System.out.println(name + <span class="hljs-string">&quot;此电话已经分发给客服并接听完毕了~~~~~&quot;</span>);<br>                number--;<br>                <span class="hljs-comment">// 唤醒别人 : 1个</span><br>                CallSystem.class.notify();<br>                CallSystem.class.wait(); <span class="hljs-comment">// 让当前线程等待</span><br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 唤醒别人 : 1个</span><br>                CallSystem.class.notify();<br>                CallSystem.class.wait(); <span class="hljs-comment">// 让当前线程等待</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h6><p>线程池就是一个可以复用线程的技术。</p><p><strong>不使用线程池的问题</strong> </p><p>如果用户每发起一个请求，后台就创建一个新线程来处理，下次新任务来了又要创建新线程，而创建新线程的开销是很大的，这样会严重影响系统的性能。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220429161856082.png" alt="image-20220429161856082"></p><p><strong>如何得到线程池对象</strong></p><p>方式一：使用ExecutorService的实现类ThreadPoolExecutor自创建一个线程池对象</p><p>方式二：使用Executors（线程池的工具类）调用方法返回不同特点的线程池对象</p><p><strong>ThreadPoolExecutor构造器的参数说明</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(</span><br><span class="hljs-params"><span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params"><span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params"><span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">TimeUnit unit,</span><br><span class="hljs-params">BlockingQueue&lt;Runnable&gt; workQueue,                          </span><br><span class="hljs-params">ThreadFactory threadFactory,                   RejectedExecutionHandler handler)</span> <br></code></pre></td></tr></table></figure><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220429162504314.png" alt="image-20220429162504314"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;输出了：HelloWorld ==&gt; &quot;</span>  + i);<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;本任务与线程绑定了，线程进入休眠了~~~&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">10000000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：自定义一个线程池对象，并测试其特性。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1、创建线程池对象</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         public ThreadPoolExecutor(int corePoolSize,</span><br><span class="hljs-comment">                                 int maximumPoolSize,</span><br><span class="hljs-comment">                                 long keepAliveTime,</span><br><span class="hljs-comment">                                 TimeUnit unit,</span><br><span class="hljs-comment">                                 BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-comment">                                 ThreadFactory threadFactory,</span><br><span class="hljs-comment">                                 RejectedExecutionHandler handler)</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5</span> ,<br>                <span class="hljs-number">6</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">5</span>) , Executors.defaultThreadFactory(),<br>               <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy() );<br><br>        <span class="hljs-comment">// 2、给任务线程池处理。</span><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br>        <span class="hljs-comment">//线程池工作线程</span><br>        pool.execute(target);<br>        pool.execute(target);<br>        pool.execute(target);<br><span class="hljs-comment">//线程队列</span><br>        pool.execute(target);<br>        pool.execute(target);<br>        pool.execute(target);<br>        pool.execute(target);<br>        pool.execute(target);<br><br>        <span class="hljs-comment">// 创建临时线程</span><br>        pool.execute(target);<br>        pool.execute(target);<br><span class="hljs-comment">//        // 不创建，拒绝策略被触发！！！</span><br><span class="hljs-comment">//        pool.execute(target);</span><br><br>        <span class="hljs-comment">// 关闭线程池（开发中一般不会使用）。</span><br>        <span class="hljs-comment">// pool.shutdownNow(); // 立即关闭，即使任务没有完成，会丢失任务的！</span><br>        pool.shutdown(); <span class="hljs-comment">// 会等待全部任务执行完毕之后再关闭（建议使用的）</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>void execute(Runnable command)</td><td>执行任务/命令，没有返回值，一般用来执行  Runnable 任务</td></tr><tr><td>Future<T>  submit(Callable<T> task)</td><td>执行任务，返回未来任务对象获取线程结果，一般拿来执行  Callable 任务</td></tr><tr><td>void  shutdown()</td><td>等任务执行完毕后关闭线程池</td></tr><tr><td>List&lt;[Runnable]&gt;shutdownNow()</td><td>立刻关闭，停止正在执行的任务，并返回队列中未执行的任务</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：自定义一个线程池对象，并测试其特性。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1、创建线程池对象</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         public ThreadPoolExecutor(int corePoolSize,</span><br><span class="hljs-comment">                                 int maximumPoolSize,</span><br><span class="hljs-comment">                                 long keepAliveTime,</span><br><span class="hljs-comment">                                 TimeUnit unit,</span><br><span class="hljs-comment">                                 BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-comment">                                 ThreadFactory threadFactory,</span><br><span class="hljs-comment">                                 RejectedExecutionHandler handler)</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5</span> ,<br>                <span class="hljs-number">6</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">5</span>) , Executors.defaultThreadFactory(),<br>               <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy() );<br><br>        <span class="hljs-comment">// 2、给任务线程池处理。</span><br>        Future&lt;String&gt; f1 = pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">100</span>));<br>        Future&lt;String&gt; f2 = pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">200</span>));<br>        Future&lt;String&gt; f3 = pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">300</span>));<br>        Future&lt;String&gt; f4 = pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">400</span>));<br>        Future&lt;String&gt; f5 = pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">500</span>));<br><br><span class="hljs-comment">//        String rs = f1.get();</span><br><span class="hljs-comment">//        System.out.println(rs);</span><br><br>        System.out.println(f1.get());<br>        System.out.println(f2.get());<br>        System.out.println(f3.get());<br>        System.out.println(f4.get());<br>        System.out.println(f5.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="Executors得到线程池对象的常用方法"><a href="#Executors得到线程池对象的常用方法" class="headerlink" title="Executors得到线程池对象的常用方法"></a><strong>Executors得到线程池对象的常用方法</strong></h6><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public  static <a href="mk:@MSITStore:D:\course\jdk-11中文api修订版.CHM::/java.base/java/util/concurrent/ExecutorService.html">ExecutorService</a> newCachedThreadPool()</td><td>线程数量随着任务增加而增加，如果线程任务执行完毕且空闲了一段时间则会被回收掉。</td></tr><tr><td>public static <a href="mk:@MSITStore:D:\course\jdk-11中文api修订版.CHM::/java.base/java/util/concurrent/ExecutorService.html">ExecutorService</a> newFixedThreadPool(int nThreads)</td><td>创建固定线程数量的线程池，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程替代它。</td></tr><tr><td>public  static <a href="mk:@MSITStore:D:\course\jdk-11中文api修订版.CHM::/java.base/java/util/concurrent/ExecutorService.html">ExecutorService</a> newSingleThreadExecutor ()</td><td>创建只有一个线程的线程池对象，如果该线程出现异常而结束，那么线程池会补充一个新线程。</td></tr><tr><td>public  static <a href="mk:@MSITStore:D:\course\jdk-11中文api修订版.CHM::/java.base/java/util/concurrent/ScheduledExecutorService.html">ScheduledExecutorService</a> newScheduledThreadPool(int corePoolSize)</td><td>创建一个线程池，可以实现在给定的延迟后运行任务，或者定期执行任务。</td></tr></tbody></table><table><thead><tr><th>方法名称</th><th>存在问题</th></tr></thead><tbody><tr><td>public  static <a href="mk:@MSITStore:D:\course\jdk-11中文api修订版.CHM::/java.base/java/util/concurrent/ExecutorService.html">ExecutorService</a> newFixedThreadPool(int nThreads)</td><td>允许请求的任务队列长度是Integer.MAX_VALUE，可能出现OOM错误（ java.lang.OutOfMemoryError  ）</td></tr><tr><td>public  static <a href="mk:@MSITStore:D:\course\jdk-11中文api修订版.CHM::/java.base/java/util/concurrent/ExecutorService.html">ExecutorService</a> newSingleThreadExecutor()</td><td>同上</td></tr><tr><td>public  static <a href="mk:@MSITStore:D:\course\jdk-11中文api修订版.CHM::/java.base/java/util/concurrent/ExecutorService.html">ExecutorService</a> newCachedThreadPool()</td><td>创建的线程数量最大上限是Integer.MAX_VALUE，  线程数可能会随着任务1:1增长，也可能出现OOM错误（ java.lang.OutOfMemoryError  ）</td></tr><tr><td>public  static <a href="mk:@MSITStore:D:\course\jdk-11中文api修订版.CHM::/java.base/java/util/concurrent/ScheduledExecutorService.html">ScheduledExecutorService</a> newScheduledThreadPool(int corePoolSize)</td><td>同上</td></tr></tbody></table><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220429165534998.png" alt="image-20220429165534998"></p><h6 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a><strong>定时器</strong></h6><p>定时器是一种控制任务延时调用，或者周期调用的技术。</p><p>作用：闹钟、定时邮件发送。</p><p><strong>定时器的实现方式</strong></p><p>方式一：Timer</p><p>方式二： ScheduledExecutorService</p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public  Timer()</td><td>创建Timer定时器对象</td></tr></tbody></table><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public void schedule(<a href="file:///D:/course/%E5%9F%BA%E7%A1%80%E9%98%B6%E6%AE%B5/API%E6%96%87%E6%A1%A3/docs/api/java.base/java/util/TimerTask.html">TimerTask</a> task,  long delay, long period)</td><td>开启一个定时器，按照计划处理TimerTask任务</td></tr></tbody></table><p><strong>Timer定时器的特点和存在的问题</strong></p><p>1、Timer是单线程，处理多个任务按照顺序执行，存在延时与设置定时器的时间有出入。</p><p>2、可能因为其中的某个任务的异常使Timer线程死掉，从而影响后续任务执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：Timer定时器的使用和了解。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TimerDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1、创建Timer定时器</span><br>        <span class="hljs-type">Timer</span> <span class="hljs-variable">timer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>();  <span class="hljs-comment">// 定时器本身就是一个单线程。</span><br>        <span class="hljs-comment">// 2、调用方法，处理定时任务</span><br>        timer.schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;执行AAA~~~&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br><span class="hljs-comment">//                try &#123;</span><br><span class="hljs-comment">//                    Thread.sleep(5000);</span><br><span class="hljs-comment">//                &#125; catch (InterruptedException e) &#123;</span><br><span class="hljs-comment">//                    e.printStackTrace();</span><br><span class="hljs-comment">//                &#125;</span><br>            &#125;<br>        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">2000</span>);<br><br>        timer.schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;执行BB~~~&quot;</span>+ <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>                System.out.println(<span class="hljs-number">10</span>/<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">2000</span>);<br><br>        timer.schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;执行CCC~~~&quot;</span>+ <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>            &#125;<br>        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">3000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="ScheduledExecutorService定时器"><a href="#ScheduledExecutorService定时器" class="headerlink" title="ScheduledExecutorService定时器"></a><strong>ScheduledExecutorService定时器</strong></h6><table><thead><tr><th>Executors的方法</th><th>说明</th></tr></thead><tbody><tr><td>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)</td><td>得到线程池对象</td></tr></tbody></table><table><thead><tr><th>ScheduledExecutorService的方法</th><th>说明</th></tr></thead><tbody><tr><td>public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period,                              TimeUnit unit)</td><td>周期调度方法</td></tr></tbody></table><p><strong>ScheduledExecutorService的优点</strong></p><p>1、基于线程池，某个任务的执行情况不会影响其他定时任务的执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：Timer定时器的使用和了解。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TimerDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1、创建ScheduledExecutorService线程池，做定时器</span><br>        <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">// 2、开启定时任务</span><br>        pool.scheduleAtFixedRate(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;执行输出：AAA  ==》 &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">100000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, TimeUnit.SECONDS);<br><br><br>        pool.scheduleAtFixedRate(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;执行输出：BBB  ==》 &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>                <span class="hljs-comment">//该线程挂了，其他线程不挂</span><br>                System.out.println(<span class="hljs-number">10</span> / <span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, TimeUnit.SECONDS);<br><br><br>        pool.scheduleAtFixedRate(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;执行输出：CCC  ==》 &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>            &#125;<br>        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, TimeUnit.SECONDS);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a><strong>并发与并行</strong></h6><p>正在运行的程序（软件）就是一个独立的进程， 线程是属于进程的，多个线程其实是并发与并行同时进行的。</p><p><strong>并发的理解：</strong></p><ul><li><p>CPU同时处理线程的数量有限。</p></li><li><p>CPU会轮询为系统的每个线程服务，由于CPU切换的速度很快，给我们的感觉这些线程在同时执行，这就是并发。</p></li></ul><p><strong>并行的理解：</strong></p><ul><li>在同一个时刻上，同时有多个线程在被CPU处理并执行。</li></ul><h6 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a><strong>线程的状态</strong></h6><ul><li><p>线程的状态：也就是线程从生到死的过程，以及中间经历的各种状态及状态转换。</p></li><li><p>理解线程的状态有利于提升并发编程的理解能力。</p></li></ul><table><thead><tr><th>NEW(新建)</th><th>解释</th></tr></thead><tbody><tr><td>NEW(新建)</td><td>线程刚被创建，但是并未启动。</td></tr><tr><td>Runnable(可运行)</td><td>线程已经调用了start()等待CPU调度</td></tr><tr><td>Blocked(锁阻塞)</td><td>线程在执行的时候未竞争到锁对象，则该线程进入Blocked状态；。</td></tr><tr><td>Waiting(无限等待)</td><td>一个线程进入Waiting状态，另一个线程调用notify或者notifyAll方法才能够唤醒</td></tr><tr><td>Timed Waiting(计时等待)</td><td>同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。带有超时参数的常用方法有Thread.sleep 、Object.wait。</td></tr><tr><td>Teminated(被终止)</td><td>因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。</td></tr></tbody></table><h4 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h4><p>常见的通信模式有如下2种形式：Client-Server(CS) 、Browser/Server(BS)</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220429174326693.png" alt="image-20220429174326693"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220429174340243.png" alt="image-20220429174340243"></p><h6 id="实现网络编程关键的三要素"><a href="#实现网络编程关键的三要素" class="headerlink" title="实现网络编程关键的三要素"></a><strong>实现网络编程关键的三要素</strong></h6><p><strong>IP地址</strong>：设备在网络中的地址，是唯一的标识。</p><p><strong>端口：</strong>应用程序在设备中唯一的标识。</p><p><strong>协议</strong>:  数据在网络中传输的规则，常见的协议有UDP协议和TCP协议。</p><p><strong>IP地址</strong></p><p>IPv6：128位（16个字节），号称可以为地球每一粒沙子编号。</p><p>IPv6分成8个整数，每个整数用四个十六进制位表示， 数之间用冒号（：）分开。</p><p><strong>IP地址形式：</strong></p><p>公网地址、和私有地址(局域网使用)。</p><p>192.168. 开头的就是常见的局域网地址，范围即为192.168.0.0–192.168.255.255，专门为组织机构内部使用。 </p><p><strong>IP常用命令：</strong></p><p>ipconfig：查看本机IP地址</p><p>ping IP地址：检查网络是否连通</p><p><strong>特殊IP地址</strong>：</p><p>本机IP: 127.0.0.1或者localhost：称为回送地址也可称本地回环地址，只会寻找当前所在本机。</p><h6 id="InetAddress-的使用"><a href="#InetAddress-的使用" class="headerlink" title="InetAddress 的使用"></a><strong>InetAddress</strong> <strong>的使用</strong></h6><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>public static <a href="mk:@MSITStore:D:\course\jdk-11中文api修订版.CHM::/java.base/java/net/InetAddress.html">InetAddress</a> getLocalHost()</td><td>返回本主机的地址对象</td></tr><tr><td>public static  InetAddress getByName(String host)</td><td>得到指定主机的IP地址对象，参数是域名或者IP地址</td></tr><tr><td>public String  getHostName()</td><td>获取此IP地址的主机名</td></tr><tr><td>public String  getHostAddress()</td><td>返回IP地址字符串</td></tr><tr><td>public boolean isReachable(int timeout)</td><td>在指定毫秒内连通该IP地址对应的主机，连通返回true</td></tr></tbody></table><h6 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a><strong>端口号</strong></h6><p>l端口号：标识正在计算机设备上运行的进程（程序），被规定为一个 16 位的二进制，范围是 0~65535。</p><p><strong>端口类型</strong></p><p>周知端口：0~1023，被预先定义的知名应用占用（如：HTTP占用 80，FTP占用21） </p><p><strong>注册端口</strong>：1024~49151，分配给用户进程或某些应用程序。（如：Tomcat占 用8080，MySQL占用3306）</p><p>动态端口：49152到65535，之所以称为动态端口，是因为它 一般不固定分配某种进程，而是动态分配。</p><p><strong>注意：我们自己开发的程序选择注册端口，且一个设备中不能出现两个程序的端口号一样，否则出错。</strong></p><h6 id="网络通信协议有两套参考模型"><a href="#网络通信协议有两套参考模型" class="headerlink" title="网络通信协议有两套参考模型"></a><strong>网络通信协议有两套参考模型</strong></h6><ul><li><p>OSI参考模型：世界互联协议标准，全球通信规范，由于此模型过于理想化，未能在因特网上进行广泛推广。</p></li><li><p>TCP/IP参考模型(或TCP/IP协议)：事实上的国际标准。</p></li></ul><table><thead><tr><th>OSI参考模型</th><th>TCP/IP参考模型</th><th>各层对应</th><th>面向操作</th></tr></thead><tbody><tr><td>应用层</td><td>应用层</td><td>HTTP、FTP、DNS、SMTP…</td><td>应用程序需要关注的：浏览器，邮箱。程序员一般在这一层开发</td></tr><tr><td>表示层</td><td></td><td></td><td></td></tr><tr><td>会话层</td><td></td><td></td><td></td></tr><tr><td>传输层</td><td>传输层</td><td>TCP、UDP…</td><td>选择使用的TCP , UDP协议</td></tr><tr><td>网络层</td><td>网络层</td><td>IP、ICMP…</td><td>封装源和目标IP，进行路径选择</td></tr><tr><td>数据链路层</td><td>数据链路层+物理</td><td>物理寻址、比特流…</td><td>物理设备中传输</td></tr><tr><td>物理层</td><td></td><td></td><td></td></tr></tbody></table><p><strong>TCP协议特点</strong></p><ul><li><p>使用TCP协议，必须双方先建立连接，它是一种面向连接的可靠通信协议。</p></li><li><p>传输前，采用“三次握手”方式建立连接，所以是可靠的 。</p></li><li><p>在连接中可进行大数据量的传输 。</p></li><li><p>连接、发送数据都需要确认，且传输完毕后，还需释放已建立的连接，通信效率较低。 </p></li></ul><p><strong>TCP协议通信场景</strong></p><ul><li>对信息安全要求较高的场景，例如：文件下载、金融等数据通信。</li></ul><p><strong>UDP协议：</strong> </p><ul><li><p>UDP是一种无连接、不可靠传输的协议。</p></li><li><p>将数据源IP、目的地IP和端口封装成数据包，不需要建立连接</p></li><li><p>每个数据包的大小限制在64KB内</p></li><li><p>发送不管对方是否准备好，接收方收到也不确认，故是不可靠的 </p></li><li><p>可以广播发送 ，发送数据结束时无需释放资源，开销小，速度快。</p></li></ul><p><strong>UDP协议通信场景</strong></p><ul><li>语音通话，视频会话等。</li></ul><h6 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h6><p><strong>DatagramPacket：数据包对象（韭菜盘子）</strong></p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public DatagramPacket(byte[] buf, int  length, InetAddress address,  int port)</td><td>创建发送端数据包对象  buf：要发送的内容，字节数组  length：要发送内容的字节长度  address：接收端的IP地址对象  port：接收端的端口号</td></tr><tr><td>public DatagramPacket(byte[] buf, int  length)</td><td>创建接收端的数据包对象  buf：用来存储接收的内容  length：能够接收内容的长度</td></tr></tbody></table><p><strong>DatagramSocket类成员方法</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public void send(DatagramPacket dp)</td><td>发送数据包</td></tr><tr><td>public void receive(DatagramPacket p)</td><td>接收数据包</td></tr></tbody></table><p>需求：客户端实现步骤</p><p>①创建DatagramSocket对象（发送端对象）           扔韭菜的人</p><p>②创建DatagramPacket对象封装需要发送的数据（数据包对象）        韭菜盘子</p><p>③使用DatagramSocket对象的send方法传入DatagramPacket对象         开始抛出韭菜</p><p>④释放资源</p><p>需求：接收端实现步骤</p><p>①创建DatagramSocket对象并指定端口（接收端对象）           接韭菜的人</p><p>②创建DatagramPacket对象接收数据（数据包对象）         韭菜盘子</p><p>③使用DatagramSocket对象的receive方法传入DatagramPacket对象         开始接收韭菜</p><p>④释放资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  发送端  一发 一收</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;=====客户端启动======&quot;</span>);<br><br>        <span class="hljs-comment">// 1、创建发送端对象：发送端自带默认的端口号（人）</span><br>        <span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(<span class="hljs-number">6666</span>);<br><br>        <span class="hljs-comment">// 2、创建一个数据包对象封装数据（韭菜盘子）</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         public DatagramPacket(byte buf[], int length,</span><br><span class="hljs-comment">         InetAddress address, int port)</span><br><span class="hljs-comment">         参数一：封装要发送的数据（韭菜）</span><br><span class="hljs-comment">         参数二：发送数据的大小</span><br><span class="hljs-comment">         参数三：服务端的主机IP地址</span><br><span class="hljs-comment">         参数四：服务端的端口</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-string">&quot;我是一颗快乐的韭菜，你愿意吃吗？&quot;</span>.getBytes();<br>        <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>( buffer, buffer.length,<br>                InetAddress.getLocalHost() , <span class="hljs-number">8888</span>);<br><br>        <span class="hljs-comment">// 3、发送数据出去</span><br>        socket.send(packet);<br><br>        socket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  接收端</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;=====服务端启动======&quot;</span>);<br>        <span class="hljs-comment">// 1、创建接收端对象：注册端口（人）</span><br>        <span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(<span class="hljs-number">8888</span>);<br><br>        <span class="hljs-comment">// 2、创建一个数据包对象接收数据（韭菜盘子）</span><br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">64</span>];<br>        <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buffer, buffer.length);<br><br>        <span class="hljs-comment">// 3、等待接收数据。</span><br>        socket.receive(packet);<br><br>        <span class="hljs-comment">// 4、取出数据即可</span><br>        <span class="hljs-comment">// 读取多少倒出多少</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> packet.getLength();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer,<span class="hljs-number">0</span>, len);<br>        System.out.println(<span class="hljs-string">&quot;收到了：&quot;</span> + rs);<br><br>        <span class="hljs-comment">// 获取发送端的ip和端口</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">ip</span>  <span class="hljs-operator">=</span>packet.getSocketAddress().toString();<br>        System.out.println(<span class="hljs-string">&quot;对方地址：&quot;</span> + ip);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">port</span>  <span class="hljs-operator">=</span> packet.getPort();<br>        System.out.println(<span class="hljs-string">&quot;对方端口：&quot;</span> + port);<br><br>        socket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="UDP的三种通信方式"><a href="#UDP的三种通信方式" class="headerlink" title="UDP的三种通信方式"></a><strong>UDP的三种通信方式</strong></h6><p>单播：单台主机与单台主机之间的通信。</p><p>广播：当前主机与所在网络中的所有主机通信。</p><p>组播：当前主机与选定的一组主机的通信。</p><h6 id="UDP如何实现广播"><a href="#UDP如何实现广播" class="headerlink" title="UDP如何实现广播"></a><strong>UDP如何实现广播</strong></h6><p>使用广播地址：255.255.255.255</p><p>具体操作：</p><p>①发送端发送的数据包的目的地写的是广播地址、且指定端口。 （255.255.255.255 ,  9999）</p><p>②本机所在网段的其他主机的程序只要注册对应端口就可以收到消息了。（9999）</p><h6 id="UDP如何实现组播"><a href="#UDP如何实现组播" class="headerlink" title="UDP如何实现组播"></a><strong>UDP如何实现组播</strong></h6><p>使用组播地址：224.0.0.0 ~ 239.255.255.255</p><p>具体操作：</p><p>①发送端的数据包的目的地是组播IP (例如：224.0.1.1, 端口：9999)</p><p>②接收端必须绑定该组播IP(224.0.1.1)，端口还要注册发送端的目的端口9999 ，这样即可接收该组播消息。</p><p>③DatagramSocket的子类MulticastSocket可以在接收端绑定组播IP。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">            <span class="hljs-comment">// 2、创建一个数据包对象封装数据（韭菜盘子）</span><br>            <span class="hljs-type">byte</span>[] buffer = msg.getBytes();<br>            <span class="hljs-comment">// 注意：只要目的地IP是 255.255.255.255 这个消息将以广播的形式对外发送</span><br><span class="hljs-comment">//            DatagramPacket packet = new DatagramPacket( buffer, buffer.length,</span><br><span class="hljs-comment">//                    InetAddress.getByName(&quot;255.255.255.255&quot;) , 8888);</span><br><br>            <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>( buffer, buffer.length,<br>                    InetAddress.getByName(<span class="hljs-string">&quot;224.0.1.1&quot;</span>) , <span class="hljs-number">9898</span>);<br><br>                    <span class="hljs-comment">// 3、发送数据出去</span><br>            socket.send(packet);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  接收端,广播</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;=====服务端启动======&quot;</span>);<br>        <span class="hljs-comment">// 1、创建接收端对象：注册端口（人）</span><br>        <span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(<span class="hljs-number">8888</span>);<br><br>        <span class="hljs-comment">// 2、创建一个数据包对象接收数据（韭菜盘子）</span><br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">64</span>];<br>        <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buffer, buffer.length);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 3、等待接收数据。</span><br>            socket.receive(packet);<br>            <span class="hljs-comment">// 4、取出数据即可</span><br>            <span class="hljs-comment">// 读取多少倒出多少</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> packet.getLength();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer,<span class="hljs-number">0</span>, len);<br>            System.out.println(<span class="hljs-string">&quot;收到了来自：&quot;</span> + packet.getAddress() +<span class="hljs-string">&quot;, 对方端口是&quot;</span> + packet.getPort() +<span class="hljs-string">&quot;的消息：&quot;</span> + rs);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  接收端，组播</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerDemo3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;=====服务端启动======&quot;</span>);<br>        <span class="hljs-comment">// 1、创建接收端对象：注册端口（人）</span><br>        <span class="hljs-type">MulticastSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MulticastSocket</span>(<span class="hljs-number">9898</span>);<br><br>        <span class="hljs-comment">// 注意：绑定组播地址（加群）</span><br>        socket.joinGroup(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(InetAddress.getByName(<span class="hljs-string">&quot;224.0.1.1&quot;</span>) , <span class="hljs-number">9898</span>),<br>                NetworkInterface.getByInetAddress(InetAddress.getLocalHost()));<br><br>        <span class="hljs-comment">// 2、创建一个数据包对象接收数据（韭菜盘子）</span><br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">64</span>];<br>        <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buffer, buffer.length);<br><br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 3、等待接收数据。</span><br>            socket.receive(packet);<br>            <span class="hljs-comment">// 4、取出数据即可</span><br>            <span class="hljs-comment">// 读取多少倒出多少</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> packet.getLength();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer,<span class="hljs-number">0</span>, len);<br>            System.out.println(<span class="hljs-string">&quot;收到了来自：&quot;</span> + packet.getAddress() +<span class="hljs-string">&quot;, 对方端口是&quot;</span> + packet.getPort() +<span class="hljs-string">&quot;的消息：&quot;</span> + rs);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h6><ul><li><p>TCP是一种面向连接，安全、可靠的传输数据的协议 </p></li><li><p>传输前，采用“三次握手”方式，点对点通信，是可靠的 </p></li><li><p>在连接中可进行大数据量的传输 </p></li></ul><h6 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a><strong>Socket</strong></h6><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public Socket(String host , int port)</td><td>创建发送端的Socket对象与服务端连接，参数为服务端程序的ip和端口。</td></tr></tbody></table><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>OutputStream getOutputStream()</td><td>获得字节输出流对象</td></tr><tr><td>InputStream getInputStream()</td><td>获得字节输入流对象</td></tr></tbody></table><h6 id="客户端发送消息"><a href="#客户端发送消息" class="headerlink" title="客户端发送消息"></a>客户端发送消息</h6><p>需求：客户端实现步骤</p><p>①创建客户端的Socket对象，请求与服务端的连接。</p><p>②使用socket对象调用getOutputStream()方法得到字节输出流。</p><p>③使用字节输出流完成数据的发送。</p><p>④释放资源：关闭socket管道。</p><p><strong>ServerSocket(服务端)</strong></p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public ServerSocket(int port)</td><td>注册服务端端口</td></tr></tbody></table><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public Socket accept()</td><td>等待接收客户端的Socket通信连接  连接成功返回Socket对象与客户端建立端到端通信</td></tr></tbody></table><h6 id="服务端实现接收消息"><a href="#服务端实现接收消息" class="headerlink" title="服务端实现接收消息"></a>服务端实现接收消息</h6><p>需求：服务端实现步骤</p><p>①创建ServerSocket对象，注册服务端端口。</p><p>②调用ServerSocket对象的accept()方法，等待客户端的连接，并得到Socket管道对象。</p><p>③通过Socket对象调用getInputStream()方法得到字节输入流、完成数据的接收。</p><p>④释放资源：关闭socket管道</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   目标：完成Socket网络编程入门案例的客户端开发，实现1发1收。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;====客户端启动===&quot;</span>);<br>            <span class="hljs-comment">// 1、创建Socket通信管道请求有服务端的连接</span><br>            <span class="hljs-comment">// public Socket(String host, int port)</span><br>            <span class="hljs-comment">// 参数一：服务端的IP地址</span><br>            <span class="hljs-comment">// 参数二：服务端的端口</span><br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">7777</span>);<br><br>            <span class="hljs-comment">// 2、从socket通信管道中得到一个字节输出流 负责发送数据</span><br>            <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br><br>            <span class="hljs-comment">// 3、把低级的字节流包装成打印流</span><br>            <span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(os);<br><br>            <span class="hljs-comment">// 4、发送消息</span><br>            ps.println(<span class="hljs-string">&quot;我是TCP的客户端，我已经与你对接，并发出邀请：约吗？&quot;</span>);<br>            ps.flush();<br><br>            <span class="hljs-comment">// 关闭资源。</span><br>            <span class="hljs-comment">// socket.close();</span><br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   目标：开发Socket网络编程入门代码的服务端，实现接收消息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;===服务端启动成功===&quot;</span>);<br>            <span class="hljs-comment">// 1、注册端口</span><br>            <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">7777</span>);<br>            <span class="hljs-comment">// 2、必须调用accept方法：等待接收客户端的Socket连接请求，建立Socket通信管道</span><br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>            <span class="hljs-comment">// 3、从socket通信管道中得到一个字节输入流</span><br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>            <span class="hljs-comment">// 4、把字节输入流包装成缓冲字符输入流进行消息的接收</span><br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(is));<br>            <span class="hljs-comment">// 5、按照行读取消息</span><br>            String msg;<br>            <span class="hljs-keyword">if</span> ((msg = br.readLine()) != <span class="hljs-literal">null</span>)&#123;<br>                System.out.println(socket.getRemoteSocketAddress() + <span class="hljs-string">&quot;说了：: &quot;</span> + msg);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>1.TCP通信服务端用的代表类？</p><p><strong>ServerSocket类,注册端口。</strong></p><p><strong>调用accept()方法阻塞等待接收客户端连接。得到Socket对象。</strong></p><p>2.TCP通信的基本原理？</p><p><strong>客户端怎么发，服务端就应该怎么收。</strong></p><p><strong>客户端如果没有消息，服务端会进入阻塞等待。</strong></p><p><strong>Socket一方关闭或者出现异常、对方Socket也会失效或者出错。</strong></p><p>1、之前我们的通信是否可以同时与多个客户端通信，为什么？</p><p><strong>不可以的</strong></p><p><strong>单线程每次只能处理一个客户端的Socket通信</strong></p><p>2、如何才可以让服务端可以处理多个客户端的通信需求？</p><p><strong>引入多线程。</strong></p><h6 id="多发多收"><a href="#多发多收" class="headerlink" title="多发多收"></a>多发多收</h6><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220429203603902.png" alt="image-20220429203603902"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：实现服务端可以同时处理多个客户端的消息。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;====客户端启动===&quot;</span>);<br>            <span class="hljs-comment">// 1、创建Socket通信管道请求有服务端的连接</span><br>            <span class="hljs-comment">// public Socket(String host, int port)</span><br>            <span class="hljs-comment">// 参数一：服务端的IP地址</span><br>            <span class="hljs-comment">// 参数二：服务端的端口</span><br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">7777</span>);<br><br>            <span class="hljs-comment">// 2、从socket通信管道中得到一个字节输出流 负责发送数据</span><br>            <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br><br>            <span class="hljs-comment">// 3、把低级的字节流包装成打印流</span><br>            <span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(os);<br><br>            <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;请说：&quot;</span>);<br>                <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> sc.nextLine();<br>                <span class="hljs-comment">// 4、发送消息</span><br>                ps.println(msg);<br>                ps.flush();<br>            &#125;<br><br>            <span class="hljs-comment">// 关闭资源。</span><br>            <span class="hljs-comment">// socket.close();</span><br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   目标：实现服务端可以同时处理多个客户端的消息。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;===服务端启动成功===&quot;</span>);<br>            <span class="hljs-comment">// 1、注册端口</span><br>            <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">7777</span>);<br>            <span class="hljs-comment">// a.定义一个死循环由主线程负责不断的接收客户端的Socket管道连接。</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-comment">// 2、每接收到一个客户端的Socket管道，交给一个独立的子线程负责读取消息</span><br>                <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>                System.out.println(socket.getRemoteSocketAddress()+ <span class="hljs-string">&quot;它来了，上线了！&quot;</span>);<br>                <span class="hljs-comment">// 3、开始创建独立线程处理socket</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerReaderThread</span>(socket).start();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerReaderThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> Socket socket;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ServerReaderThread</span><span class="hljs-params">(Socket socket)</span>&#123;<br>        <span class="hljs-built_in">this</span>.socket = socket;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 3、从socket通信管道中得到一个字节输入流</span><br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>            <span class="hljs-comment">// 4、把字节输入流包装成缓冲字符输入流进行消息的接收</span><br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(is));<br>            <span class="hljs-comment">// 5、按照行读取消息</span><br>            String msg;<br>            <span class="hljs-keyword">while</span> ((msg = br.readLine()) != <span class="hljs-literal">null</span>)&#123;<br>                System.out.println(socket.getRemoteSocketAddress() + <span class="hljs-string">&quot;说了：: &quot;</span> + msg);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(socket.getRemoteSocketAddress() + <span class="hljs-string">&quot;下线了！！！&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="引入线程池"><a href="#引入线程池" class="headerlink" title="引入线程池"></a>引入线程池</h6><p>解决N:N资源耗尽问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    拓展：使用线程池优化：实现通信。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;====客户端启动===&quot;</span>);<br>            <span class="hljs-comment">// 1、创建Socket通信管道请求有服务端的连接</span><br>            <span class="hljs-comment">// public Socket(String host, int port)</span><br>            <span class="hljs-comment">// 参数一：服务端的IP地址</span><br>            <span class="hljs-comment">// 参数二：服务端的端口</span><br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6666</span>);<br><br>            <span class="hljs-comment">// 2、从socket通信管道中得到一个字节输出流 负责发送数据</span><br>            <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br><br>            <span class="hljs-comment">// 3、把低级的字节流包装成打印流</span><br>            <span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(os);<br><br>            <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;请说：&quot;</span>);<br>                <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> sc.nextLine();<br>                <span class="hljs-comment">// 4、发送消息</span><br>                ps.println(msg);<br>                ps.flush();<br>            &#125;<br>            <span class="hljs-comment">// 关闭资源。</span><br>            <span class="hljs-comment">// socket.close();</span><br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   目标：实现服务端可以同时处理多个客户端的消息。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerDemo2</span> &#123;<br><br>    <span class="hljs-comment">// 使用静态变量记住一个线程池对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">300</span>,<br>            <span class="hljs-number">1500</span>, <span class="hljs-number">6</span>, TimeUnit.SECONDS,<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">2</span>)<br>    , Executors.defaultThreadFactory(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy());<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;===服务端启动成功===&quot;</span>);<br>            <span class="hljs-comment">// 1、注册端口</span><br>            <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">6666</span>);<br>            <span class="hljs-comment">// a.定义一个死循环由主线程负责不断的接收客户端的Socket管道连接。</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-comment">// 2、每接收到一个客户端的Socket管道，</span><br>                <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>                System.out.println(socket.getRemoteSocketAddress()+ <span class="hljs-string">&quot;它来了，上线了！&quot;</span>);<br><br>                <span class="hljs-comment">// 任务对象负责读取消息。</span><br>                <span class="hljs-type">Runnable</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerReaderRunnable</span>(socket);<br>                pool.execute(target);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerReaderRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">private</span> Socket socket;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ServerReaderRunnable</span><span class="hljs-params">(Socket socket)</span>&#123;<br>        <span class="hljs-built_in">this</span>.socket = socket;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 3、从socket通信管道中得到一个字节输入流</span><br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>            <span class="hljs-comment">// 4、把字节输入流包装成缓冲字符输入流进行消息的接收</span><br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(is));<br>            <span class="hljs-comment">// 5、按照行读取消息</span><br>            String msg;<br>            <span class="hljs-keyword">while</span> ((msg = br.readLine()) != <span class="hljs-literal">null</span>)&#123;<br>                System.out.println(socket.getRemoteSocketAddress() + <span class="hljs-string">&quot;说了：: &quot;</span> + msg);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(socket.getRemoteSocketAddress() + <span class="hljs-string">&quot;下线了！！！&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="即时通信"><a href="#即时通信" class="headerlink" title="即时通信"></a>即时通信</h6><p><strong>即时通信，是指一个客户端的消息发出去，其他客户端可以接收到。</strong></p><p><strong>之前我们的消息都是发给服务端的。</strong></p><p><strong>即时通信需要进行端口转发的设计思想。</strong></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220430093310743.png" alt="image-20220430093310743"></p><p>1.即时通信是什么含义，要实现怎么样的设计？</p><p><strong>即时通信，是指一个客户端的消息发出去，其他客户端可以接收到</strong></p><p><strong>即时通信需要进行端口转发的设计思想。</strong></p><p><strong>服务端需要把在线的Socket管道存储起来</strong></p><p><strong>一旦收到一个消息要推送给其他管道</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    拓展：即时通信</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    客户端：发消息的同时，随时有人发消息过来。</span><br><span class="hljs-comment">    服务端：接收消息后，推送给其他所有的在线socket</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;====客户端启动===&quot;</span>);<br>            <span class="hljs-comment">// 1、创建Socket通信管道请求有服务端的连接</span><br>            <span class="hljs-comment">// public Socket(String host, int port)</span><br>            <span class="hljs-comment">// 参数一：服务端的IP地址</span><br>            <span class="hljs-comment">// 参数二：服务端的端口</span><br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6868</span>);<br><br>            <span class="hljs-comment">// 马上为客户端分配一个独立的线程负责读取它收到的消息</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientReaderThread</span>(socket).start();<br><br>            <span class="hljs-comment">// 2、从socket通信管道中得到一个字节输出流 负责发送数据</span><br>            <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br><br>            <span class="hljs-comment">// 3、把低级的字节流包装成打印流</span><br>            <span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(os);<br><br>            <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;请说：&quot;</span>);<br>                <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> sc.nextLine();<br>                <span class="hljs-comment">// 4、发送消息</span><br>                ps.println(msg);<br>                ps.flush();<br>            &#125;<br>            <span class="hljs-comment">// 关闭资源。</span><br>            <span class="hljs-comment">// socket.close();</span><br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientReaderThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> Socket socket;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ClientReaderThread</span><span class="hljs-params">(Socket socket)</span>&#123;<br>        <span class="hljs-built_in">this</span>.socket = socket;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 3、从socket通信管道中得到一个字节输入流</span><br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>            <span class="hljs-comment">// 4、把字节输入流包装成缓冲字符输入流进行消息的接收</span><br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(is));<br>            <span class="hljs-comment">// 5、按照行读取消息</span><br>            String msg;<br>            <span class="hljs-keyword">while</span> ((msg = br.readLine()) != <span class="hljs-literal">null</span>)&#123;<br>                System.out.println(socket.getRemoteSocketAddress() + <span class="hljs-string">&quot;收到了: &quot;</span> + msg);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;服务端把你踢出去了~~&quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   目标: 即时通信</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerDemo2</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Socket&gt; onLineSockets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;===服务端启动成功===&quot;</span>);<br>            <span class="hljs-comment">// 1、注册端口</span><br>            <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">6868</span>);<br>            <span class="hljs-comment">// a.定义一个死循环由主线程负责不断的接收客户端的Socket管道连接。</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-comment">// 2、每接收到一个客户端的Socket管道，交给一个独立的子线程负责读取消息</span><br>                <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>                System.out.println(socket.getRemoteSocketAddress()+ <span class="hljs-string">&quot;它来了，上线了！&quot;</span>);<br>                <span class="hljs-comment">// 把当前客户端管道Socket加入到在线集合中去</span><br>                onLineSockets.add(socket);<br><br>                <span class="hljs-comment">// 3、开始创建独立线程处理socket</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerReaderThread</span>(socket).start();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerReaderThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> Socket socket;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ServerReaderThread</span><span class="hljs-params">(Socket socket)</span>&#123;<br>        <span class="hljs-built_in">this</span>.socket = socket;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 3、从socket通信管道中得到一个字节输入流</span><br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>            <span class="hljs-comment">// 4、把字节输入流包装成缓冲字符输入流进行消息的接收</span><br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(is));<br>            <span class="hljs-comment">// 5、按照行读取消息</span><br>            String msg;<br>            <span class="hljs-keyword">while</span> ((msg = br.readLine()) != <span class="hljs-literal">null</span>)&#123;<br>                System.out.println(socket.getRemoteSocketAddress() + <span class="hljs-string">&quot;说了：: &quot;</span> + msg);<br>                <span class="hljs-comment">// 把这个消息发给当前所有在线socket</span><br>                sendMsgToAll(msg);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(socket.getRemoteSocketAddress() + <span class="hljs-string">&quot;下线了！！！&quot;</span>);<br>            <span class="hljs-comment">// 从在线集合中抹掉本客户端socket</span><br>            ServerDemo2.onLineSockets.remove(socket);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMsgToAll</span><span class="hljs-params">(String msg)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 遍历全部的在线 socket给他们发消息</span><br>            <span class="hljs-keyword">for</span> (Socket onLineSocket : ServerDemo2.onLineSockets) &#123;<br>                <span class="hljs-comment">// 除了自己的socket，其他socket我都发！！</span><br>                <span class="hljs-keyword">if</span>(onLineSocket != socket)&#123;<br>                    <span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(socket.getOutputStream());<br>                    ps.println(msg);<br>                    ps.flush();<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="BS开发"><a href="#BS开发" class="headerlink" title="BS开发"></a>BS开发</h6><p><strong>HTTP响应数据的协议格式：就是给浏览器显示的网页信息</strong></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220430094241610.png" alt="image-20220430094241610"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerReaderRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">private</span> Socket socket;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ServerReaderRunnable</span><span class="hljs-params">(Socket socket)</span>&#123;<br>        <span class="hljs-built_in">this</span>.socket = socket;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 浏览器 已经与本线程建立了Socket管道</span><br>            <span class="hljs-comment">// 响应消息给浏览器显示</span><br>            <span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(socket.getOutputStream());<br>            <span class="hljs-comment">// 必须响应HTTP协议格式数据，否则浏览器不认识消息</span><br>            ps.println(<span class="hljs-string">&quot;HTTP/1.1 200 OK&quot;</span>); <span class="hljs-comment">// 协议类型和版本 响应成功的消息！</span><br>            ps.println(<span class="hljs-string">&quot;Content-Type:text/html;charset=UTF-8&quot;</span>); <span class="hljs-comment">// 响应的数据类型：文本/网页</span><br><br>            ps.println(); <span class="hljs-comment">// 必须发送一个空行</span><br><br>            <span class="hljs-comment">// 才可以响应数据回去给浏览器</span><br>            ps.println(<span class="hljs-string">&quot;&lt;span style=&#x27;color:red;font-size:90px&#x27;&gt;《最牛的149期》 &lt;/span&gt;&quot;</span>);<br>            ps.close();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(socket.getRemoteSocketAddress() + <span class="hljs-string">&quot;下线了！！！&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java">**<br>    了解：BS-浏览器-服务器基本了解。<br><br>    引入：<br>        之前客户端和服务端都需要自己开发。也就是CS架构。<br>        接下来模拟一下BS架构。<br><br>    客户端：浏览器。（无需开发）<br>    服务端：自己开发。<br>    需求：在浏览器中请求本程序，响应一个网页文字给浏览器显示<br><br><br> */<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BSserverDemo</span> &#123;<br>    <span class="hljs-comment">// 使用静态变量记住一个线程池对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">3</span>,<br>            <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, TimeUnit.SECONDS,<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">2</span>)<br>            , Executors.defaultThreadFactory(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy());<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 1.注册端口</span><br>            <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">ss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8080</span>);<br>            <span class="hljs-comment">// 2.创建一个循环接收多个客户端的请求。</span><br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> ss.accept();<br>                <span class="hljs-comment">// 3.交给一个独立的线程来处理！</span><br>                pool.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerReaderRunnable</span>(socket));<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="单元测试、反射、注解、动态管理"><a href="#单元测试、反射、注解、动态管理" class="headerlink" title="单元测试、反射、注解、动态管理"></a>单元测试、反射、注解、动态管理</h4><h5 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h5><ul><li>单元测试就是针对最小的功能单元编写测试代码，Java程序最小的功能单元是方法，因此，单元测试就是针对Java方法的测试，进而检查方法的正确性。</li></ul><p><strong>目前测试方法是怎么进行的，存在什么问题</strong></p><ul><li><p>只有一个main方法，如果一个方法的测试失败了，其他方法测试会受到影响。</p></li><li><p>无法得到测试的结果报告，需要程序员自己去观察测试是否成功。</p></li><li><p>无法实现自动化测试。</p></li></ul><h6 id="Junit单元测试框架"><a href="#Junit单元测试框架" class="headerlink" title="Junit单元测试框架"></a><strong>Junit单元测试框架</strong></h6><ul><li><p>JUnit是使用Java语言实现的单元测试框架，它是开源的，Java开发者都应当学习并使用JUnit编写单元测试。</p></li><li><p>此外，几乎所有的IDE工具都集成了JUnit，这样我们就可以直接在IDE中编写并运行JUnit测试，JUnit目前最新版本是5。</p></li></ul><p><strong>JUnit优点</strong></p><ul><li><p>JUnit可以灵活的选择执行哪些测试方法，可以一键执行全部测试方法。</p></li><li><p>Junit可以生成全部方法的测试报告。</p></li><li><p>单元测试中的某个方法测试失败了，不会影响其他测试方法的测试。</p></li></ul><h6 id="单元测试快速入门"><a href="#单元测试快速入门" class="headerlink" title="单元测试快速入门"></a>单元测试快速入门</h6><p>需求：使用单元测试进行业务方法预期结果、正确性测试的快速入门</p><p>分析：</p><p>①将JUnit的jar包导入到项目中</p><p>​        IDEA通常整合好了Junit框架，一般不需要导入。</p><p>​        如果IDEA没有整合好，需要自己手工导入如下2个JUnit的jar包        到模块</p><p>②编写测试方法：该测试方法必须是公共的无参数无返回值的非静态方法。</p><p>③在测试方法上使用@Test注解：标注该方法是一个测试方法</p><p>④在测试方法中完成被测试方法的预期正确性测试。</p><p>⑤选中测试方法，选择“JUnit运行” ，如果测试良好则是绿色；如果测试失败，则是红色</p><p><strong>Junit常用注解(Junit 4.xxxx版本)</strong></p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Test</td><td>测试方法</td></tr><tr><td>@Before</td><td>用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。</td></tr><tr><td>@After</td><td>用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次。</td></tr><tr><td>@BeforeClass</td><td>用来静态修饰方法，该方法会在所有测试方法之前只执行一次。</td></tr><tr><td>@AfterClass</td><td>用来静态修饰方法，该方法会在所有测试方法之后只执行一次。</td></tr></tbody></table><p><strong>Junit常用注解(Junit 5.xxxx版本)</strong></p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Test</td><td>测试方法</td></tr><tr><td>@BeforeEach</td><td>用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。</td></tr><tr><td>@AfterEach</td><td>用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次。</td></tr><tr><td>@BeforeAll</td><td>用来静态修饰方法，该方法会在所有测试方法之前只执行一次。</td></tr><tr><td>@AfterAll</td><td>用来静态修饰方法，该方法会在所有测试方法之后只执行一次。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   业务方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">loginName</span><span class="hljs-params">(String loginName , String passWord)</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;admin&quot;</span>.equals(loginName) &amp;&amp; <span class="hljs-string">&quot;123456&quot;</span>.equals(passWord))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;登录成功&quot;</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;用户名或者密码有问题&quot;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectNames</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-number">10</span>/<span class="hljs-number">2</span>);<br>        System.out.println(<span class="hljs-string">&quot;查询全部用户名称成功~~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   测试类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestUserService</span> &#123;<br><br>    <span class="hljs-comment">// 修饰实例方法的</span><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;===before方法执行一次===&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@After</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;===after方法执行一次===&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 修饰静态方法</span><br>    <span class="hljs-meta">@BeforeClass</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeClass</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;===beforeClass方法执行一次===&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@AfterClass</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterClass</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;===afterClass方法执行一次===&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">       测试方法</span><br><span class="hljs-comment">       注意点：</span><br><span class="hljs-comment">            1、必须是公开的，无参数 无返回值的方法</span><br><span class="hljs-comment">            2、测试方法必须使用<span class="hljs-doctag">@Test</span>注解标记。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testLoginName</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserService</span>();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> userService.loginName(<span class="hljs-string">&quot;admin&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>);<br><br>        <span class="hljs-comment">// 进行预期结果的正确性测试：断言。</span><br>        Assert.assertEquals(<span class="hljs-string">&quot;您的登录业务可能出现问题&quot;</span>, <span class="hljs-string">&quot;登录成功&quot;</span>, rs );<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectNames</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserService</span>();<br>        userService.selectNames();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h5><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220430164907424.png" alt="image-20220430164907424"></p><h6 id="反射概述"><a href="#反射概述" class="headerlink" title="反射概述"></a><strong>反射概述</strong></h6><ul><li><p>反射是指对于任何一个Class类，在”运行的时候”都可以直接得到这个类全部成分。</p></li><li><p>在运行时,可以直接得到这个类的构造器对象：Constructor</p></li><li><p>在运行时,可以直接得到这个类的成员变量对象：Field</p></li><li><p>在运行时,可以直接得到这个类的成员方法对象：Method</p></li><li><p>这种运行时动态获取类信息以及动态调用类中成分的能力称为Java语言的反射机制。</p></li></ul><h6 id="反射的关键："><a href="#反射的关键：" class="headerlink" title="反射的关键："></a><strong>反射的关键：</strong></h6><ul><li>反射的第一步都是先得到编译后的Class类对象，然后就可以得到Class的全部成分。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">HelloWorld.java -&gt; javac -&gt; HelloWorld.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">Class</span> c = HelloWorld.class;<br></code></pre></td></tr></table></figure><h6 id="获取类的对象"><a href="#获取类的对象" class="headerlink" title="获取类的对象"></a><strong>获取类的对象</strong></h6><p><strong>方式一：Class c1 =</strong> <strong>Class.forName(“全类名”);</strong></p><p><strong>方式二：Class c2 =</strong> <strong>类名.class</strong></p><p><strong>方式三：Class c3 =</strong> <strong>对象.getClass();</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs jV">/**<br>   目标：反射的第一步：获取Class对象<br> */<br>public class Test &#123;<br>    public static void main(String[] args) throws Exception &#123;<br>        // 1、Class类中的一个静态方法：forName(全限名：包名 + 类名)<br>        Class c = Class.forName(&quot;com.itheima.d2_reflect_class.Student&quot;);<br>        System.out.println(c); // Student.class<br><br>        // 2、类名.class<br>        Class c1 = Student.class;<br>        System.out.println(c1);<br><br>        // 3、对象.getClass() 获取对象对应类的Class对象。<br>        Student s = new Student();<br>        Class c2 = s.getClass();<br>        System.out.println(c2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="使用反射技术获取构造器对象并使用"><a href="#使用反射技术获取构造器对象并使用" class="headerlink" title="使用反射技术获取构造器对象并使用"></a><strong>使用反射技术获取构造器对象并使用</strong></h6><ul><li><p>反射的第一步是先得到类对象，然后从类对象中获取类的成分对象。</p></li><li><p>Class类中用于获取构造器的方法</p></li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Constructor&lt;?&gt;[]  getConstructors()</td><td>返回所有构造器对象的数组（只能拿public的）</td></tr><tr><td>Constructor&lt;?&gt;[]  getDeclaredConstructors()</td><td>返回所有构造器对象的数组，存在就能拿到</td></tr><tr><td>Constructor<T>  getConstructor(Class&lt;?&gt;…  parameterTypes)</td><td>返回单个构造器对象（只能拿public的）</td></tr><tr><td>Constructor<T>  getDeclaredConstructor(Class&lt;?&gt;…  parameterTypes)</td><td>返回单个构造器对象，存在就能拿到</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;无参数构造器执行！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;有参数构造器执行！&quot;</span>);<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：反射_获取Constructor构造器对象.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    反射的第一步是先得到Class类对象。（Class文件）</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    反射中Class类型获取构造器提供了很多的API:</span><br><span class="hljs-comment">         1. Constructor getConstructor(Class... parameterTypes)</span><br><span class="hljs-comment">            根据参数匹配获取某个构造器，只能拿public修饰的构造器，几乎不用！</span><br><span class="hljs-comment">         2. Constructor getDeclaredConstructor(Class... parameterTypes)</span><br><span class="hljs-comment">            根据参数匹配获取某个构造器，只要申明就可以定位，不关心权限修饰符，建议使用！</span><br><span class="hljs-comment">         3. Constructor[] getConstructors()</span><br><span class="hljs-comment">            获取所有的构造器，只能拿public修饰的构造器。几乎不用！！太弱了！</span><br><span class="hljs-comment">         4. Constructor[] getDeclaredConstructors()</span><br><span class="hljs-comment">            获取所有申明的构造器，只要你写我就能拿到，无所谓权限。建议使用！！</span><br><span class="hljs-comment">    小结：</span><br><span class="hljs-comment">        获取类的全部构造器对象： Constructor[] getDeclaredConstructors()</span><br><span class="hljs-comment">            -- 获取所有申明的构造器，只要你写我就能拿到，无所谓权限。建议使用！！</span><br><span class="hljs-comment">        获取类的某个构造器对象：Constructor getDeclaredConstructor(Class... parameterTypes)</span><br><span class="hljs-comment">            -- 根据参数匹配获取某个构造器，只要申明就可以定位，不关心权限修饰符，建议使用！</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestStudent01</span> &#123;<br>    <span class="hljs-comment">// 1. getConstructors:</span><br>    <span class="hljs-comment">// 获取全部的构造器：只能获取public修饰的构造器。</span><br>    <span class="hljs-comment">// Constructor[] getConstructors()</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getConstructors</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// a.第一步：获取类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Student.class;<br>        <span class="hljs-comment">// b.提取类中的全部的构造器对象(这里只能拿public修饰)</span><br>        Constructor[] constructors = c.getConstructors();<br>        <span class="hljs-comment">// c.遍历构造器</span><br>        <span class="hljs-keyword">for</span> (Constructor constructor : constructors) &#123;<br>            System.out.println(constructor.getName() + <span class="hljs-string">&quot;===&gt;&quot;</span> + constructor.getParameterCount());<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">// 2.getDeclaredConstructors():</span><br>    <span class="hljs-comment">// 获取全部的构造器：只要你敢写，这里就能拿到，无所谓权限是否可及。</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getDeclaredConstructors</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// a.第一步：获取类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Student.class;<br>        <span class="hljs-comment">// b.提取类中的全部的构造器对象</span><br>        Constructor[] constructors = c.getDeclaredConstructors();<br>        <span class="hljs-comment">// c.遍历构造器</span><br>        <span class="hljs-keyword">for</span> (Constructor constructor : constructors) &#123;<br>            System.out.println(constructor.getName() + <span class="hljs-string">&quot;===&gt;&quot;</span> + constructor.getParameterCount());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 3.getConstructor(Class... parameterTypes)</span><br>    <span class="hljs-comment">// 获取某个构造器：只能拿public修饰的某个构造器</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getConstructor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// a.第一步：获取类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Student.class;<br>        <span class="hljs-comment">// b.定位单个构造器对象 (按照参数定位无参数构造器 只能拿public修饰的某个构造器)</span><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">cons</span> <span class="hljs-operator">=</span> c.getConstructor();<br>        System.out.println(cons.getName() + <span class="hljs-string">&quot;===&gt;&quot;</span> + cons.getParameterCount());<br>    &#125;<br><br><br>    <span class="hljs-comment">// 4.getConstructor(Class... parameterTypes)</span><br>    <span class="hljs-comment">// 获取某个构造器：只要你敢写，这里就能拿到，无所谓权限是否可及。</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getDeclaredConstructor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// a.第一步：获取类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Student.class;<br>        <span class="hljs-comment">// b.定位单个构造器对象 (按照参数定位无参数构造器)</span><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">cons</span> <span class="hljs-operator">=</span> c.getDeclaredConstructor();<br>        System.out.println(cons.getName() + <span class="hljs-string">&quot;===&gt;&quot;</span> + cons.getParameterCount());<br><br>        <span class="hljs-comment">// c.定位某个有参构造器</span><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">cons1</span> <span class="hljs-operator">=</span> c.getDeclaredConstructor(String.class, <span class="hljs-type">int</span>.class);<br>        System.out.println(cons1.getName() + <span class="hljs-string">&quot;===&gt;&quot;</span> + cons1.getParameterCount());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="Constructor类中用于创建对象的方法"><a href="#Constructor类中用于创建对象的方法" class="headerlink" title="Constructor类中用于创建对象的方法"></a><strong>Constructor类中用于创建对象的方法</strong></h6><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>T newInstance(Object…  initargs)</td><td>根据指定的构造器创建对象</td></tr><tr><td>public  void setAccessible(boolean  flag)</td><td>设置为true,表示取消访问检查，进行暴力反射</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标: 反射_获取Constructor构造器然后通过这个构造器初始化对象。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    反射获取Class中的构造器对象Constructor作用：</span><br><span class="hljs-comment">            也是初始化并得到类的一个对象返回。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Constructor的API:</span><br><span class="hljs-comment">         1. T newInstance(Object... initargs)</span><br><span class="hljs-comment">                创建对象，注入构造器需要的数据。</span><br><span class="hljs-comment">         2. void setAccessible(true)</span><br><span class="hljs-comment">                修改访问权限，true代表暴力攻破权限，false表示保留不可访问权限(暴力反射)</span><br><span class="hljs-comment">    小结：</span><br><span class="hljs-comment">        可以通过定位类的构造器对象。</span><br><span class="hljs-comment">        如果构造器对象没有访问权限可以通过：void setAccessible(true)打开权限</span><br><span class="hljs-comment">        构造器可以通过T newInstance(Object... initargs)调用自己，传入参数！</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestStudent02</span> &#123;<br>    <span class="hljs-comment">// 1.调用构造器得到一个类的对象返回。</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getDeclaredConstructor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// a.第一步：获取类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Student.class;<br>        <span class="hljs-comment">// b.定位单个构造器对象 (按照参数定位无参数构造器)</span><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">cons</span> <span class="hljs-operator">=</span> c.getDeclaredConstructor();<br>        System.out.println(cons.getName() + <span class="hljs-string">&quot;===&gt;&quot;</span> + cons.getParameterCount());<br><br>        <span class="hljs-comment">// 如果遇到了私有的构造器，可以暴力反射</span><br>        cons.setAccessible(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 权限被打开，被打开一次</span><br><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (Student) cons.newInstance();<br>        System.out.println(s);<br><br>        System.out.println(<span class="hljs-string">&quot;-------------------&quot;</span>);<br><br>        <span class="hljs-comment">// c.定位某个有参构造器</span><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">cons1</span> <span class="hljs-operator">=</span> c.getDeclaredConstructor(String.class, <span class="hljs-type">int</span>.class);<br>        System.out.println(cons1.getName() + <span class="hljs-string">&quot;===&gt;&quot;</span> + cons1.getParameterCount());<br><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> (Student) cons1.newInstance(<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-number">1000</span>);<br>        System.out.println(s1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="使用反射技术获取成员变量对象并使用"><a href="#使用反射技术获取成员变量对象并使用" class="headerlink" title="使用反射技术获取成员变量对象并使用"></a><strong>使用反射技术获取成员变量对象并使用</strong></h6><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220430170214454.png" alt="image-20220430170214454"></p><ul><li><p>反射的第一步是先得到类对象，然后从类对象中获取类的成分对象。</p></li><li><p>Class类中用于获取成员变量的方法</p></li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Field[]  getFields()</td><td>返回所有成员变量对象的数组（只能拿public的）</td></tr><tr><td>Field[]  getDeclaredFields()</td><td>返回所有成员变量对象的数组，存在就能拿到</td></tr><tr><td>Field  getField(String  name)</td><td>返回单个成员变量对象（只能拿public的）</td></tr><tr><td>Field  getDeclaredField(String  name)</td><td>返回单个成员变量对象，存在就能拿到</td></tr></tbody></table><p><strong>Field类中用于取值、赋值的方法</strong></p><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>void  set(Object obj, Object value)：</td><td>赋值</td></tr><tr><td>Object  get(Object obj)</td><td>获取值。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     目标：反射_获取Field成员变量对象。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     反射的第一步是先得到Class类对象。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     1、Field getField(String name);</span><br><span class="hljs-comment">            根据成员变量名获得对应Field对象，只能获得public修饰</span><br><span class="hljs-comment">     2.Field getDeclaredField(String name);</span><br><span class="hljs-comment">            根据成员变量名获得对应Field对象，只要申明了就可以得到</span><br><span class="hljs-comment">     3.Field[] getFields();</span><br><span class="hljs-comment">            获得所有的成员变量对应的Field对象，只能获得public的</span><br><span class="hljs-comment">     4.Field[] getDeclaredFields();</span><br><span class="hljs-comment">            获得所有的成员变量对应的Field对象，只要申明了就可以得到</span><br><span class="hljs-comment">     小结：</span><br><span class="hljs-comment">        获取全部成员变量：getDeclaredFields</span><br><span class="hljs-comment">        获取某个成员变量：getDeclaredField</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FieldDemo01</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1.获取全部的成员变量。</span><br><span class="hljs-comment">     * Field[] getDeclaredFields();</span><br><span class="hljs-comment">     *  获得所有的成员变量对应的Field对象，只要申明了就可以得到</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getDeclaredFields</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// a.定位Class对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Student.class;<br>        <span class="hljs-comment">// b.定位全部成员变量</span><br>        Field[] fields = c.getDeclaredFields();<br>        <span class="hljs-comment">// c.遍历一下</span><br>        <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>            System.out.println(field.getName() + <span class="hljs-string">&quot;==&gt;&quot;</span> + field.getType());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">        2.获取某个成员变量对象 Field getDeclaredField(String name);</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getDeclaredField</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// a.定位Class对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Student.class;<br>        <span class="hljs-comment">// b.根据名称定位某个成员变量</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;age&quot;</span>);<br>        System.out.println(f.getName() +<span class="hljs-string">&quot;===&gt;&quot;</span> + f.getType());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：反射获取成员变量: 取值和赋值。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Field的方法：给成员变量赋值和取值</span><br><span class="hljs-comment">        void set(Object obj, Object value)：给对象注入某个成员变量数据</span><br><span class="hljs-comment">        Object get(Object obj):获取对象的成员变量的值。</span><br><span class="hljs-comment">        void setAccessible(true);暴力反射，设置为可以直接访问私有类型的属性。</span><br><span class="hljs-comment">        Class getType(); 获取属性的类型，返回Class对象。</span><br><span class="hljs-comment">        String getName(); 获取属性的名称。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FieldDemo02</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setField</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// a.反射第一步，获取类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Student.class;<br>        <span class="hljs-comment">// b.提取某个成员变量</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">ageF</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;age&quot;</span>);<br><br>        ageF.setAccessible(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 暴力打开权限</span><br><br>        <span class="hljs-comment">// c.赋值</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        ageF.set(s , <span class="hljs-number">18</span>);  <span class="hljs-comment">// s.setAge(18);</span><br>        System.out.println(s);<br><br>        <span class="hljs-comment">// d、取值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) ageF.get(s);<br>        System.out.println(age);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="使用反射技术获取方法对象并使用"><a href="#使用反射技术获取方法对象并使用" class="headerlink" title="使用反射技术获取方法对象并使用"></a><strong>使用反射技术获取方法对象并使用</strong></h6><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220430171323459-165154597765923.png" alt="image-20220430171323459"></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Method[]  getMethods()</td><td>返回所有成员方法对象的数组（只能拿public的）</td></tr><tr><td>Method[]  getDeclaredMethods()</td><td>返回所有成员方法对象的数组，存在就能拿到</td></tr><tr><td>Method  getMethod(String  name, Class&lt;?&gt;… parameterTypes)</td><td>返回单个成员方法对象（只能拿public的）</td></tr><tr><td>Method  getDeclaredMethod(String  name, Class&lt;?&gt;… parameterTypes)</td><td>返回单个成员方法对象，存在就能拿到</td></tr></tbody></table><p><strong>Method类中用于触发执行的方法</strong></p><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>Object invoke(Object obj, Object… args)</td><td>运行方法  参数一：用obj对象调用该方法  参数二：调用方法的传递的参数（如果没有就不写）  返回值：方法的返回值（如果没有就不写）</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>    <span class="hljs-keyword">private</span> String name ;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;狗跑的贼快~~&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;狗吃骨头&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">eat</span><span class="hljs-params">(String name)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;狗吃&quot;</span> + name);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;吃的很开心！&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inAddr</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;在黑马学习Java!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：反射——获取Method方法对象</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    反射获取类的Method方法对象：</span><br><span class="hljs-comment">         1、Method getMethod(String name,Class...args);</span><br><span class="hljs-comment">             根据方法名和参数类型获得对应的方法对象，只能获得public的</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">         2、Method getDeclaredMethod(String name,Class...args);</span><br><span class="hljs-comment">             根据方法名和参数类型获得对应的方法对象，包括private的</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">         3、Method[] getMethods();</span><br><span class="hljs-comment">             获得类中的所有成员方法对象，返回数组，只能获得public修饰的且包含父类的</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">         4、Method[] getDeclaredMethods();</span><br><span class="hljs-comment">            获得类中的所有成员方法对象，返回数组,只获得本类申明的方法。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Method的方法执行：</span><br><span class="hljs-comment">        Object invoke(Object obj, Object... args)</span><br><span class="hljs-comment">          参数一：触发的是哪个对象的方法执行。</span><br><span class="hljs-comment">          参数二： args：调用方法时传递的实际参数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodDemo01</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1.获得类中的所有成员方法对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getDeclaredMethods</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// a.获取类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Dog.class;<br>        <span class="hljs-comment">// b.提取全部方法；包括私有的</span><br>        Method[] methods = c.getDeclaredMethods();<br>        <span class="hljs-comment">// c.遍历全部方法</span><br>        <span class="hljs-keyword">for</span> (Method method : methods) &#123;<br>            System.out.println(method.getName() +<span class="hljs-string">&quot; 返回值类型：&quot;</span> + method.getReturnType() + <span class="hljs-string">&quot; 参数个数：&quot;</span> + method.getParameterCount());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 2. 获取某个方法对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getDeclardMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// a.获取类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Dog.class;<br>        <span class="hljs-comment">// b.提取单个方法对象</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> c.getDeclaredMethod(<span class="hljs-string">&quot;eat&quot;</span>);<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">m2</span> <span class="hljs-operator">=</span> c.getDeclaredMethod(<span class="hljs-string">&quot;eat&quot;</span>, String.class);<br><br>        <span class="hljs-comment">// 暴力打开权限了</span><br>        m.setAccessible(<span class="hljs-literal">true</span>);<br>        m2.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-comment">// c.触发方法的执行</span><br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        <span class="hljs-comment">// 注意：方法如果是没有结果回来的，那么返回的是null.</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> m.invoke(d);<br>        System.out.println(result);<br><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result2</span> <span class="hljs-operator">=</span> m2.invoke(d, <span class="hljs-string">&quot;骨头&quot;</span>);<br>        System.out.println(result2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="反射的作用——绕过编译阶段为集合添加数据"><a href="#反射的作用——绕过编译阶段为集合添加数据" class="headerlink" title="反射的作用——绕过编译阶段为集合添加数据****"></a><strong>反射的作用</strong>——绕过编译阶段为集合添加数据****</h6><ul><li>反射是作用在运行时的技术，此时集合的泛型将不能产生约束了，此时是可以为集合存入其他任意类型的元素的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-number">100</span>);<br><span class="hljs-comment">// list.add(“黑马&quot;); // 报错</span><br>list.add(<span class="hljs-number">99</span>);<br></code></pre></td></tr></table></figure><ul><li>泛型只是在编译阶段可以约束集合只能操作某种数据类型，在编译成Class文件进入运行阶段的时候，其真实类型都是ArrayList了，泛型相当于被擦除了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 需求：反射实现泛型擦除后，加入其他类型的元素</span><br>        ArrayList&lt;String&gt; lists1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        ArrayList&lt;Integer&gt; lists2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        System.out.println(lists1.getClass());<br>        System.out.println(lists2.getClass());<br><br>        System.out.println(lists1.getClass() ==  lists2.getClass());  <span class="hljs-comment">// ArrayList.class</span><br><br>        System.out.println(<span class="hljs-string">&quot;---------------------------&quot;</span>);<br>        ArrayList&lt;Integer&gt; lists3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        lists3.add(<span class="hljs-number">23</span>);<br>        lists3.add(<span class="hljs-number">22</span>);<br>        <span class="hljs-comment">// lists3.add(&quot;黑马&quot;);</span><br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> lists3.getClass(); <span class="hljs-comment">// ArrayList.class  ===&gt; public boolean add(E e)</span><br>        <span class="hljs-comment">// 定位c类中的add方法</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">add</span> <span class="hljs-operator">=</span> c.getDeclaredMethod(<span class="hljs-string">&quot;add&quot;</span>, Object.class);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> (<span class="hljs-type">boolean</span>) add.invoke(lists3, <span class="hljs-string">&quot;黑马&quot;</span>);<br>        System.out.println(rs);<br><br>        System.out.println(lists3);<br><span class="hljs-comment">//也可以这样</span><br>        <span class="hljs-type">ArrayList</span> <span class="hljs-variable">list4</span> <span class="hljs-operator">=</span> lists3;<br>        list4.add(<span class="hljs-string">&quot;白马&quot;</span>);<br>        list4.add(<span class="hljs-literal">false</span>);<br>        System.out.println(lists3);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="反射做通用框架"><a href="#反射做通用框架" class="headerlink" title="反射做通用框架"></a>反射做通用框架</h6><p>给你任意一个对象，在不清楚对象字段的情况可以，可以把对象的字段名称和对应值存储到文件中去。</p><p><strong>分析</strong></p><p>①定义一个方法，可以接收任意类的对象。</p><p>②每次收到一个对象后，需要解析这个对象的全部成员变量名称。</p><p>③这个对象可能是任意的，那么怎么样才可以知道这个对象的全部成员变量名称呢？</p><p>④使用反射获取对象的Class类对象，然后获取全部成员变量信息。</p><p>⑤遍历成员变量信息，然后提取本成员变量在对象中的具体值</p><p>⑥存入成员变量名称和值到文件中去即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   目标：提供一个通用框架，支持保存所有对象的具体信息。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        s.setName(<span class="hljs-string">&quot;猪八戒&quot;</span>);<br>        s.setClassName(<span class="hljs-string">&quot;西天跑路1班&quot;</span>);<br>        s.setAge(<span class="hljs-number">1000</span>);<br>        s.setHobby(<span class="hljs-string">&quot;吃，睡&quot;</span>);<br>        s.setSex(<span class="hljs-string">&#x27;男&#x27;</span>);<br>        MybatisUtil.save(s);<br><br>        <span class="hljs-type">Teacher</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>();<br>        t.setName(<span class="hljs-string">&quot;波仔&quot;</span>);<br>        t.setSex(<span class="hljs-string">&#x27;男&#x27;</span>);<br>        t.setSalary(<span class="hljs-number">6000</span>);<br>        MybatisUtil.save(t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisUtil</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     保存任意类型的对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> obj</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(Object obj)</span>&#123;<br>        <span class="hljs-keyword">try</span> (<br>                <span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;junit-reflect-annotation-proxy-app/src/data.txt&quot;</span>, <span class="hljs-literal">true</span>));<br>        )&#123;<br>            <span class="hljs-comment">// 1、提取这个对象的全部成员变量：只有反射可以解决</span><br>            <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> obj.getClass();  <span class="hljs-comment">//   c.getSimpleName()获取当前类名   c.getName获取全限名：包名+类名</span><br>            ps.println(<span class="hljs-string">&quot;================&quot;</span> + c.getSimpleName() + <span class="hljs-string">&quot;================&quot;</span>);<br><br>            <span class="hljs-comment">// 2、提取它的全部成员变量</span><br>            Field[] fields = c.getDeclaredFields();<br>            <span class="hljs-comment">// 3、获取成员变量的信息</span><br>            <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> field.getName();<br>                <span class="hljs-comment">// 提取本成员变量在obj对象中的值（取值）</span><br>                field.setAccessible(<span class="hljs-literal">true</span>);<br>                <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> field.get(obj) + <span class="hljs-string">&quot;&quot;</span>;<br>                ps.println(name  + <span class="hljs-string">&quot;=&quot;</span> + value);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="注解概述、作用"><a href="#注解概述、作用" class="headerlink" title="注解概述、作用"></a><strong>注解概述、作用</strong></h6><ul><li><p>Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。</p></li><li><p>Java 语言中的类、构造器、方法、成员变量、参数等都可以被注解进行标注。</p></li></ul><p><strong>注解的作用是什么呢？</strong></p><ul><li><p>对Java中类、方法、成员变量做标记，然后进行特殊处理，至于到底做何种处理由业务需求来决定。</p></li><li><p>例如：JUnit框架中，标记了注解@Test的方法就可以被当成测试方法执行，而没有标记的就不能当成测试方法执行。</p></li></ul><p><strong>自定义注解</strong> <strong>—</strong> <strong>格式</strong></p><p>自定义注解就是自己做一个注解来使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> 注解名称 &#123;<br><span class="hljs-keyword">public</span> 属性类型 属性名() <span class="hljs-keyword">default</span> 默认值 ;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyBook &#123;<br>    String <span class="hljs-title function_">name</span><span class="hljs-params">()</span>;<br>    String[] authors();<br>    <span class="hljs-type">double</span> <span class="hljs-title function_">price</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">   目标：学会自定义注解。掌握其定义格式和语法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@MyBook(name=&quot;《精通JavaSE》&quot;,authors = &#123;&quot;黑马&quot;, &quot;dlei&quot;&#125; , price = 199.5)</span><br><span class="hljs-comment">//@Book(value = &quot;/delete&quot;)</span><br><span class="hljs-comment">// @Book(&quot;/delete&quot;)</span><br><span class="hljs-meta">@Book(value = &quot;/delete&quot;, price = 23.5)</span><br><span class="hljs-comment">//@Book(&quot;/delete&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnnotationDemo1</span> &#123;<br><br>    <span class="hljs-meta">@MyBook(name=&quot;《精通JavaSE2》&quot;,authors = &#123;&quot;黑马&quot;, &quot;dlei&quot;&#125; , price = 199.5)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">AnnotationDemo1</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@MyBook(name=&quot;《精通JavaSE1》&quot;,authors = &#123;&quot;黑马&quot;, &quot;dlei&quot;&#125; , price = 199.5)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-meta">@MyBook(name=&quot;《精通JavaSE2》&quot;,authors = &#123;&quot;黑马&quot;, &quot;dlei&quot;&#125; , price = 199.5)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">21</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>特殊属性</strong></p><ul><li><p>value属性，如果只有一个value属性的情况下，使用value属性的时候可以省略value名称不写!!</p></li><li><p>但是如果有多个属性, 且多个属性没有默认值，那么value名称是不能省略的。</p></li></ul><h6 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h6><ul><li>元注解：就是注解注解的注解。 </li></ul><p><strong>元注解有两个：</strong></p><ul><li><p><strong>@Target</strong>: 约束自定义注解只能在哪些地方使用，</p></li><li><p><strong>@Retention</strong>：申明注解的生命周期</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD,ElementType.FIELD&#125;)</span> <span class="hljs-comment">// 元注解</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="hljs-comment">// 一直活着，在运行阶段这个注解也不消失</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyTest &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>@Target中可使用的值定义在ElementType枚举类中，常用值如下</p><ul><li><p> TYPE，类，接口</p></li><li><p> FIELD, 成员变量</p></li><li><p> METHOD, 成员方法</p></li><li><p> PARAMETER, 方法参数</p></li><li><p> CONSTRUCTOR, 构造器</p></li><li><p> LOCAL_VARIABLE, 局部变量</p></li></ul><p>@Retention中可使用的值定义在RetentionPolicy枚举类中，常用值如下</p><ul><li><p> SOURCE： 注解只作用在源码阶段，生成的字节码文件中不存在</p></li><li><p> CLASS： 注解作用在源码阶段，字节码文件阶段，运行阶段不存在，默认值.</p></li><li><p> RUNTIME：注解作用在源码阶段，字节码文件阶段，运行阶段（开发常用）</p></li></ul><h6 id="注解的解析"><a href="#注解的解析" class="headerlink" title="注解的解析"></a><strong>注解的解析</strong></h6><ul><li>注解的操作中经常需要进行解析，注解的解析就是判断是否存在注解，存在注解就解析出内容。</li></ul><p><strong>与注解解析相关的接口</strong></p><ul><li><p>Annotation: 注解的顶级接口，注解都是Annotation类型的对象</p></li><li><p>AnnotatedElement:该接口定义了与注解解析相关的解析方法</p></li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Annotation[]  getDeclaredAnnotations()</td><td>获得当前对象上使用的所有注解，返回注解数组。</td></tr><tr><td>T getDeclaredAnnotation(Class<T>  annotationClass)</td><td>根据注解类型获得对应注解对象</td></tr><tr><td>boolean isAnnotationPresent(Class<Annotation>  annotationClass)</td><td>判断当前对象是否使用了指定的注解，如果使用了则返回true，否则false</td></tr></tbody></table><p>所有的类成分Class, Method , Field , Constructor，都实现了AnnotatedElement接口他们都拥有解析注解的能力</p><p><strong>解析注解的技巧</strong></p><ul><li><p>注解在哪个成分上，我们就先拿哪个成分对象。</p></li><li><p>比如注解作用成员方法，则要获得该成员方法对应的Method对象，再来拿上面的注解</p></li><li><p>比如注解作用在类上，则要该类的Class对象，再来拿上面的注解</p></li><li><p>比如注解作用在成员变量上，则要获得该成员变量对应的Field对象，再来拿上面的注解</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   目标：完成注解的解析</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnnotationDemo3</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseClass</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// a.先得到类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> BookStore.class;<br>        <span class="hljs-comment">// b.判断这个类上面是否存在这个注解</span><br>        <span class="hljs-keyword">if</span>(c.isAnnotationPresent(Bookk.class))&#123;<br>            <span class="hljs-comment">//c.直接获取该注解对象</span><br>            <span class="hljs-type">Bookk</span> <span class="hljs-variable">book</span> <span class="hljs-operator">=</span> (Bookk) c.getDeclaredAnnotation(Bookk.class);<br>            System.out.println(book.value());<br>            System.out.println(book.price());<br>            System.out.println(Arrays.toString(book.author()));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NoSuchMethodException &#123;<br>        <span class="hljs-comment">// a.先得到类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> BookStore.class;<br><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> c.getDeclaredMethod(<span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-comment">// b.判断这个类上面是否存在这个注解</span><br>        <span class="hljs-keyword">if</span>(m.isAnnotationPresent(Bookk.class))&#123;<br>            <span class="hljs-comment">//c.直接获取该注解对象</span><br>            <span class="hljs-type">Bookk</span> <span class="hljs-variable">book</span> <span class="hljs-operator">=</span> (Bookk) m.getDeclaredAnnotation(Bookk.class);<br>            System.out.println(book.value());<br>            System.out.println(book.price());<br>            System.out.println(Arrays.toString(book.author()));<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Bookk(value = &quot;《情深深雨濛濛》&quot;, price = 99.9, author = &#123;&quot;琼瑶&quot;, &quot;dlei&quot;&#125;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BookStore</span>&#123;<br><br>    <span class="hljs-meta">@Bookk(value = &quot;《三少爷的剑》&quot;, price = 399.9, author = &#123;&quot;古龙&quot;, &quot;熊耀华&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h5><h6 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   模拟用户业务功能</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> &#123;<br>    String <span class="hljs-title function_">login</span><span class="hljs-params">(String loginName , String passWord)</span> ;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectUsers</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">deleteUsers</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateUsers</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">login</span><span class="hljs-params">(String loginName, String passWord)</span>  &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;admin&quot;</span>.equals(loginName) &amp;&amp; <span class="hljs-string">&quot;1234&quot;</span>.equals(passWord)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;登录名和密码可能有毛病&quot;</span>;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectUsers</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;查询了100个用户数据！&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">deleteUsers</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;删除100个用户数据！&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">500</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateUsers</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;修改100个用户数据！&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">2500</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1、把业务对象，直接做成一个代理对象返回，代理对象的类型也是 UserService类型</span><br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> ProxyUtil.getProxy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>());<br>        System.out.println(userService.login(<span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;1234&quot;</span>));<br>        System.out.println(userService.deleteUsers());<br>        userService.selectUsers();<br>        userService.updateUsers(); <span class="hljs-comment">// 走代理</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    public static Object newProxyInstance(ClassLoader loader,  Class&lt;?&gt;[] interfaces, InvocationHandler h)</span><br><span class="hljs-comment">    参数一：类加载器，负责加载代理类到内存中使用。</span><br><span class="hljs-comment">    参数二：获取被代理对象实现的全部接口。代理要为全部接口的全部方法进行代理</span><br><span class="hljs-comment">    参数三：代理的核心处理逻辑</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyUtil</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">      生成业务对象的代理对象。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> obj</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T  <span class="hljs-title function_">getProxy</span><span class="hljs-params">(T obj)</span> &#123;<br>        <span class="hljs-comment">// 返回了一个代理对象了</span><br>        <span class="hljs-keyword">return</span> (T)Proxy.newProxyInstance(obj.getClass().getClassLoader(),<br>                obj.getClass().getInterfaces(),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>                        <span class="hljs-comment">// 参数一：代理对象本身。一般不管</span><br>                        <span class="hljs-comment">// 参数二：正在被代理的方法</span><br>                        <span class="hljs-comment">// 参数三：被代理方法，应该传入的参数</span><br>                       <span class="hljs-type">long</span> <span class="hljs-variable">startTimer</span> <span class="hljs-operator">=</span> System .currentTimeMillis();<br>                        <span class="hljs-comment">// 马上触发方法的真正执行。(触发真正的业务功能)</span><br>                        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(obj, args);<br><br>                        <span class="hljs-type">long</span> <span class="hljs-variable">endTimer</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>                        System.out.println(method.getName() + <span class="hljs-string">&quot;方法耗时：&quot;</span> + (endTimer - startTimer) / <span class="hljs-number">1000.0</span> + <span class="hljs-string">&quot;s&quot;</span>);<br><br>                        <span class="hljs-comment">// 把业务功能方法执行的结果返回给调用者</span><br>                        <span class="hljs-keyword">return</span> result;<br>                    &#125;<br>                &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>业务对象的的每个方法都要进行性能统计，存在大量重复的代码</strong>。</p><h6 id="动态代理-1"><a href="#动态代理-1" class="headerlink" title="动态代理"></a>动态代理</h6><ul><li>代理就是被代理者没有能力或者不愿意去完成某件事情，需要找个人代替自己去完成这件事，动态代理就是用来对业务功能（方法）进行代理的。</li></ul><p>关键步骤</p><p>1.必须有接口，实现类要实现接口（代理通常是基于接口实现的）。</p><p>3.创建一个实现类的对象，该对象为业务对象，紧接着为业务对象做一个代理对象。</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220430192519797-165154600613126.png" alt="image-20220430192519797"></p><p><strong>动态代理的优点</strong></p><ul><li><p>非常的灵活，支持任意接口类型的实现类对象做代理，也可以直接为接本身做代理。</p></li><li><p>可以为被代理对象的所有方法做代理。</p></li><li><p>可以在不改变方法源码的情况下，实现对方法功能的增强。</p></li><li><p>不仅简化了编程工作、提高了软件系统的可扩展性，同时也提高了开发效率。</p></li></ul><h4 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h4><p>XML是可扩展标记语言（eXtensible Markup Language）的缩写，它是是一种数据表示格式，可以描述非常复杂的数据结构，常用于传输和存储数据。</p><h6 id="XML的几个特点和使用场景"><a href="#XML的几个特点和使用场景" class="headerlink" title="XML的几个特点和使用场景"></a><strong>XML的几个特点和使用场景</strong></h6><p>一是纯文本，默认使用UTF-8编码；二是可嵌套；</p><p>l如果把XML内容存为文件，那么它就是一个XML文件。</p><p>XML的使用场景：XML内容经常被当成消息进行网络传输，或者作为配置文件用于存储系统的信息。</p><h6 id="XML的创建"><a href="#XML的创建" class="headerlink" title="XML的创建"></a><strong>XML的创建</strong></h6><p><strong>IDEA创建XML文件的操作步骤</strong></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220501180353162-165154601918229.png" alt="image-20220501180353162"></p><h6 id="XML的标签-元素-规则"><a href="#XML的标签-元素-规则" class="headerlink" title="XML的标签(元素)规则"></a><strong>XML的标签(元素)规则</strong></h6><p>XML的标签(元素)规则</p><p>标签由一对尖括号和合法标识符组成: <name></name>，必须存在一个根标签，有且只能有一个。</p><p>标签必须成对出现，有开始，有结束: <name></name></p><p>特殊的标签可以不成对，但是必须有结束标记，如:<br/></p><p>标签中可以定义属性，属性和标签名空格隔开,属性值必须用引号引起来&lt;student id = “1”&gt;</name></p><p>标签需要正确的嵌套</p><h6 id="XML的其他组成"><a href="#XML的其他组成" class="headerlink" title="XML的其他组成"></a><strong>XML的其他组成</strong></h6><p>XML文件中可以定义注释信息：<!-- 注释内容 --></p><p>XML文件中可以存在以下特殊字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&amp;lt;    &lt;  小于<br>&amp;gt;    &gt;  大于<br>&amp;amp;   &amp;  和号<br>&amp;apos;  <span class="hljs-string">&#x27;  单引号</span><br><span class="hljs-string">&amp;quot;  &quot;  引号</span><br></code></pre></td></tr></table></figure><p>XML文件中可以存在CDATA区: <![CDATA[  …内容… ]]></p><p><strong>由于XML文件可以自定义标签，导致XML文件可以随意定义，程序在解析的时候可能出现问题。</strong></p><h6 id="什么是文档约束？"><a href="#什么是文档约束？" class="headerlink" title="什么是文档约束？"></a><strong>什么是文档约束？</strong></h6><p>文档约束：是用来限定xml文件中的标签以及属性应该怎么写。</p><p>以此强制约束程序员必须按照文档约束的规定来编写xml文件。</p><h6 id="文档约束的分类"><a href="#文档约束的分类" class="headerlink" title="文档约束的分类"></a><strong>文档约束的分类</strong></h6><h6 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h6><p>schema</p><p><strong>需求：</strong>利用DTD文档约束，约束一个XML文件的编写。</p><p><strong>分析：</strong></p><p>①：编写DTD约束文档，后缀必须是.dtd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;!ELEMENT 书架 (书+)&gt;<br>&lt;!ELEMENT 书 (书名,作者,售价)&gt;<br>&lt;!ELEMENT 书名 (#PCDATA)&gt;<br>&lt;!ELEMENT 作者 (#PCDATA)&gt;<br>&lt;!ELEMENT 售价 (#PCDATA)&gt;<br></code></pre></td></tr></table></figure><p>②：在需要编写的XML文件中导入该DTD约束文档</p><p>③：按照约束的规定编写XML文件的内容。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE 书架 <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;data.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">书架</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">书</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">书名</span>&gt;</span>精通JavaSE加强<span class="hljs-tag">&lt;/<span class="hljs-name">书名</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">作者</span>&gt;</span>dlei<span class="hljs-tag">&lt;/<span class="hljs-name">作者</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">售价</span>&gt;</span>很贵<span class="hljs-tag">&lt;/<span class="hljs-name">售价</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">书</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">书</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">书名</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">书名</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">作者</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">作者</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">售价</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">售价</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">书</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">书</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">书名</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">书名</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">作者</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">作者</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">售价</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">售价</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">书</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">书架</span>&gt;</span><br></code></pre></td></tr></table></figure><h6 id="文档约束-schema"><a href="#文档约束-schema" class="headerlink" title="文档约束-schema"></a><strong>文档约束-schema</strong></h6><p>schema可以约束具体的数据类型，约束能力上更强大。</p><p>schema本身也是一个xml文件，本身也受到其他约束文件的要求，所以编写的更加严谨</p><p>1.XML的文档约束-schema的优点？</p><p>可以约束XML文件的标签内容格式，以及具体的数据类型。</p><p>本身也是xml文件，格式更严谨。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">schema</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">targetNamespace</span>=<span class="hljs-string">&quot;http://www.itcast.cn&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">elementFormDefault</span>=<span class="hljs-string">&quot;qualified&quot;</span> &gt;</span><br>    <span class="hljs-comment">&lt;!-- targetNamespace:申明约束文档的地址（命名空间）--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">element</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;书架&#x27;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 写子元素 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">complexType</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- maxOccurs=&#x27;unbounded&#x27;: 书架下的子元素可以有任意多个！--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">sequence</span> <span class="hljs-attr">maxOccurs</span>=<span class="hljs-string">&#x27;unbounded&#x27;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">element</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;书&#x27;</span>&gt;</span><br>                    <span class="hljs-comment">&lt;!-- 写子元素 --&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">complexType</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">sequence</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">element</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;书名&#x27;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;string&#x27;</span>/&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">element</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;作者&#x27;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;string&#x27;</span>/&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">element</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;售价&#x27;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;double&#x27;</span>/&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">sequence</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">complexType</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">element</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">sequence</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">complexType</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">element</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">schema</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">书架</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.itcast.cn&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.itcast.cn data.xsd&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- xmlns=&quot;http://www.itcast.cn&quot;  基本位置</span><br><span class="hljs-comment">         xsi:schemaLocation=&quot;http://www.itcast.cn books02.xsd&quot; 具体的位置 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">书</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">书名</span>&gt;</span>神雕侠侣<span class="hljs-tag">&lt;/<span class="hljs-name">书名</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">作者</span>&gt;</span>金庸<span class="hljs-tag">&lt;/<span class="hljs-name">作者</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">售价</span>&gt;</span>399.9<span class="hljs-tag">&lt;/<span class="hljs-name">售价</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">书</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">书</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">书名</span>&gt;</span>神雕侠侣<span class="hljs-tag">&lt;/<span class="hljs-name">书名</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">作者</span>&gt;</span>金庸<span class="hljs-tag">&lt;/<span class="hljs-name">作者</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">售价</span>&gt;</span>19.5<span class="hljs-tag">&lt;/<span class="hljs-name">售价</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">书</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">书架</span>&gt;</span><br></code></pre></td></tr></table></figure><h6 id="XML解析"><a href="#XML解析" class="headerlink" title="XML解析"></a><strong>XML解析</strong></h6><p>使用程序读取XML中的数据</p><p><strong>两种解析方式</strong></p><p>SAX解析//一行一行</p><p>DOM解析//整个文档解析</p><p><strong>Dom常见的解析工具</strong></p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>JAXP</td><td>SUN公司提供的一套XML的解析的API</td></tr><tr><td>JDOM</td><td>JDOM是一个开源项目，它基于树型结构，利用纯JAVA的技术对XML文档实现解析、生成、序列化以及多种操作。</td></tr><tr><td>dom4j</td><td>是JDOM的升级品，用来读写XML文件的。具有性能优异、功能强大和极其易使用的特点，它的性能超过sun公司官方的dom  技术，同时它也是一个开放源代码的软件，Hibernate也用它来读写配置文件。</td></tr><tr><td>jsoup</td><td>功能强大DOM方式的XML解析开发包，尤其对HTML解析更加方便</td></tr></tbody></table><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220501182543306-165154603584732.png" alt="image-20220501182543306"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20220501182605641-165154605152335.png" alt="image-20220501182605641"></p><h6 id="使用Dom4J解析出XML文件"><a href="#使用Dom4J解析出XML文件" class="headerlink" title="使用Dom4J解析出XML文件"></a>使用Dom4J解析出XML文件</h6><p><strong>需求：</strong>使用Dom4J把一个XML文件的数据进行解析</p><p><strong>分析：</strong></p><p>①下载Dom4j框架，官网下载。</p><p>②在项目中创建一个文件夹：lib</p><p>③将dom4j-2.1.1.jar文件复制到 lib 文件夹</p><p>④在jar文件上点右键，选择 Add as Library -&gt; 点击OK</p><p>⑤在类中导包使用</p><p><strong>Dom4j解析XML-得到Document对象</strong></p><p>SAXReader类</p><table><thead><tr><th>构造器/方法</th><th>说明</th></tr></thead><tbody><tr><td>public SAXReader()</td><td>创建Dom4J的解析器对象</td></tr><tr><td>Document  read(String url)</td><td>加载XML文件成为Document对象</td></tr></tbody></table><p>Document类</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Element getRootElement()</td><td>获得根元素对象</td></tr></tbody></table><p><strong>Dom4j解析XML的元素、属性、文本</strong></p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>List<Element> elements()</td><td>得到当前元素下所有子元素</td></tr><tr><td>List<Element>  elements(String name)</td><td>得到当前元素下指定名字的子元素返回集合</td></tr><tr><td>Element  element(String name)</td><td>得到当前元素下指定名字的子元素,如果有很多名字相同的返回第一个</td></tr><tr><td>String  getName()</td><td>得到元素名字</td></tr><tr><td>String attributeValue(String name)</td><td>通过属性名直接得到属性值</td></tr><tr><td>String  elementText(子元素名)</td><td>得到指定名称的子元素的文本</td></tr><tr><td>String  getText()</td><td>得到文本</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   目标：学会使用dom4j解析XML文件中的数据。</span><br><span class="hljs-comment">    1、导入dom4j框架。</span><br><span class="hljs-comment">    2、准备一个XML文件。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dom4JHelloWorldDemo1</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseXMLData</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1、创建一个Dom4j的解析器对象，代表了整个dom4j框架</span><br>        <span class="hljs-type">SAXReader</span> <span class="hljs-variable">saxReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXReader</span>();<br><br>        <span class="hljs-comment">// 2、把XML文件加载到内存中成为一个Document文档对象</span><br>        <span class="hljs-comment">// Document document = saxReader.read(new File(&quot;xml-app\\src\\Contacts.xml&quot;)); // 需要通过模块名去定位</span><br>        <span class="hljs-comment">// Document document = saxReader.read(new FileInputStream(&quot;xml-app\\src\\Contacts.xml&quot;));</span><br><br>        <span class="hljs-comment">// 注意: getResourceAsStream中的/是直接去src下寻找的文件</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> Dom4JHelloWorldDemo1.class.getResourceAsStream(<span class="hljs-string">&quot;/Contacts.xml&quot;</span>);<br>        <span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span> saxReader.read(is);<br><br>        <span class="hljs-comment">// 3、获取根元素对象</span><br>        <span class="hljs-type">Element</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> document.getRootElement();<br>        System.out.println(root.getName());<br><br>        <span class="hljs-comment">// 4、拿根元素下的全部子元素对象(一级)</span><br>        <span class="hljs-comment">// List&lt;Element&gt; sonEles =  root.elements();</span><br>        List&lt;Element&gt; sonEles =  root.elements(<span class="hljs-string">&quot;contact&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Element sonEle : sonEles) &#123;<br>            System.out.println(sonEle.getName());<br>        &#125;<br><br>        <span class="hljs-comment">// 拿某个子元素</span><br>        <span class="hljs-type">Element</span> <span class="hljs-variable">userEle</span> <span class="hljs-operator">=</span> root.element(<span class="hljs-string">&quot;user&quot;</span>);<br>        System.out.println(userEle.getName());<br><br>        <span class="hljs-comment">// 默认提取第一个子元素对象 (Java语言。)</span><br>        <span class="hljs-type">Element</span> <span class="hljs-variable">contact</span> <span class="hljs-operator">=</span> root.element(<span class="hljs-string">&quot;contact&quot;</span>);<br>        <span class="hljs-comment">// 获取子元素文本</span><br>        System.out.println(contact.elementText(<span class="hljs-string">&quot;name&quot;</span>));<br>        <span class="hljs-comment">// 去掉前后空格</span><br>        System.out.println(contact.elementTextTrim(<span class="hljs-string">&quot;name&quot;</span>));<br>        <span class="hljs-comment">// 获取当前元素下的子元素对象</span><br>        <span class="hljs-type">Element</span> <span class="hljs-variable">email</span> <span class="hljs-operator">=</span> contact.element(<span class="hljs-string">&quot;email&quot;</span>);<br>        System.out.println(email.getText());<br>        <span class="hljs-comment">// 去掉前后空格</span><br>        System.out.println(email.getTextTrim());<br><br>        <span class="hljs-comment">// 根据元素获取属性值</span><br>        <span class="hljs-type">Attribute</span> <span class="hljs-variable">idAttr</span> <span class="hljs-operator">=</span> contact.attribute(<span class="hljs-string">&quot;id&quot;</span>);<br>        System.out.println(idAttr.getName() + <span class="hljs-string">&quot;--&gt;&quot;</span> + idAttr.getValue());<br>        <span class="hljs-comment">// 直接提取属性值</span><br>        System.out.println(contact.attributeValue(<span class="hljs-string">&quot;id&quot;</span>));<br>        System.out.println(contact.attributeValue(<span class="hljs-string">&quot;vip&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需求:利用Dom4J的知识，将Contact.xml文件中的联系人数据封装成List集合，其中每个元素是实体类Contact。打印输出 List 中的每个元素</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">contactList</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">contact</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">vip</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>   潘金莲  <span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">gender</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">gender</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">email</span>&gt;</span>panpan@itcast.cn<span class="hljs-tag">&lt;/<span class="hljs-name">email</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">contact</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">contact</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">vip</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>武松<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">gender</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">gender</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">email</span>&gt;</span>wusong@itcast.cn<span class="hljs-tag">&lt;/<span class="hljs-name">email</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">contact</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">contact</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;3&quot;</span> <span class="hljs-attr">vip</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>武大狼<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">gender</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">gender</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">email</span>&gt;</span>wuda@itcast.cn<span class="hljs-tag">&lt;/<span class="hljs-name">email</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">contact</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">user</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">user</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">contactList</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> &lt;contact id=&quot;1&quot; vip=&quot;true&quot;&gt;</span><br><span class="hljs-comment"> &lt;name&gt;   潘金莲  &lt;/name&gt;</span><br><span class="hljs-comment"> &lt;gender&gt;女&lt;/gender&gt;</span><br><span class="hljs-comment"> &lt;email&gt;panpan@itcast.cn&lt;/email&gt;</span><br><span class="hljs-comment"> &lt;/contact&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Contact</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> vip;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> gender;<br>    <span class="hljs-keyword">private</span> String email;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Contact</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Contact</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> id, <span class="hljs-type">boolean</span> vip, <span class="hljs-type">char</span> gendar, String email)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.vip = vip;<br>        <span class="hljs-built_in">this</span>.gender = gendar;<br>        <span class="hljs-built_in">this</span>.email = email;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isVip</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> vip;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVip</span><span class="hljs-params">(<span class="hljs-type">boolean</span> vip)</span> &#123;<br>        <span class="hljs-built_in">this</span>.vip = vip;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">getGender</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> gender;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setGender</span><span class="hljs-params">(<span class="hljs-type">char</span> gender)</span> &#123;<br>        <span class="hljs-built_in">this</span>.gender = gender;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getEmail</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> email;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEmail</span><span class="hljs-params">(String email)</span> &#123;<br>        <span class="hljs-built_in">this</span>.email = email;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Contact&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, vip=&quot;</span> + vip +<br>                <span class="hljs-string">&quot;, gendar=&quot;</span> + gender +<br>                <span class="hljs-string">&quot;, email=&#x27;&quot;</span> + email + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dom4JTest2</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseToList</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 需求：解析XML中的数据成为一个List集合对象。</span><br>        <span class="hljs-comment">// 1、导入框架（做过）</span><br>        <span class="hljs-comment">// 2、创建SaxReader对象</span><br>        <span class="hljs-type">SAXReader</span> <span class="hljs-variable">saxReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXReader</span>();<br>        <span class="hljs-comment">// 3、加载XML文件成为文档对象Document对象。</span><br>        <span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span><br>                saxReader.read(Dom4JTest2.class.getResourceAsStream(<span class="hljs-string">&quot;/Contacts.xml&quot;</span>));<br>        <span class="hljs-comment">// 4、先拿根元素</span><br>        <span class="hljs-type">Element</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> document.getRootElement();<br>        <span class="hljs-comment">// 5、提取contact子元素</span><br>        List&lt;Element&gt; contactEles = root.elements(<span class="hljs-string">&quot;contact&quot;</span>);<br>        <span class="hljs-comment">// 6、准备一个ArrayList集合封装联系人信息</span><br>        List&lt;Contact&gt; contacts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 7、遍历Contact子元素</span><br>        <span class="hljs-keyword">for</span> (Element contactEle : contactEles) &#123;<br>            <span class="hljs-comment">// 8、每个子元素都是一个联系人对象</span><br>            <span class="hljs-type">Contact</span> <span class="hljs-variable">contact</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Contact</span>();<br>            contact.setId(Integer.valueOf(contactEle.attributeValue(<span class="hljs-string">&quot;id&quot;</span>)));<br>            contact.setVip(Boolean.valueOf(contactEle.attributeValue(<span class="hljs-string">&quot;vip&quot;</span>)));<br>            contact.setName(contactEle.elementTextTrim(<span class="hljs-string">&quot;name&quot;</span>));<br>            contact.setGender(contactEle.elementTextTrim(<span class="hljs-string">&quot;gender&quot;</span>).charAt(<span class="hljs-number">0</span>));<br>            contact.setEmail(contactEle.elementText(<span class="hljs-string">&quot;email&quot;</span>));<br>            <span class="hljs-comment">// 9、把联系人对象数据加入到List集合</span><br>            contacts.add(contact);<br>        &#125;<br>        <span class="hljs-comment">// 10、遍历List集合</span><br>        <span class="hljs-keyword">for</span> (Contact contact : contacts) &#123;<br>            System.out.println(contact);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要从XML文件中检索需要的某个信息（如name）怎么解决？</p><p><strong>Dom4j需要进行文件的全部解析，然后再寻找数据。</strong></p><p><strong>Xpath技术更加适合做信息检索。</strong></p><h6 id="XPath介绍"><a href="#XPath介绍" class="headerlink" title="XPath介绍"></a><strong>XPath介绍</strong></h6><p>XPath在解析XML文档方面提供了一独树一帜的路径思想，更加优雅，高效</p><p>XPath使用路径表达式来定位XML文档中的元素节点或属性节点。</p><p>/元素/子元素/孙元素</p><p>//子元素//孙元素</p><h6 id="需求：使用Dom4J把一个XML文件的数据进行解析"><a href="#需求：使用Dom4J把一个XML文件的数据进行解析" class="headerlink" title="需求：使用Dom4J把一个XML文件的数据进行解析"></a>需求：使用Dom4J把一个XML文件的数据进行解析</h6><p>分析：</p><p>①导入jar包(dom4j和jaxen-1.1.2.jar)，Xpath技术依赖Dom4j技术</p><p>②通过dom4j的SAXReader获取Document对象</p><p>③利用XPath提供的API,结合XPath的语法完成选取XML文档元素节点进行解析操作。</p><p>④Document中与Xpath相关的API如下：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Node  selectSingleNode(“表达式”)</td><td>获取符合表达式的唯一元素</td></tr><tr><td>List<Node> selectNodes(“表达式”)</td><td>获取符合表达式的元素集合</td></tr></tbody></table><h6 id="Xpath的四大检索方案"><a href="#Xpath的四大检索方案" class="headerlink" title="Xpath的四大检索方案"></a><strong>Xpath的四大检索方案</strong></h6><p>绝对路径</p><p>相对路径</p><p>全文检索</p><p>属性查找</p><h6 id="XPath：绝对路径"><a href="#XPath：绝对路径" class="headerlink" title="XPath：绝对路径"></a><strong>XPath：绝对路径</strong></h6><p>采用绝对路径获取从根节点开始逐层的查找/contactList/contact/name节点列表并打印信息</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>/根元素/子元素/孙元素</td><td>从根元素开始，一级一级向下查找，不能跨级</td></tr></tbody></table><h6 id="XPath：相对路径"><a href="#XPath：相对路径" class="headerlink" title="XPath：相对路径"></a><strong>XPath：相对路径</strong></h6><p>先得到根节点contactList</p><p>再采用相对路径获取下一级contact 节点的name子节点并打印信息</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>./子元素/孙元素</td><td>从当前元素开始，一级一级向下查找，不能跨级</td></tr></tbody></table><h6 id="XPath：全文搜索"><a href="#XPath：全文搜索" class="headerlink" title="XPath：全文搜索"></a><strong>XPath：全文搜索</strong></h6><p>直接全文搜索所有的name元素并打印</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>//contact</td><td>找contact元素，无论元素在哪里</td></tr><tr><td>//contact/name</td><td>找contact，无论在哪一级，但name一定是contact的子节点</td></tr><tr><td>//contact//name</td><td>contact无论在哪一种，name只要是contact的子孙元素都可以找到</td></tr></tbody></table><h6 id="XPath：属性查找"><a href="#XPath：属性查找" class="headerlink" title="XPath：属性查找"></a><strong>XPath：属性查找</strong></h6><p>在全文中搜索属性，或者带属性的元素</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>//@属性名</td><td>查找属性对象，无论是哪个元素，只要有这个属性即可。</td></tr><tr><td>//元素[@属性名]</td><td>查找元素对象，全文搜索指定元素名和属性名。</td></tr><tr><td>//元素//[@属性名=‘值’]</td><td>查找元素对象，全文搜索指定元素名和属性名，并且属性值相等。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：XPath检索XML中的信息啊。(了解)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    引入：</span><br><span class="hljs-comment">        Dom4J可以用于解析整个XML的数据。</span><br><span class="hljs-comment">        但是如果要检索XML中的某些信息，建议使用XPath.（Xpath依赖Dom4j技术）</span><br><span class="hljs-comment">        Dom4J用于解析数据，Xpath用于检索数据。</span><br><span class="hljs-comment">    XPath使用步骤：</span><br><span class="hljs-comment">        1.导入dom4j框架。（XPath依赖于Dom4j技术,必须先导入dom4j框架！）</span><br><span class="hljs-comment">        2.导入XPath独有的框架包。jaxen-1.1.2.jar</span><br><span class="hljs-comment">    XPath常用API:</span><br><span class="hljs-comment">        List&lt;Node&gt; selectNodes(String var1):检索出一批节点集合。</span><br><span class="hljs-comment">        Node selectSingleNode(String var1)：检索出一个节点返回。</span><br><span class="hljs-comment">    XPath提供的四种检索数据的写法：</span><br><span class="hljs-comment">        1.绝对路径。</span><br><span class="hljs-comment">        2.相对路径。</span><br><span class="hljs-comment">        3.全文搜索。</span><br><span class="hljs-comment">        4.属性查找。</span><br><span class="hljs-comment">    小结：</span><br><span class="hljs-comment">         1.绝对路径： /根元素/子元素/子元素。</span><br><span class="hljs-comment">         2.相对路径： ./子元素/子元素。 (.代表了当前元素)</span><br><span class="hljs-comment">         3.全文搜索：</span><br><span class="hljs-comment">                //元素  在全文找这个元素</span><br><span class="hljs-comment">                //元素1/元素2  在全文找元素1下面的一级元素2</span><br><span class="hljs-comment">                //元素1//元素2  在全文找元素1下面的全部元素2</span><br><span class="hljs-comment">         4.属性查找。</span><br><span class="hljs-comment">                //@属性名称  在全文检索属性对象。</span><br><span class="hljs-comment">                //元素[@属性名称]  在全文检索包含该属性的元素对象。</span><br><span class="hljs-comment">                //元素[@属性名称=值]  在全文检索包含该属性的元素且属性值为该值的元素对象。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XPathDemo</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     1.绝对路径: /根元素/子元素/子元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parse01</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// a、创建解析器对象</span><br>        <span class="hljs-type">SAXReader</span> <span class="hljs-variable">saxReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXReader</span>();<br>        <span class="hljs-comment">// b、把XML加载成Document文档对象</span><br>        <span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span><br>                saxReader.read(XPathDemo.class.getResourceAsStream(<span class="hljs-string">&quot;/Contacts2.xml&quot;</span>));<br>        <span class="hljs-comment">// c、检索全部的名称</span><br>        List&lt;Node&gt; nameNodes = document.selectNodes(<span class="hljs-string">&quot;/contactList/contact/name&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Node nameNode : nameNodes) &#123;<br>            <span class="hljs-type">Element</span>  <span class="hljs-variable">nameEle</span> <span class="hljs-operator">=</span> (Element) nameNode;<br>            System.out.println(nameEle.getTextTrim());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     2.相对路径： ./子元素/子元素。 (.代表了当前元素)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parse02</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// a、创建解析器对象</span><br>        <span class="hljs-type">SAXReader</span> <span class="hljs-variable">saxReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXReader</span>();<br>        <span class="hljs-comment">// b、把XML加载成Document文档对象</span><br>        <span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span><br>                saxReader.read(XPathDemo.class.getResourceAsStream(<span class="hljs-string">&quot;/Contacts2.xml&quot;</span>));<br>        <span class="hljs-type">Element</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> document.getRootElement();<br>        <span class="hljs-comment">// c、检索全部的名称</span><br>        List&lt;Node&gt; nameNodes = root.selectNodes(<span class="hljs-string">&quot;./contact/name&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Node nameNode : nameNodes) &#123;<br>            <span class="hljs-type">Element</span>  <span class="hljs-variable">nameEle</span> <span class="hljs-operator">=</span> (Element) nameNode;<br>            System.out.println(nameEle.getTextTrim());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     3.全文搜索：</span><br><span class="hljs-comment">     //元素  在全文找这个元素</span><br><span class="hljs-comment">     //元素1/元素2  在全文找元素1下面的一级元素2</span><br><span class="hljs-comment">     //元素1//元素2  在全文找元素1下面的全部元素2</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parse03</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// a、创建解析器对象</span><br>        <span class="hljs-type">SAXReader</span> <span class="hljs-variable">saxReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXReader</span>();<br>        <span class="hljs-comment">// b、把XML加载成Document文档对象</span><br>        <span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span><br>                saxReader.read(XPathDemo.class.getResourceAsStream(<span class="hljs-string">&quot;/Contacts2.xml&quot;</span>));<br>        <span class="hljs-comment">// c、检索数据</span><br>        <span class="hljs-comment">//List&lt;Node&gt; nameNodes = document.selectNodes(&quot;//name&quot;);</span><br>        <span class="hljs-comment">// List&lt;Node&gt; nameNodes = document.selectNodes(&quot;//contact/name&quot;);</span><br>        List&lt;Node&gt; nameNodes = document.selectNodes(<span class="hljs-string">&quot;//contact//name&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Node nameNode : nameNodes) &#123;<br>            <span class="hljs-type">Element</span>  <span class="hljs-variable">nameEle</span> <span class="hljs-operator">=</span> (Element) nameNode;<br>            System.out.println(nameEle.getTextTrim());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     4.属性查找。</span><br><span class="hljs-comment">     //@属性名称  在全文检索属性对象。</span><br><span class="hljs-comment">     //元素[@属性名称]  在全文检索包含该属性的元素对象。</span><br><span class="hljs-comment">     //元素[@属性名称=值]  在全文检索包含该属性的元素且属性值为该值的元素对象。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parse04</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// a、创建解析器对象</span><br>        <span class="hljs-type">SAXReader</span> <span class="hljs-variable">saxReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXReader</span>();<br>        <span class="hljs-comment">// b、把XML加载成Document文档对象</span><br>        <span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span><br>                saxReader.read(XPathDemo.class.getResourceAsStream(<span class="hljs-string">&quot;/Contacts2.xml&quot;</span>));<br>        <span class="hljs-comment">// c、检索数据</span><br>        List&lt;Node&gt; nodes = document.selectNodes(<span class="hljs-string">&quot;//@id&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Node node : nodes) &#123;<br>            <span class="hljs-type">Attribute</span> <span class="hljs-variable">attr</span> <span class="hljs-operator">=</span> (Attribute) node;<br>            System.out.println(attr.getName() + <span class="hljs-string">&quot;===&gt;&quot;</span> + attr.getValue());<br>        &#125;<br><br>        <span class="hljs-comment">// 查询name元素（包含id属性的）</span><br><span class="hljs-comment">//      Node node = document.selectSingleNode(&quot;//name[@id]&quot;);</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> document.selectSingleNode(<span class="hljs-string">&quot;//name[@id=888]&quot;</span>);<br>        <span class="hljs-type">Element</span> <span class="hljs-variable">ele</span> <span class="hljs-operator">=</span> (Element) node;<br>        System.out.println(ele.getTextTrim());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h5><h6 id="什么是工厂设计模式？"><a href="#什么是工厂设计模式？" class="headerlink" title="什么是工厂设计模式？"></a><strong>什么是工厂设计模式？</strong></h6><ul><li><p>之前我们创建类对象时, 都是使用new 对象的形式创建,在很多业务场景下也提供了不直接new的方式 。</p></li><li><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一， 这种类型的设计模式属于创建型模式，它提供了一种获取对象的方式。</p></li></ul><h6 id="工厂设计模式的作用："><a href="#工厂设计模式的作用：" class="headerlink" title="工厂设计模式的作用："></a><strong>工厂设计模式的作用：</strong></h6><p>工厂的方法可以封装对象的创建细节，比如：为该对象进行加工和数据注入。</p><p>可以实现类与类之间的解耦操作（核心思想）。（不想用了只需要改名字）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FactoryPattern</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">       定义一个方法，创建对象返回</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Computer <span class="hljs-title function_">createComputer</span><span class="hljs-params">(String info)</span>&#123;<br>        <span class="hljs-keyword">switch</span> (info)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;huawei&quot;</span>:<br>                <span class="hljs-type">Computer</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Huawei</span>();<br>                c.setName(<span class="hljs-string">&quot;huawei pro 16&quot;</span>);<br>                c.setPrice(<span class="hljs-number">5999</span>);<br>                <span class="hljs-keyword">return</span> c;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;mac&quot;</span>:<br>                <span class="hljs-type">Computer</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mac</span>();<br>                c2.setName(<span class="hljs-string">&quot;MacBook pro&quot;</span>);<br>                c2.setPrice(<span class="hljs-number">11999</span>);<br>                <span class="hljs-keyword">return</span> c2;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    目标：工厂模式。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    什么是工厂设计模式？</span><br><span class="hljs-comment">            工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。</span><br><span class="hljs-comment">            这种类型的设计模式属于创建型模式，它提供了一种创建对象的方式。</span><br><span class="hljs-comment">            之前我们创建类对象时, 都是使用new 对象的形式创建, 除new 对象方式以外,</span><br><span class="hljs-comment">            工厂模式也可以创建对象。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    工厂设计模式的作用：</span><br><span class="hljs-comment">            1.对象通过工厂的方法创建返回，工厂的方法可以为该对象进行加工和数据注入。</span><br><span class="hljs-comment">            2.可以实现类与类之间的解耦操作（核心思想，重点）</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    小结：</span><br><span class="hljs-comment">        工厂模式的思想是提供一个工厂方法返回对象！</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FactoryDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Computer</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> FactoryPattern.createComputer(<span class="hljs-string">&quot;huawei&quot;</span>);<br>        c1.start();<br><br>        <span class="hljs-type">Computer</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> FactoryPattern.createComputer(<span class="hljs-string">&quot;mac&quot;</span>);<br>        c2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="什么是装饰设计模式？"><a href="#什么是装饰设计模式？" class="headerlink" title="什么是装饰设计模式？"></a><strong>什么是装饰设计模式？</strong></h6><ul><li>创建一个新类，包装原始类，从而在新类中提升原来类的功能。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">InputStream</span><span class="hljs-params">(抽象父类)</span></span><br><span class="hljs-function"><span class="hljs-title">FileInputStream</span><span class="hljs-params">(实现子类，读写性能较差)</span></span><br><span class="hljs-function"><span class="hljs-title">BufferedInputStream</span><span class="hljs-params">(实现子类，装饰类，读写性能高)</span></span><br></code></pre></td></tr></table></figure><ul><li><p>定义父类。</p></li><li><p>定义原始类，继承父类，定义功能。</p></li><li><p>定义装饰类，继承父类，包装原始类，增强功能！！</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   共同父类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputStream</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] buffer)</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">   原始类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStream</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;低性能的方式读取了一个字节a&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">97</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] buffer)</span> &#123;<br>        buffer[<span class="hljs-number">0</span>] = <span class="hljs-number">97</span>;<br>        buffer[<span class="hljs-number">1</span>] = <span class="hljs-number">98</span>;<br>        buffer[<span class="hljs-number">2</span>] = <span class="hljs-number">99</span>;<br>        System.out.println(<span class="hljs-string">&quot;低性能的方式读取了一个字节数组：&quot;</span> + Arrays.toString(buffer));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">   装饰类：继承InputStream 拓展原始类的功能</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStream</span>&#123;<br>    <span class="hljs-keyword">private</span> InputStream is;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BufferedInputStream</span><span class="hljs-params">(InputStream is)</span>&#123;<br>        <span class="hljs-built_in">this</span>.is = is;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;提供8KB的缓冲区，提高读数据性能~~~~&quot;</span>);<br>        <span class="hljs-keyword">return</span> is.read();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] buffer)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;提供8KB的缓冲区，提高读数据性能~~~~&quot;</span>);<br>        <span class="hljs-keyword">return</span> is.read(buffer);<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  装饰模式</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    定义父类：InputStream</span><br><span class="hljs-comment">    定义实现类：FileInputStream 继续父类 定义功能</span><br><span class="hljs-comment">    定义装饰实现类：BufferedInputStream 继承父类 定义功能 包装原始类，增强功能。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DecoratorPattern</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>());<br>        System.out.println(is.read());<br>        System.out.println(is.read(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">3</span>]));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JAVA学习</category>
      
      <category>java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CLion&amp;Navicat</title>
    <link href="/2023/03/20/CLion&amp;Navicat/"/>
    <url>/2023/03/20/CLion&amp;Navicat/</url>
    
    <content type="html"><![CDATA[<p><a href="https://willwoodson.github.io/">作者</a></p><h1 id="Navicat"><a href="#Navicat" class="headerlink" title="Navicat"></a>Navicat</h1><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310178.png" alt="image-20230309175032787" style="zoom:50%;" /><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://baijiahao.baidu.com/s?id=1740971973625189531&wfr=spider&for=pc">Navicat16破解 Navicat最新版破解教程「永久激活，亲测有效」</a></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><a href="https://www.navicat.com.cn/company/aboutus/blog/478-%E4%BD%BF%E7%94%A8-navicat-16-%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E5%BA%93.html">使用 Navicat 16 创建测试数据库</a></p><p><a href="https://www.bilibili.com/video/BV1Ni4y1c7sG/?spm_id_from=333.337.search-card.all.click&vd_source=3f77123f4c4359b83bca0e12557bdf5c">使用navicat连接mysql数据库创建数据库、表、转储sql文件，导入sql数据</a></p><p><a href="https://www.bilibili.com/video/BV1vV411Y7V3/?spm_id_from=333.337.search-card.all.click&vd_source=3f77123f4c4359b83bca0e12557bdf5c">【Am】神兵利器-Navicat在工作中的所有使用技巧总结</a></p><h1 id="CLion"><a href="#CLion" class="headerlink" title="CLion"></a>CLion</h1><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310179.png" alt="image-20230309175141233" style="zoom:50%;" /><p>CLion是JetBrains公司旗下发布的一款跨平台C/C++/Rust IDE开发工具。</p><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p><a href="https://www.bilibili.com/read/cv21621826/">2023年Clion最新版安装破解激活教程，永久免费使用</a></p><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p><a href="https://www.jianshu.com/p/371066499570">clion远程开发|linux开发环境|跨平台开发|ssh连接远程主机</a></p><p>在 windows上用 clion开发 c++，之前 clion用 mingw的环境，但后面遇到 mingw头文件有些不全，或者 linux里的个别函数没有，会导致 IDE报错，虽然最终不会影响在 linux上编译，但是写代码会很别扭，开发效率降低。</p><p>想到 Source Insight软件可以用 ssh远程加载虚拟机 linux上的项目文件，然后可以更好的查看代码。<br> 在 virtual studio 201*上可以进行 c-linux跨平台开发，连接 linux后，可以直接在 linux上创建项目，在 windows上拥有 linux的开发环境。</p><p>试想 clion应该也可以。确实可以，设置起来也还算简单。</p><p>=================<br> 0，先在 windows本地打开一个原有的项目，或者创建一个空项目，反正要先打开一个项目。<br> 虚拟机 linux上面不用下载额外的工具，只需要 clion一个软件 和 项目程序能够运行的 linux环境 就可以。</p><p>1，先看我用的软件版本</p><p>2，之前配置 mingw的情况</p><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310180.png" alt="image-20230309164507118" style="zoom: 50%;" /><p>001_mingw.png</p><p>3，打开 file -&gt; settings -&gt; toolchains 在工具链添加远程主机</p><p><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310181.png" alt="image-20230309164518187"></p><p>4，点击 deploment 设置部署</p><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310182.png" alt="image-20230309164534007" style="zoom:50%;" /><p>003_deployment.png</p><p>或者是在 tools -&gt; deploment 打开部署设置</p><p><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310183.png" alt="image-20230309164541736"></p><p>004_deployment2.png</p><p>5，这里我使用软件自带的 ssh会话工具，你可以用其他的</p><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310184.png" alt="image-20230309164547948" style="zoom:50%;" /><p>005_ssh_session.png</p><p>6，关于本地项目文件修改后 同步到远程项目的事情，软件会自己同步，有时候可能需要你自己手动同步修改的文件。</p><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310185.png" alt="image-20230309164555198" style="zoom:50%;" /><p>006_sync.png</p><p>7，也可以设置自动同步，即使不设置，clion自己也会将更新的修改同步到远程。</p><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310186.png" alt="image-20230309164604779" style="zoom:50%;" /><p>007_auto_sync.png</p><p>8，然后开始写代码，可以看到头文件不是 mingw的，而是虚拟机 linux上的。</p><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310187.png" alt="image-20230309164611878" style="zoom:50%;" /><p>008_head_file.png</p><p>9，代码提示1</p><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310188.png" alt="image-20230309164618457" style="zoom:50%;" /><p>009_tip1.png</p><p>10，代码提示2</p><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310189.png" alt="image-20230309164627616" style="zoom:50%;" /><p>010_tip2.png</p><p>11，函数参数提示</p><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310190.png" alt="image-20230309164704778" style="zoom:50%;" /><p>011_tip3.png</p><p>12，运行前要到 settings -&gt; cmake 设置dubug的工具链为 remote host。</p><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310191.png" alt="image-20230309164718041" style="zoom:50%;" /><p>012_debug.png</p><p>13，然后可能要重新加载一下当前项目。</p><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310192.png" alt="image-20230309164727810" style="zoom:50%;" /><p>013_reload.png</p><p>14，点击右上角的绿色三角形，执行程序。</p><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310193.png" alt="image-20230309164734795" style="zoom:50%;" /><p>014_cout.png</p><p>=======================================================================================<br> 15，以上就是整个流程，clion可能会在 linux的 /tmp目录生成文件，那些文件会自动删除。</p><p>16，这是 jetbrains关于远程开发的帮助文档，或许有用。</p><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310194.png" alt="image-20230309164742583" style="zoom:50%;" /><p>015_help.png</p><p>至此，结束。</p><p>17，后来发现，本地文件的创建和修改 会自动上传到 linux，但本地删除文件后，linux端不会跟着删除文件，我的解决办法，<br> 右键项目，选择部署同步，然后比对差异文件，选中需要删除的删掉。</p><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310195.png" alt="image-20230309164749881" style="zoom:50%;" /><p>diff0.png</p><img src="https://gallery-1302735062.cos.ap-beijing.myqcloud.com/typora/202303152310196.png" alt="image-20230309164756851" style="zoom:50%;" /><p>diff1.png</p><h1 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h1><p><a href="https://blog.csdn.net/qq_43257914/article/details/128409831">cmake超详细入门教程，学不会你捶我~</a></p><p><a href="https://zhuanlan.zhihu.com/p/500002865">CMake 良心教程，教你从入门到入魂</a></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>CLion&amp;Navicat</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>debian安装</title>
    <link href="/2023/03/20/debian%E5%AE%89%E8%A3%85/"/>
    <url>/2023/03/20/debian%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/networkTalent/article/details/123375048">debain安装教程</a></p><p>一 准备工作<br>1.虚拟机软件 VMware 16</p><p><a href="https://www.vmware.com/go/getworkstation-win">https://www.vmware.com/go/getworkstation-win</a></p><p>2.Debian ISO镜像</p><p><a href="https://www.debian.org/download">https://www.debian.org/download</a></p><p>二 创建安装Debain的虚拟机<br>1、打开虚拟软件 vmware workstation16 点击创建虚新的拟机</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/25036d2205b740f5b4ff0c3ab128fc6d.png" alt="img"></p><p>2、选择自定义(高级)选项，然后点击下一步</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/8c110db85161408684d6d12ce466b86f.png" alt="img"></p><p>3.、选择硬件兼容，然后下一步</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/c67a509fcfff4cf1a37e838722d9c21e.png" alt="img"></p><p>4、安装客户机操作系统</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/1115f37b2ba14e5ca894dbcfb0fb9bee.png" alt="img"></p><p> 5、选择需要安装的操作系统，这里选择Linux -&gt; Debian</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/f2c31cc50f264bdca105b91403077ace.png" alt="img"></p><p>6、虚拟机命名</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/7276b5cce24c4eb480788d3336f6d7cc.png" alt="img"></p><p> 7、处理器相关配置</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/c7d8969bd12e4b188736e2b91612acd8.png" alt="img"></p><p> 8、内存配置，如果宿主机内存够用的话，可以适当的给虚拟机内存多一些</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/472cd7ab2eec4289938e3e924a80b99d.png" alt="img"></p><p>9、选择<a href="https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE&spm=1001.2101.3001.7020">虚拟机网络配置</a></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/fce6583363494818b2aefb103c2a5a02.png" alt="img"></p><p> 10、选择I/O控制器类型 按照推荐的即可</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/1002e225d269446caba46c06413c931b.png" alt="img"></p><p>11、选择磁盘类型，按照推荐的即可</p><p> <img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/2422a7c5aae543ecb6ed818e2bdf51b5.png" alt="img"></p><p> 12、创建虚拟磁盘</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/f1ecb29547f04eabb036cedd91cb23e8.png" alt="img"></p><p> 13、为创建的虚拟磁盘分配存储空间，宿主机存储空间充足，可适当分配多一些</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/9a55601c7f8b4867af3254334a84ba2c.png" alt="img"></p><p>14、选择磁盘存储位置</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/1e4e3df114824e8587697704fee4a9cb.png" alt="img"></p><p> 15、配置自定义硬件</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/f34061a819ee421394678b0cd7d3aee2.png" alt="img"></p><p> 16、把提前下载好的ISO镜像，进行相关的选择</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/844a035df8ef44a192f57227491292b2.png" alt="img"></p><p> 17、点击完成即虚拟机创建完成</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/da07529e3dfa40349bc5faf310449e77.png" alt="img"></p><h2 id="三-安装-Debian-11-过程"><a href="#三-安装-Debian-11-过程" class="headerlink" title="三 安装 Debian 11 过程"></a>三 安装 Debian 11 过程</h2><p>1、点击开启之前安装好的虚拟机</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/ad7aacab2b5d478480490e527d541456.png" alt="img"></p><p> 2、把鼠标点击虚拟机空白处，然后使用方向键，选择 图形安装，然后回车</p><p> <img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/5cfc1f93e18d4764b43388d95116aadc.png" alt="img"></p><p> 3、选择安装的语言</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/c49b92e8120042de98c16a8dcb8f3f1b.png" alt="img"></p><p> 4、选择地区</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/f8c8a82b3aaa47f0a8885477710d865c.png" alt="img"></p><p> 5、选择硬盘映射的语言</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/c27a6cb665f14462bced50280aa7a123.png" alt="img"></p><p> 6、开始安装</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/ecf761419b8f4a5d8abf1dbee72cf741.png" alt="img"></p><p> 7、设置主机名</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/c4920d2f71cb4556994bdf372660c01c.png" alt="img"></p><p> 8、配置域名，这里空白即可</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/13c4404c0cd84e51a3f15cb61459f732.png" alt="img"></p><p> 9、为root 用户设置登录密码</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/898e4271943f475c8a73145815fd7c97.png" alt="img"></p><p> 10、创建新用户来替代 root 用户 我们起名叫它 [xiaode]</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/2fb84fe674a64200896310fd52855e4e.png" alt="img"></p><p> 11、</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/8868e11ecb0d4cabba8f310490c7e45c.png" alt="img"></p><p>12、为新创建的 登录账号[xiaode] 创建登录密码</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/b78fb17924b34d8db35dc3c8032497c9.png" alt="img"></p><p> 13、对磁盘进行分区</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/e69795da5874457181a7381df8f8587b.png" alt="img"></p><p> 14、选择需要分区的磁盘</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/b3a2831098154c65b712a93f5a0d9c2b.png" alt="img"></p><p> 15、对磁盘进行分区，选择具体的分区方案</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/4812dc72990244dfae189d277c435577.png" alt="img"></p><p> 16、</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/79e1ea5f0132496fa6685f33360d2432.png" alt="img"></p><p> 17、<a href="https://so.csdn.net/so/search?q=%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA&spm=1001.2101.3001.7020">磁盘分区</a>格式化</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/8617e52ddd7e4df6bf54a0f5ac263100.png" alt="img"></p><p>18、配置软件包管理</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/f53f4e1698334107940f760a0e6259a2.png" alt="img"></p><p> 19、选择Debian 仓库镜像所在的国家</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/efeda4c07af2416686b173c7e9196c36.png" alt="img"></p><p> 20、这里选择的进行地址 为网易163的</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/1c9d25c93ed045d6a117cd10eb6f9ee6.png" alt="img"></p><p> 21、设置代理</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/20b330fa1abe4089abf869b8535474a9.png" alt="img"></p><p> 22、<br><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/f994545ff254453eaf639d0a8e33b68d.png" alt="img"></p><p> 23、选择安装软件</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/0a3b4916ff07404188eb22c5303971ef.png" alt="img"></p><p> 24、安装 GRUB 启动引导器</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/2ef27b2175c6493fa3b9a563c2dc56be.png" alt="img"></p><p>25、安装启动引导器设备</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/7c76a38e1b164203b82f9f718372bb26.png" alt="img"></p><p> 26、软件安装完毕</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/37b593ecce504309a45a71cc42ee5aa0.png" alt="img"></p><p> 27、安装完成 用之前创建的账号[xiaode] 登录系统</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/6c4f740fa30a4bf8b314ada7a0e41cc1.png" alt="img"></p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/60fd65e6b5df4ec69abc62d77d33b3dd.png" alt="img"></p><p> 28、查看安装版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/os-release <br></code></pre></td></tr></table></figure><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/17c5ec529c634077aca2fc32c9da1846.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>debian安装</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建博客</title>
    <link href="/2023/03/18/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/03/18/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="搭建Hexo博客"><a href="#搭建Hexo博客" class="headerlink" title="搭建Hexo博客"></a>搭建Hexo博客</h1><h2 id="1、安装node-js"><a href="#1、安装node-js" class="headerlink" title="1、安装node.js"></a>1、安装node.js</h2><p><a href="https://blog.csdn.net/qq_40712862/article/details/120231621">安装Nodejs</a></p><h2 id="2、注册github"><a href="#2、注册github" class="headerlink" title="2、注册github"></a>2、注册github</h2><p><a href="https://github.com/">github</a></p><h2 id="3、安装hexo"><a href="#3、安装hexo" class="headerlink" title="3、安装hexo"></a>3、安装hexo</h2><p>新建文件夹，打开cmd，输入命令<code>npm install hexo-cli -g</code><br><code>hexo -v</code>出现版本号即安装成功</p><p>卸载hexo：<br>卸载命令：卸载成功后npm文件夹会消失<code>npm uninstall hexo-cli -g</code></p><p>如果遇到权限问题：</p><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/image-20230318105214715.png" alt="image-20230318105214715"></p><p>删除本机电脑用户目录下的.npmrc文件：<code>C:\Users\&#123;当前登录的用户名&#125;\.npmrc</code></p><h2 id="4、生成本地静态网页"><a href="#4、生成本地静态网页" class="headerlink" title="4、生成本地静态网页"></a>4、生成本地静态网页</h2><ul><li><code>hexo init 博客名称</code>初始化</li><li><code>cd 博客名称</code>进入文件夹，<code>npm install</code>安装依赖</li><li><code>hexo g</code>生成静态网页</li><li><code>hexo s</code>打开本地预览</li><li><code>hexo clean</code>，清除缓存文件 db.json 和已生成的静态文件在 ./public/文件夹下</li></ul><h2 id="5、将Hexo部署到Github"><a href="#5、将Hexo部署到Github" class="headerlink" title="5、将Hexo部署到Github"></a>5、将Hexo部署到Github</h2><h3 id="1-Github创建个人仓库"><a href="#1-Github创建个人仓库" class="headerlink" title="1.Github创建个人仓库"></a>1.Github创建个人仓库</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">首先，需要有一个github账号。登上账号后建一个仓库：仓库名为你的用户名.github.<span class="hljs-built_in">io</span>，<br>举例如下：<br>创建一个和你用户名相同的仓库，后面加.github.<span class="hljs-built_in">io</span>，<br>只有这样，将来要部署到GitHub的时候，才会被识别，也就是xxxx.github.<span class="hljs-built_in">io</span>，其中xxx就是你注册GitHub的用户名.<br></code></pre></td></tr></table></figure><h3 id="2-生成ssh添加到Github"><a href="#2-生成ssh添加到Github" class="headerlink" title="2.生成ssh添加到Github"></a>2.生成ssh添加到Github</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">在Github上创建仓库完成之后，需要设置ssh免密登录<br></code></pre></td></tr></table></figure><h3 id="3-打开cmd窗口：执行如下命令："><a href="#3-打开cmd窗口：执行如下命令：" class="headerlink" title="3.打开cmd窗口：执行如下命令："></a>3.打开cmd窗口：执行如下命令：</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;yourname&quot;</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;youremail&quot;</span><br></code></pre></td></tr></table></figure><h3 id="4-接着进入到家目录：C-Users-libinbin，右击打开git-bash-。"><a href="#4-接着进入到家目录：C-Users-libinbin，右击打开git-bash-。" class="headerlink" title="4.接着进入到家目录：C:\Users\libinbin，右击打开git bash 。"></a>4.接着进入到家目录：C:\Users\libinbin，右击打开git bash 。</h3><p>输入：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">ssh-keygen -t rsa -C <span class="hljs-symbol">XXXXXXXXXXXXX@</span>qq.com<br></code></pre></td></tr></table></figure><h3 id="5-接着就会发现C-Users-libinbin下多了一个-ssh目录，打开后有一个公钥，一个私钥。id-rsa-pub是公钥，我们需要打开它，复制里面的内容。"><a href="#5-接着就会发现C-Users-libinbin下多了一个-ssh目录，打开后有一个公钥，一个私钥。id-rsa-pub是公钥，我们需要打开它，复制里面的内容。" class="headerlink" title="5.接着就会发现C:\Users\libinbin下多了一个.ssh目录，打开后有一个公钥，一个私钥。id_rsa.pub是公钥，我们需要打开它，复制里面的内容。"></a>5.接着就会发现C:\Users\libinbin下多了一个.ssh目录，打开后有一个公钥，一个私钥。id_rsa.pub是公钥，我们需要打开它，复制里面的内容。</h3><p>然后进入github：</p><p>点击setings</p><p>进行以下操作</p><p>发现我们需要一个密钥，把我们刚刚复制的密钥粘进去，title随便起</p><p>点击 Add SSH Key</p><h2 id="6-进行部署"><a href="#6-进行部署" class="headerlink" title="6.进行部署"></a>6.进行部署</h2><p>这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 _config.yml，翻到最后，修改为<br>YourgithubName就是你的GitHub账户</p><h3 id="1-修改配置文件"><a href="#1-修改配置文件" class="headerlink" title="1.修改配置文件"></a>1.修改配置文件</h3><p>修改内容：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> git@github.com:你的github名/仓库名.github.io.git<br><span class="hljs-symbol">  branch:</span> main（master）<br></code></pre></td></tr></table></figure><h3 id="2-找到自己的博客路径打开cmd"><a href="#2-找到自己的博客路径打开cmd" class="headerlink" title="2.找到自己的博客路径打开cmd"></a>2.找到自己的博客路径打开cmd</h3><p>这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><h3 id="3-然后依次执行以下命令："><a href="#3-然后依次执行以下命令：" class="headerlink" title="3.然后依次执行以下命令："></a>3.然后依次执行以下命令：</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog">hexo c   #清除缓存文件 db<span class="hljs-variable">.json</span> 和已生成的静态文件 public<br>hexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo <span class="hljs-keyword">generate</span> 的缩写)<br>hexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)注意deploy时会让输个yes<br></code></pre></td></tr></table></figure><p>最后回到github上查看自己的仓库：</p><p>这就表示上传成功。</p><p>现在就可以使用xxx.github.io来访问你的博客啦</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>搭建博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>胡桃真好看</title>
    <link href="/2023/03/18/%E8%83%A1%E6%A1%83/"/>
    <url>/2023/03/18/%E8%83%A1%E6%A1%83/</url>
    
    <content type="html"><![CDATA[<h1 id="胡桃真好看"><a href="#胡桃真好看" class="headerlink" title="胡桃真好看"></a>胡桃真好看</h1><p><img src="https://fastly.jsdelivr.net/gh/xuzengsong/picbed@main//img/hutao.jpg" alt="hutao"></p>]]></content>
    
    
    <categories>
      
      <category>原神</category>
      
      <category>图片</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
